<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Seite 3 | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/page/3/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-27T00:00:35.000Z"><a href="/2018/01/27/CSS-最佳实践-套路（六）-- flex/">2018-01-27</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/27/CSS-最佳实践-套路（六）-- flex/">CSS 最佳实践 + 套路（六） -- flex</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>CSS 弹性盒子（Flexible box 或 Flexbox）</strong>是一种用于在页面上布置元素的布局模式，它的目的是允许容器可以让其子项目（子元素）能够改变宽度、高度、顺序等等，以最佳的方式填充空间（父元素）</p>
<p><strong>弹性盒布局</strong>是指通过调整其内元素的宽高，从而在任何显示设备上实现对可用的显示空间最佳的填充能力</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>与方向无关</li>
<li>实现空间的自动分配，自动对齐</li>
<li>适用于简单的线性布局</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="http://upload-images.jianshu.io/upload_images/9617841-c483db96d0c1e6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flexbox 基本概念"></p>
<h3 id="弹性容器（Flex-container）"><a href="#弹性容器（Flex-container）" class="headerlink" title="弹性容器（Flex container）"></a>弹性容器（Flex container）</h3><p>包含这弹性项目的父元素，通过设置 <code>display: flex | inline-flex</code> 定义弹性容器</p>
<h3 id="弹性项目（Flex-item）"><a href="#弹性项目（Flex-item）" class="headerlink" title="弹性项目（Flex item）"></a>弹性项目（Flex item）</h3><p>弹性容器中的每个子元素都被称为弹性项目</p>
<h3 id="轴（Axis）"><a href="#轴（Axis）" class="headerlink" title="轴（Axis）"></a>轴（Axis）</h3><p>每个弹性框包含两个轴。弹性项目延其依次排列的那根轴称为<strong>主轴（main axis）</strong>，垂直于主轴的那根轴称为<strong>侧轴（cross axis）</strong></p>
<h3 id="方向（direction）"><a href="#方向（direction）" class="headerlink" title="方向（direction）"></a>方向（direction）</h3><hr>
<p><strong>很重要，知道方向才能了解弹性容器上的属性</strong></p>
<hr>
<p><strong>主轴方向</strong>：弹性容器的<strong>主轴起点（main start）</strong>到<strong>主轴终点（main end）</strong>的方向<br><strong>侧轴方向</strong>：弹性容器的<strong>侧轴起点（cross start）</strong>到<strong>侧轴终点（cross end）</strong>的方向</p>
<h1 id="弹性容器属性"><a href="#弹性容器属性" class="headerlink" title="弹性容器属性"></a>弹性容器属性</h1><h3 id="定义弹性容器"><a href="#定义弹性容器" class="headerlink" title="定义弹性容器"></a>定义弹性容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;            // 弹性容器是块级元素</span><br><span class="line">或者</span><br><span class="line">display: inline-flex;  // 弹性容器是行内元素</span><br></pre></td></tr></table></figure>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>确立<strong>主轴</strong>方向，可以改变 main start 到 main end 的方向</p>
<p>值:</p>
<ul>
<li><p><code>flex-direction: row</code> ==&gt; 横向排列弹性项目，方向与内容方向相同（<strong>main start 到 main end 的方向与内容方向相同</strong>）</p>
</li>
<li><p><code>flex-direction: row-reverse</code> ==&gt; 横向排列弹性项目，方向与内容方向相反（<strong>main start 到 main end 的方向与内容方向相反</strong>）</p>
</li>
<li><p><code>flex-direction: column</code> ==&gt; 纵向排列弹性项目，方向与内容方向相同（<strong>main start 到 main end 的方向与内容方向相同</strong>）</p>
</li>
<li><p><code>flex-direction: column-reverse</code> ==&gt; 纵向排列弹性项目，方向与内容方向相反（<strong>main start 到 main end 的方向与内容方向相反</strong>）</p>
</li>
</ul>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>指定 flex 元素是单行显示还是多行显示，可以改变 cross start 到 cross end 的方向</p>
<p>值：</p>
<ul>
<li><p><code>flex-wrap: nowrap</code> ==&gt; 不允许弹性项目换行</p>
</li>
<li><p><code>flex-wrap: wrap</code> ==&gt; 允许弹性项目换行</p>
</li>
<li><p><code>flex-wrap: wrap-server</code> ==&gt; 允许弹性项目换行，cross start 到cross end 的方向颠倒</p>
</li>
</ul>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>这是一个集合属性<br>flex-flow === flex-direction + flex-wrap</p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><strong>主轴方向</strong>上伸缩项目的对齐方式</p>
<p>值：</p>
<ul>
<li><p><code>justify-content: space-between</code> ==&gt; 在主轴方向上均匀分配弹性项目，相邻弹性项目距离相同。主轴方向上的第一个弹性项目和行首对齐，主轴方向上的最后一个弹性项目和行尾对齐</p>
</li>
<li><p><code>justify-content: space-around</code> ==&gt; 在主轴方向上均匀分配弹性项目，相邻弹性项目距离相同。主轴方向上第一个弹性项目到行首的距离和主轴方向上最后一个弹性项目到行尾的距离等于相邻元素距离的一半</p>
</li>
<li><p><code>justify-content: flex-start</code> ==&gt; 弹性项目与主轴起点对齐</p>
</li>
<li><p><code>justify-content: flex-end</code> ==&gt; 弹性项目与主轴终点对齐</p>
</li>
<li><p><code>justify-content: center</code> ==&gt; 弹性项目在主轴起点到主轴终点距离的中点</p>
</li>
</ul>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><strong>侧轴方向</strong>上伸缩项目的对齐方式</p>
<p>值：</p>
<ul>
<li><p><code>align-items: flex-start</code> ==&gt; 弹性项目项与侧轴起点对齐</p>
</li>
<li><p><code>align-items: flex-end</code> ==&gt; 弹性项目与侧轴终点对齐</p>
</li>
<li><p><code>align-items: center</code> ==&gt; 弹性项目在侧轴起点到侧轴终点距离的中点</p>
</li>
</ul>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>多行或者多列的对齐方式</p>
<p>值：</p>
<ul>
<li><code>align-content: space-between</code> ==&gt; 在侧轴方向上均匀分配弹性项目，相邻弹性项目距离相同。主轴方向上的第一个弹性项目和行首对齐，主轴方向上的最后一个弹性项目和行尾对齐</li>
</ul>
<ul>
<li><p><code>align-content: space-around</code> ==&gt; 在侧轴方向上均匀分配弹性项目，相邻弹性项目距离相同。侧轴方向上第一个弹性项目到行首的距离和侧轴方向上最后一个弹性项目到行尾的距离等于相邻元素距离的一半</p>
</li>
<li><p><code>align-content: flex-start</code> ==&gt; 弹性项目项与侧轴起点对齐</p>
</li>
<li><p><code>align-content: flex-end</code> ==&gt; 弹性项目与侧轴终点对齐</p>
</li>
<li><p><code>align-content: center</code> ==&gt; 弹性项目在侧轴起点到侧轴终点距离的中点<br><img src="http://upload-images.jianshu.io/upload_images/9617841-797dc91fac60e84f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="align-content 属性全解"></p>
</li>
</ul>
<h1 id="弹性项目属性"><a href="#弹性项目属性" class="headerlink" title="弹性项目属性"></a>弹性项目属性</h1><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>主轴方向上增长比例。指空间过多时，多余空间分配比例<br>值： <number> ，负值无效</number></p>
<h3 id="flex-shirk"><a href="#flex-shirk" class="headerlink" title="flex-shirk"></a>flex-shirk</h3><p>主轴方向上收缩比例。指空间不足时，溢出空间在每个伸缩项目的收缩比例<br>值： <number> ，负值无效</number></p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>主轴方向上伸缩项目的初始大小<br>值： </p>
<ul>
<li><number> ，负值无效</number></li>
<li><code>content</code> ==&gt; 基于 flex 的伸缩项目的内容自动调整大小</li>
</ul>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex 是一个复合属性<br>flex === flex-grow + flex-shirk + flex-basis</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>主轴方向上弹性项目布局时的顺序<br>值：<number> ，负值有效</number></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>自身的对齐方式<br>值：</p>
<ul>
<li><p><code>align-self: flex-start</code> ==&gt; 弹性项目项与侧轴起点对齐</p>
</li>
<li><p><code>align-self: flex-end</code> ==&gt; 弹性项目与侧轴终点对齐</p>
</li>
<li><p><code>align-self: center</code> ==&gt; 弹性项目在侧轴起点到侧轴终点距离的中点</p>
</li>
</ul>
<h1 id="最佳实践-amp-套路"><a href="#最佳实践-amp-套路" class="headerlink" title="最佳实践 &amp; 套路"></a>最佳实践 &amp; 套路</h1><ol>
<li>垂直水平居中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><p>这里有两个小游戏，可以练习 flex 属性<br><a href="http://flexboxfroggy.com/#zh-cn" target="_blank" rel="noopener">网站一</a><br><a href="http://www.flexboxdefense.com/" target="_blank" rel="noopener">网站二</a> </p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T23:58:06.000Z"><a href="/2018/01/27/CSS-最佳实践-套路（五）-- icon/">2018-01-27</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/27/CSS-最佳实践-套路（五）-- icon/">CSS 最佳实践 + 套路（五） -- icon</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>icon 有很多做法，主要的做法有</p>
<ul>
<li>img 标签</li>
<li>background-image 属性</li>
<li>CSS Sprites </li>
<li>font</li>
<li>svg</li>
<li>纯 CSS 实现</li>
</ul>
<p>在这些方法中，目前最值得推荐的就是 <strong>svg 方法</strong>，其他的大家可以了解一下。</p>
<h1 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./img/xxx.png&quot; alt=&quot;icon&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>此种方法可以自适应宽高，只需要给 img 一个 width 属性或者一个 height 属性即可</p>
<h1 id="background-image-属性"><a href="#background-image-属性" class="headerlink" title="background-image 属性"></a>background-image 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSS：</span><br><span class="line">    div&#123;</span><br><span class="line">        background-image: url(./image/xxx.png);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">HTML:</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h1><p>可以使用<a href="http://css.spritegen.com/" target="_blank" rel="noopener">工具自动生成 Sprites</a> ，之后进行使用，此种方法便是工具的使用</p>
<h1 id="font"><a href="#font" class="headerlink" title="font"></a>font</h1><p>font 方法主要是使用<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里</a>的 Unicode 和 Font class 方法<br><img src="http://upload-images.jianshu.io/upload_images/9617841-ca3bfe98993983c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Font 方法"></p>
<h1 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h1><p>svg 方法是现在最值得推荐的方法<br><strong>SVG</strong>是可缩放矢量图形，是W3C XML的分支语言之一，用于标记可缩放的矢量图形。它支持 CSS 属性</p>
<p>首先去<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里的 iconfont 网站</a></p>
<ol>
<li>选取相应的图标并加入购物车</li>
<li>将购物车中的图标添加至项目</li>
<li>生成 Symbol 代码</li>
<li>拷贝生成的 Symbol 代码，放在 HTML 中</li>
<li><p>引入通用css代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .icon &#123;</span><br><span class="line">       width: 1em; height: 1em;</span><br><span class="line">       vertical-align: -0.15em;</span><br><span class="line">       fill: currentColor;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>挑选相应图标并获取类名，应用于页面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">        &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;</span><br><span class="line">    &lt;/svg&gt;</span><br><span class="line">    ``` </span><br><span class="line">![SVG](http://upload-images.jianshu.io/upload_images/9617841-1b6964ececccf5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">![阿里 iconfont 使用](http://upload-images.jianshu.io/upload_images/9617841-ccdc31dd20104add.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">`&lt;svg&gt;` 属性：</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>width:          // icon 宽度<br>height:          // icon 高度<br>fill:          // icon 颜色<br>stroke:    // 描边<br>vertical-align: top;   //可以用于调整上下间距。<br>```</p>
<h1 id="纯-CSS-实现"><a href="#纯-CSS-实现" class="headerlink" title="纯 CSS 实现"></a>纯 CSS 实现</h1><p>纯 CSS 实现就是使用 CSS 去画一些图标，<a href="http://cssicon.space/#/" target="_blank" rel="noopener">推荐一个网站</a></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:57:26.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（四）-- 移动端适配/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（四）-- 移动端适配/">CSS 最佳实践 + 套路（四） -- 移动端适配</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/node-create-file" target="_blank" rel="noopener">脚本实现自动创建移动端适配的相关文件</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>手机上显示网页是将整个网页缩小，模拟页面宽度 980px ，可以使用 <code>document.documentElement.clientWidth</code> 来获取到页面宽度为 980px。在移动端加上 <code>&lt;meta&gt;</code> 标签才是自适应，否则就是 980px ，即网页整体缩小。</p>
<h1 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&apos; viewport &apos; content=&apos; width=device-width user-scalable=no initial-scale=1.0 maximum=1.0 minimum-scale=1.0 &apos;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><code>width=device-width</code> ==&gt; 网页宽度默认等于屏幕宽度</li>
<li><code>user-scalable=no</code> ==&gt; 用户是否可以缩放</li>
<li><code>initial-scale=1.0</code> ==&gt; 原始缩放比例为 1.0 ，即网页初始大小占屏幕面积的 100%</li>
<li><code>maximum=1.0</code> ==&gt; 最大缩放比例</li>
<li><code>minimum-scale=1.0</code> ==&gt; 最小缩放比例</li>
</ul>
<p><code>&lt;meta&gt;</code> 标签可以防止手机模拟 980px，防止页面在用户双击的时候放大和防止用户横屏</p>
<h1 id="Media-Query-（媒体查询）模块"><a href="#Media-Query-（媒体查询）模块" class="headerlink" title="Media Query （媒体查询）模块"></a>Media Query （媒体查询）模块</h1><p>由一个可选的媒体类型和零个或多个使用媒体功能的限制了样式表范围的表达式组成，即<strong>对媒体进行某些条件的查询</strong></p>
<ol>
<li><p>目前来说只用两种模式 ：</p>
<ul>
<li>移动端 </li>
<li>PC 端 </li>
</ul>
</li>
<li><p>两种技术：</p>
<ul>
<li><strong>mobiles-first</strong> ==&gt; 先做移动端页面后做 PC 端页面（推荐）</li>
<li>desktop-first ==&gt; 先做 PC 端页面后做移动端页面</li>
</ul>
</li>
<li><p>两种方案：</p>
<ul>
<li>移动端和 PC 端分别跳转不同网站（京东、淘宝）</li>
<li>渲染不同的 HTML+CSS（知乎）</li>
</ul>
</li>
</ol>
<h3 id="元素中的-CSS-媒体查询"><a href="#元素中的-CSS-媒体查询" class="headerlink" title=" 元素中的 CSS 媒体查询"></a><link> 元素中的 CSS 媒体查询</h3><p>满足查询条件，则生效，否则不生效。但是无论生效与否<strong>都会下载</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="样式表中的CSS媒体查询"><a href="#样式表中的CSS媒体查询" class="headerlink" title="样式表中的CSS媒体查询"></a>样式表中的CSS媒体查询</h3><p>满足查询条件，则生效，否则不生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 600px) &#123;</span><br><span class="line">  .facet_sidebar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul>
<li><p>and 操作符 ==&gt; 把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(min-width: 700px) and (max-width: 960px) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逗号分隔列表 ==&gt; 使用逗号分隔效果等同于<strong>or逻辑操作符</strong>。当使用逗号分隔的媒体查询时，如果<strong>任何一个媒体查询返回真</strong>，<strong>样式</strong>就是<strong>有效</strong>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>not 操作符 ==&gt; 应用于整个媒体查询，在媒体查询为假时返回真</p>
</li>
<li><p>only 操作符 ==&gt; 防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>说明：</strong>若使用了not或only操作符，必须明确指定一个媒体类型。</p>
<h3 id="媒体特征"><a href="#媒体特征" class="headerlink" title="媒体特征"></a>媒体特征</h3><ul>
<li>device-width ==&gt; 设备宽度</li>
<li>width ==&gt; 宽度。描述了输出设备渲染区域的宽度。接受 <strong>mix/min</strong> 前缀</li>
</ul>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式即不同的屏幕得到不同的样式</p>
<h1 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h1><ul>
<li>px ==&gt; 绝对长度单位，像素</li>
<li>em ==&gt; 相对长度单位，这个单位表示<strong>元素的 <code>font-size</code> 的计算值</strong>。</li>
<li>rem ==&gt; 相对长度单位，这个单位代表<strong>根元素（<html>）</html></strong>的 <code>font-size</code> 大小<br><strong>说明：网页默认的 <code>font-size: 16px</code></strong></li>
<li>vh ==&gt; viewport hight，相对长度单位，视口高度的 1/100。</li>
<li>vw ==&gt; viewport width，相对长度单位，视口宽度的 1/100。<br><strong>说明：vh 和 vw 的兼容性比较差，使用较少</strong></li>
</ul>
<h1 id="动态-REM"><a href="#动态-REM" class="headerlink" title="动态 REM"></a>动态 REM</h1><p>由于手机上分辨率太多，不是做响应式，只能退而求其次</p>
<ul>
<li><strong>百分比布局</strong>：高度问题，宽度不知道具体大小，仅仅知道百分比。造成了宽度不确定导致高度和宽度不能做任何配合</li>
<li><strong>动态REM</strong>：一切单位以宽度为基准（vw 啊，但是 vw 兼容性较差），退而求其次：<strong>rem</strong></li>
</ul>
<p><strong>rem ==&gt; html font-size   =（JS实现）=&gt; page width（页面宽度）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var pageWidth = window.innerWidth</span><br><span class="line">        document.write( &apos;&lt;style&gt;html&#123;font-size:&apos; + pageWidth/10 + &apos;px;&#125;&lt;/style&gt;&apos; )</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">            font-size: 16px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p>
<p>将 rem 变为 pageWidth/100 即可以表示 vw（视口宽度的 1/100），<strong>Chrome 浏览器默认最小字号 12px</strong>，此时的 <code>font-size</code> 被 Chrome 浏览器强制为 <strong>12px</strong>。所以将 rem 变为 pageWidth/10 。</p>
<h1 id="最佳实践-amp-套路"><a href="#最佳实践-amp-套路" class="headerlink" title="最佳实践 &amp; 套路"></a>最佳实践 &amp; 套路</h1><h3 id="SASS-实现将-px-自动变为-rem"><a href="#SASS-实现将-px-自动变为-rem" class="headerlink" title="SASS 实现将 px 自动变为 rem"></a>SASS 实现将 px 自动变为 rem</h3><p><a href="https://www.jianshu.com/p/f1fccdb53f8a" target="_blank" rel="noopener">LUNIX 安装SASS</a><br>SASS 文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@function px( $px )&#123;</span><br><span class="line">  @return $px/$designWidth*10 + rem; // 此处的 10 是 html&#123;font-size:&apos; + pageWidth/10 + &apos;px;&#125; 中的10 </span><br><span class="line">&#125;</span><br><span class="line">$designWidth : 640; // 640 是设计稿的宽度，需要根据设计稿的宽度填写</span><br></pre></td></tr></table></figure></p>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li>移动端中没有 hover 事件，但是有 <strong><a href="https://www.jianshu.com/p/f0df9575a101" target="_blank" rel="noopener">touch 事件</a></strong></li>
<li>移动端中<strong>没有 resize 事件</strong>，并且没有滚动条（隐藏滚动条）</li>
<li>使用相对大小的字体 rem</li>
<li>流动布局，各个区块都是浮动的</li>
<li>选择加载 CSS ，Media Query 模块（CSS3）自动探测屏幕宽度，然后加载相应的 CSS 文件</li>
<li>CSS 的 @media 规则</li>
<li>图片自适应 max-width: 100%;</li>
<li>很小很小的地方使用 px ==&gt; 1px</li>
<li>rem 单位和其他单位混用，例如：<code>font-size: 16px</code></li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:54:17.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（三）-- 堆叠上下文/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（三）-- 堆叠上下文/">CSS 最佳实践 + 套路（三） -- 堆叠上下文</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p>
<ul>
<li>根元素（HTML）</li>
<li><strong>z-index 不为 auto 的 absolute/relative</strong></li>
<li>一个 z-index 值不为 auto 的 flex 项目，即父元素 display: flex/inline-flex</li>
<li>opacity 属性值小于 1 的元素</li>
<li>transform 属性不为 none 的元素</li>
<li>mix-blend-mode 属性值不为 normal 的元素</li>
<li>filter 不为 none 的元素</li>
<li>perspective 值不为 none 的元素</li>
<li>isolation 属性被设置为 isolate 的元素</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即使没有直接指定这些属性的值</li>
<li>-webkit-overflow-scrolling 属性被设置为 touch 的元素</li>
</ul>
<p>#堆叠层级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负z-index(父元素没有position: relative/absolute) &lt; position: static（background-color &lt; border &lt; 负z-index(父元素position: relative/absolute)  &lt; div/块级元素 &lt; 浮动元素 &lt; 浮动元素内的文字/内联元素 &lt; 浮动元素外面的文字/内联元素） &lt; position: relative/absolute &lt; 正z-index</span><br></pre></td></tr></table></figure></p>
<ul>
<li>相同的属性按先后顺序排列</li>
<li>具有相同 <code>position</code> 属性的 + <code>z-index</code> 只能覆盖相同 <code>position</code> 属性（<code>relative === absolute</code>）的元素</li>
</ul>
<h1 id="作用-影响"><a href="#作用-影响" class="headerlink" title="作用 + 影响"></a>作用 + 影响</h1><p>堆叠上下文主要是影响 <code>z-index</code><br><code>z-index: 2</code> 永远在 <code>z-index: 0</code> 的上方么？<br><img src="http://upload-images.jianshu.io/upload_images/9617841-d931d5aaeb0f0ab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 01"><br><img src="http://upload-images.jianshu.io/upload_images/9617841-461257c3d745833f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 02"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-5b575d02cd7bb458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 03"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-c35c60561e808a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 04"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-0ee2aa3c1c265b62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 05"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-868517d973ef2db3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="具体使用示例"></p>
<h1 id="最佳实践-amp-套路"><a href="#最佳实践-amp-套路" class="headerlink" title="最佳实践 &amp; 套路"></a>最佳实践 &amp; 套路</h1><p><code>z-index</code> 需要配合 <code>position: relative | absolute</code> 使用</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:53:08.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（二）-- height & width/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（二）-- height & width/">CSS 最佳实践 + 套路（二） -- height width</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>文档内元素的流动方向</p>
<ul>
<li>内联元素 ==&gt; 从左向右依次流动，若 <code>width</code> 不足，则换行</li>
<li>块级元素 ==&gt; 从上到下依次流动，每个块级元素独占一行</li>
</ul>
<h1 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h1><p>将会影响其祖先元素（块级元素）的 height </p>
<p>脱离文档流的三种方式：</p>
<ul>
<li><code>position: fixed</code> 相对于窗口定位</li>
<li><code>position: absolute</code> 相对于定位包含框定位（<code>position: absolute; top: 100%;</code>）</li>
<li><code>float:</code> 浮动，可以利用 <code>.clearfix</code> 类清除浮动</li>
</ul>
<h1 id="height-问题"><a href="#height-问题" class="headerlink" title="height 问题"></a>height 问题</h1><ul>
<li><code>div</code> （块级元素）==&gt; 由其内部文档流元素的 <code>height</code> 总和<strong>决定</strong>。</li>
<li><code>span</code> （内联元素） ==&gt; <code>span</code> 的 <code>height</code> 决定于具体的字体（<strong>建议行高</strong> + 设计字体的设计师决定）。</li>
</ul>
<h3 id="建议行高"><a href="#建议行高" class="headerlink" title="建议行高"></a>建议行高</h3><p>字体都有一个<strong>建议行高</strong>，每种字体的<strong>建议行高</strong>是不同的。以下面的 <code>span</code> 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style= &apos;font-family: 字体A; font-size: 20px; line-height: 40px;&apos;&gt;字体hug&lt;/span&gt;</span><br><span class="line">&lt;span style= &apos;font-family: 字体B; font-size: 20px; line-height: 40px;&apos;&gt;字体hug&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>两个 <code>span</code> 的字体不同，所以两个 <code>span</code> 的 <code>height</code> 就不相同。</li>
<li><code>font-size: 20px;</code> 指的是英文字母 <code>h</code> 的上部 <strong>距</strong> 英文字母 <code>g</code> 的下部的距离为 <code>20px</code> ，中文汉字会比 <code>20px</code> 偏小一些。</li>
</ul>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li><p>将 <code>line-height</code> 设置的比 <code>font-size</code> 大一些，那么行内元素的 <code>height</code> 将会等于 <code>line-height</code> 的值</p>
</li>
<li><p>内联元素设置 <code>width</code> 和 <code>height</code> 时，不要使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: block;</span><br><span class="line">height: </span><br><span class="line">line-height: </span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure>
<p> <strong>通过添加 <code>padding</code> 从而达到想要的 <code>width</code> 和 <code>height</code> （添加 <code>line-height</code> 明确 <code>height</code>），并且宽度（max-width）自适应</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding: </span><br><span class="line">line-height:</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h3 id="设置一个-height-为-40px-（近似）的-div-其内部包含内敛元素-span-："><a href="#设置一个-height-为-40px-（近似）的-div-其内部包含内敛元素-span-：" class="headerlink" title="设置一个 height 为 40px （近似）的 div ,其内部包含内敛元素 span ："></a>设置一个 <code>height</code> 为 <code>40px</code> （近似）的 <code>div</code> ,其内部包含内敛元素 <code>span</code> ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style= &apos;line-height: 24px; border: 1px solid green; padding: 6px 0;&apos;&gt;</span><br><span class="line">    &lt;span style= &apos;font-size: 14px; border: 1px solid red;&apos;&gt;hug&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="两个-span-两端对齐方法"><a href="#两个-span-两端对齐方法" class="headerlink" title="两个 span 两端对齐方法"></a>两个 <code>span</code> 两端对齐方法</h3><p><code>text-align: justify</code> ==&gt; 定义行内内容（例如文字）如何相对它的块父    元素对齐。<code>text-align</code> 并不控制块元素自己的对齐，只控制它的行内内容    的对齐。<strong>文字向两侧对齐（必须是多行文本）</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">span&#123; </span><br><span class="line">  display: block;</span><br><span class="line">  width:            // 设置宽度，从而让两端对齐</span><br><span class="line">  line-height:    //设置行高和高度，固定下来</span><br><span class="line">  height: </span><br><span class="line">  taxt-align: justify;  //设置两端对齐 </span><br><span class="line">  overflow: hidden;  </span><br><span class="line">&#125;</span><br><span class="line">span::after&#123;   // 设置伪类，从而有第二行。</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>可以将 <code>span</code> 设置为 <code>display: inline-block</code> ，之后在第一个 <code>span</code> 后面加上 <code>&lt;br&gt;</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-6bb605df69f4cd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两端对齐"></p>
<h3 id="文字省略溢出"><a href="#文字省略溢出" class="headerlink" title="文字省略溢出"></a>文字省略溢出</h3><h5 id="单行文本省略溢出"><a href="#单行文本省略溢出" class="headerlink" title="单行文本省略溢出"></a>单行文本省略溢出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis</span><br></pre></td></tr></table></figure>
<h5 id="多行文本省略溢出（css-multi-line-text-ellipsis）"><a href="#多行文本省略溢出（css-multi-line-text-ellipsis）" class="headerlink" title="多行文本省略溢出（css multi line text ellipsis）"></a>多行文本省略溢出（css multi line text ellipsis）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 3; //控制行数</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure>
<h3 id="实现一个-1-1-的-div"><a href="#实现一个-1-1-的-div" class="headerlink" title="实现一个 1:1 的 div"></a>实现一个 1:1 的 div</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">padding-top: 100%;</span><br></pre></td></tr></table></figure>
<h3 id="margin-合并"><a href="#margin-合并" class="headerlink" title="margin 合并"></a><code>margin</code> 合并</h3><p>一个 <code>div</code> 标签中有一个子标签 <code>div</code> ，如果父标签有以下属性，则子标签中的 <code>margin</code>（上下） 属性不会合并。</p>
<ul>
<li>border：</li>
<li>padding: </li>
<li>overflow: hidden;( 不推荐 )</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p>文字和单词、单词和单词都是以<strong>基线</strong>对齐。</p>
</li>
<li><p>内联元素的 <code>padding</code> 、 <code>margin</code> 和 <code>border</code> 不会影响 <code>height</code> ，但是会影响 <code>width</code></p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:51:19.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（一）-- 概述/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（一）-- 概述/">CSS 最佳实践 + 套路（一） -- 概述</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ol>
<li>Google: 关键词 MDN</li>
<li><a href="https://css-tricks.com/" title="null" target="_blank" rel="noopener">CSS Tricks</a></li>
<li><a href="https://www.google.com/search?q=%E9%98%AE%E4%B8%80%E5%B3%B0+css" title="null" target="_blank" rel="noopener">Google: 阮一峰 css</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/category/css/page/25/" title="null" target="_blank" rel="noopener">张鑫旭的 240 多篇 CSS 博客</a></li>
<li><a href="https://tympanus.net/codrops/category/playground/" title="null" target="_blank" rel="noopener">Codrops 炫酷 CSS 效果</a></li>
<li><a href="http://www.ituring.com.cn/book/1695" title="null" target="_blank" rel="noopener">CSS揭秘</a></li>
<li><a href="http://cndevdocs.com/" title="null" target="_blank" rel="noopener">CSS 2.1 中文 spec</a></li>
<li><a href="http://adamschwartz.co/magic-of-css/" title="null" target="_blank" rel="noopener">Magic of CSS</a> 免费在线书<h1 id="引入CSS"><a href="#引入CSS" class="headerlink" title="引入CSS"></a>引入CSS</h1></li>
<li>内联样式 ==&gt; style属性 ==&gt; <code>style= &#39;color: red; width: 200px; height:200px;&#39;</code></li>
<li><p>内嵌样式 ==&gt; <code>style</code> 标签 ==&gt; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">    background: gray;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外联样式 ==&gt; <code>&lt;link&gt;</code> 标签 ==&gt; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel= &apos;stylesheet&apos; href= &apos;&apos;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@import url(./b/css)</code></p>
</li>
</ol>
<h1 id="最佳实践-amp-套路"><a href="#最佳实践-amp-套路" class="headerlink" title="最佳实践 &amp; 套路"></a>最佳实践 &amp; 套路</h1><h3 id="reset-CSS"><a href="#reset-CSS" class="headerlink" title="reset CSS"></a>reset CSS</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*&#123; margin: 0; padding: 0; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6, p&#123; margin: 0; padding: 0; &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>添加到浮动元素的父元素上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><p>元素分类：</p>
<ul>
<li>块级元素：<code>block</code> ==&gt; <code>display: block;</code></li>
<li>内联元素：<code>inline</code> ==&gt; <code>display: inline;</code></li>
<li>内联块级元素：<code>inline-block</code> ==&gt; <code>display: inline-block;</code></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-22T14:13:10.000Z"><a href="/2018/01/22/JS进阶 -- MVC 思想/">2018-01-22</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/22/JS进阶 -- MVC 思想/">JS高级 -- MVC 思想</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MVC 是一种思想，它会让我们写代码时更加简洁、高效、模块化，了解这种方法对于前端程序员来说是很有必要的。首先说明下 MVC 代表的含义：</p>
<ul>
<li>M ==&gt; Model ==&gt; 模型</li>
<li>V ==&gt; View ==&gt; 视图</li>
<li>C ==&gt; Controller ==&gt; 控制器</li>
</ul>
<h1 id="MVC-各自作用"><a href="#MVC-各自作用" class="headerlink" title="MVC 各自作用"></a>MVC 各自作用</h1><p>MVC 主要是按功能划分模块</p>
<ol>
<li>view：js 代码所操纵的视图（HTML），负责显示给用户和通知 controller（控制器）</li>
<li><p>Model：view（视图）所需要的所有的数据操作,包括：</p>
<ul>
<li>初始化数据</li>
<li>读取数据</li>
<li><p>存入数据</p>
<p>负责和向 server（服务器）请求数据和响应 server（服务器） </p>
</li>
</ul>
</li>
<li><p>controller：所有的逻辑操作，负责监控和更新 view（视图） + 调用和接收 model（数据） </p>
</li>
</ol>
<h1 id="MVC-使用技术点"><a href="#MVC-使用技术点" class="headerlink" title="MVC 使用技术点"></a>MVC 使用技术点</h1><ol>
<li><p>立即执行函数，<a href="https://www.jianshu.com/p/e8ad9fdf8e07" target="_blank" rel="noopener">这里</a>有所有的立即执行函数的写法，但是这里推荐大家使用 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;&#125;.call()</span><br></pre></td></tr></table></figure>
<p> 立即执行函数避免了我们是用全局变量，隔离作用域，从而达到了使用局部变量的目的</p>
</li>
<li><p>闭包<br> 闭包就是如果一个函数使用了它范围外的值，那么这个函数 + 这个变量就叫做闭包<br> 闭包使得模块之间可以进行相互访问。具体实现：<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-10ee3cec1d8d6750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包 + 操作局部变量"></p>
<ul>
<li>函数 fn 中局部变量 obj 和 return 的函数构成了闭包</li>
<li>return 的函数便是接口，可以供外部调用，从而来操纵局部变量 obj</li>
<li><strong>外部除了使用函数 fn 的接口，没有任何其他方法可以访问到局部变量 obj</strong></li>
</ul>
</li>
<li><p>全局变量<br>模块与模块之间是在不同的 js 文件中，例如模块2想去操纵模块1的数据，通过上述方式显然是不够的，那么只能退而求其次，使用全局变量。具体实现：<br><img src="http://upload-images.jianshu.io/upload_images/9617841-9012bcc7bdc3e5fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全局变量"><br>通过使用全局变量保存了匿名函数的地址，从而全局都可以使用这个全局属性</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上3种技术点的结合 ==&gt; <strong>立即执行函数 + 闭包 + 全局变量</strong> 实现了 MVC 中 Controller（控制器） 的相应需求，从而让前端更好的使用 MVC 思想</p>
<h4 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h4><ol>
<li>this 的使用，在 MVC 中要着重使用 this </li>
<li>箭头函数，其实在 MVC 中使用箭头函数，主要就是为了 this ，原因在于<strong>箭头函数内外 this 不变</strong></li>
<li>HTML 中每一块都是一个 view ，当我们为 HTML 分块的时候，是可以嵌套的，所以我们的 view 也是可以嵌套的</li>
</ol>
<h1 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    let view = 操纵的 HTML 模块</span><br><span class="line">    let model = &#123;</span><br><span class="line">        init: function()&#123;&#125;,</span><br><span class="line">        fetch: function()&#123;&#125;  // 注意此处最好返回 Promise 对象</span><br><span class="line">        save: function()&#123;&#125;  // 注意此处最好返回 Promise 对象</span><br><span class="line">    &#125;</span><br><span class="line">    let controller = &#123;</span><br><span class="line">        view = null,</span><br><span class="line">        model = null,</span><br><span class="line">        ...... = null,</span><br><span class="line">        init: function()&#123;</span><br><span class="line">            this.view = view</span><br><span class="line">            this.model = model</span><br><span class="line">            ......</span><br><span class="line">            this.bindEvents()</span><br><span class="line">        &#125;,</span><br><span class="line">        bindEvents: function()&#123;</span><br><span class="line">            // 绑定事件，与绑定事件无关的放在 controller 属性上</span><br><span class="line">        &#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    controller.init( controller,model )</span><br><span class="line">    //controller.init.call( controller,view, model )</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p><a href="https://github.com/bowen-wu/resume/blob/master/js/leaveMessage-system-database.js" target="_blank" rel="noopener">代码示例</a></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T09:10:21.000Z"><a href="/2018/01/20/HTTP系列 -- AJAX 进阶/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- AJAX 进阶/">HTTP系列 -- AJAX 进阶</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/master/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">相关代码链接</a></p>
<h1 id="AJAX-设置响应-和-获取请求"><a href="#AJAX-设置响应-和-获取请求" class="headerlink" title="AJAX 设置响应 和 获取请求"></a>AJAX 设置响应 和 获取请求</h1><h3 id="AJAX-设置请求-header"><a href="#AJAX-设置请求-header" class="headerlink" title="AJAX 设置请求 header"></a>AJAX 设置请求 header</h3><p>第一部分：<code>request.open( &#39;POST&#39;, &#39;http://www.baidu.com/search&#39; )</code><br>第二部分：<code>request.setRequestHeader( hander, value )</code><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setRequestHeader( &apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos; )</span><br><span class="line">request.setRequestHeader( &apos;who&apos;, &apos;bowen&apos; )</span><br></pre></td></tr></table></figure></p>
<p>第四部分：<code>request.send( &#39;a=1&amp;b=2&#39; )</code></p>
<h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. POST /search HTTP/1.1</span><br><span class="line">2. Host: www.baidu.com</span><br><span class="line">   Content-Type: application/x-www-form-urlencoded</span><br><span class="line">   who: bowen</span><br><span class="line">   Content-Length: </span><br><span class="line">   Cookie: </span><br><span class="line">3. </span><br><span class="line">4. a=1&amp;b=2</span><br></pre></td></tr></table></figure>
<h3 id="AJAX-获取响应-header"><a href="#AJAX-获取响应-header" class="headerlink" title="AJAX 获取响应 header"></a>AJAX 获取响应 header</h3><p>第一部分：<code>request.status</code> 和 <code>request.statusText</code><br>第二部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.getResponseHeader( headerName ) </span><br><span class="line">request.getAllResponseHeaders()</span><br></pre></td></tr></table></figure></p>
<p>第四部分：<code>request.responseText</code></p>
<h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. HTTP/1.1 200 ok</span><br><span class="line">2. key: value</span><br><span class="line">3. </span><br><span class="line">4. 数据</span><br></pre></td></tr></table></figure>
<h3 id="Node-js（后端）设置响应-header"><a href="#Node-js（后端）设置响应-header" class="headerlink" title="Node.js（后端）设置响应 header"></a>Node.js（后端）设置响应 header</h3><p><a href="https://bowen-wu.github.io/2018/01/19/HTTP%E7%B3%BB%E5%88%97-Node-js/" target="_blank" rel="noopener">详解</a></p>
<h1 id="callback（回调）"><a href="#callback（回调）" class="headerlink" title="callback（回调）"></a>callback（回调）</h1><p>callback 就是一个回调函数，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-580ea1a7bb64c8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callback 示例"></p>
<ol>
<li>给 window 添加一个方法 fn123 ，这个方法接受一个对象 options 。</li>
<li>使用 window 下的方法 fn123 ，并传入一个对象，这个对象有一个方法 fn456 ，它是一个函数。</li>
<li>window 下的 fn123 接受到对象后将调用 fn456，将其 call back</li>
<li>fn456 中接受的 this 就是 window 下的方法中 call 时传的第一个参数，x 就是 call 时传的第二个参数</li>
</ol>
<h1 id="实现-jQuery-ajax"><a href="#实现-jQuery-ajax" class="headerlink" title="实现 jQuery.ajax"></a>实现 jQuery.ajax</h1><ol>
<li><p>首先回顾下 <a href="https://www.jianshu.com/p/3eb5f1c7937e" target="_blank" rel="noopener">window.jQuery</a></p>
</li>
<li><p>将 AJAX-基础 的<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/master/AJAX-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">代码</a> 进行封装，封装为 window.jQuery.ajax，<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/da549df5393a229f1d3e878d27b491755e6e99bb" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>将封装的 window.jQuery.ajax 进行代码优化（给参数命名）。由于传入参数过多，将其参数设置为有结构的数据 ==&gt; 对象，<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/80c6de9166b9efb60b2c34a5fb115aa9d0f61fcf" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>实现传入不定个参数的优化。既可以传入一个对象，也可以传入 url + 对象。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/3ca84506652fa89c4f3854da77420d7f6094e240" target="_blank" rel="noopener">代码地址</a>。此时由于要使用 arguments ，所以不能使用箭头函数。</p>
</li>
<li><p>优化代码，使用 ES6 解构赋值达到优化代码的目的，并增加 request.setRequestHeader() 功能。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/5118accb4c21f0ed2b8da6f2c5677867d238bf51" target="_blank" rel="noopener">代码地址</a>。</p>
</li>
<li><p>如果不实现传入不定个参数，还可以进一步使用 ES6 解构赋值优化。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/88436fc2378cec3a814a96cc3260a5de133038da/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>使用 Promise 规范进行优化，<code>return new Promise(function(resolve,reject){})</code>，成功 === 调用 resolve，失败 === 调用 reject，之后在调用时使用 <code>.then</code> 方法。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/1ea0e7728b98f008f077e7b7f77b2eb80ec77e6b/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>Promise 实现原理</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.Promise = function(fn)&#123;</span><br><span class="line">  // ......</span><br><span class="line">   return &#123;</span><br><span class="line">        then: function()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T09:01:25.000Z"><a href="/2018/01/20/HTTP系列 -- AJAX 基础/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- AJAX 基础/">HTTP系列 -- AJAX 基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/server-Node.js-demo/tree/master/AJAX-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">参考代码</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AJAX（Async JavaScript And XML）：异步 JavaScript 和XML，远程编程脚本，使 JavaScript 能够在 Web 服务器上运行的程序通信，它是一种无需重新加载整个网页的情况之下能够更新部分网页的技术。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>使用 XMLHttpRequest 发请求</li>
<li>服务器返回 XML / <strong>JSON</strong> 格式的<strong>字符串</strong></li>
<li>JS 解析 XML / <strong>JSON</strong>，并更新局部页面<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3>HTTP 的 path（路径）都是绝对路径</li>
</ol>
<h1 id="如何发送请求"><a href="#如何发送请求" class="headerlink" title="如何发送请求"></a>如何发送请求</h1><h3 id="form-表单"><a href="#form-表单" class="headerlink" title="form 表单"></a>form 表单</h3><p>使用 form 表单可以发请求，但是会刷新页面或新开页面<br>    <img src="http://upload-images.jianshu.io/upload_images/9617841-a4cd551b880d7edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-fa120004a4c5d9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送请求"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-9f0cfec4a4ad3a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送 GET 请求"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-13288ee474125f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送 POST 请求"></p>
<h3 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h3><p>使用 a 标签可以发 GET 请求，但是也会刷新页面或新开页面<br><img src="http://upload-images.jianshu.io/upload_images/9617841-f8081f7df640b734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-1b8aad5535592eed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 标签发送 GET 请求"></p>
<h3 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h3><p>使用 img 标签可以发 GET 请求，但是只能以图片的形式展示<br><img src="http://upload-images.jianshu.io/upload_images/9617841-419575e6ec290994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-78c17819094b4e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img 标签发送 GET 请求"></p>
<h3 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h3><p>使用 link 标签可以发 GET 请求，但是只能以 CSS、favicon 的形式展示<br><img src="http://upload-images.jianshu.io/upload_images/9617841-67c1f5fea5f0cd93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-396bbc64663e8d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link 标签发送 GET 请求"></p>
<h3 id="script-标签（JSONP）"><a href="#script-标签（JSONP）" class="headerlink" title="script 标签（JSONP）"></a>script 标签（JSONP）</h3><p>使用 script 标签可以发 GET 请求，但是只能以脚本的形式运行<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b11d2c9d39d32347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="script 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-16b27a15892f6486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="script 标签发送 GET 请求"></p>
<h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p><code>XMLHttpRequest</code> 是一个 API，它为客户端<strong>提供了在客户端和服务器之间传输数据的功能</strong>。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。<code>XMLHttpRequest</code> 在 <a href="https://developer.mozilla.org/zh-CN/docs/AJAX" target="_blank" rel="noopener">AJAX</a> 中被大量使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-15f0d81c590baedd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="挂载在 window 下的 XMLHttpRequest 对象"></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><ul>
<li>类型：function</li>
<li>JavaScript函数对象，当readyState属性改变时会调用它。</li>
</ul>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>类型：Number<br>显示 XMLHttpRequest  代理当前所处的状态，值：</p>
<ul>
<li>0 ==&gt; 代理被创建，但尚未调用 open() 方法</li>
<li>1 ==&gt; open() 方法已经被调用</li>
<li>2 ==&gt; send() 方法已经被调用，并且头部和状态已经可获得</li>
<li>3 ==&gt; 下载中，requestText 属性已经包含部分数据</li>
<li>4 ==&gt; 下载操作以完成</li>
</ul>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><ul>
<li>类型：String<br>响应的文本</li>
</ul>
<h5 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h5><p>设置响应类型，值：</p>
<ul>
<li>“” ==&gt; 字符串（默认值）</li>
<li>“arraybuffer”</li>
<li>“blob”</li>
<li>“document”</li>
<li>“json” ==&gt; JavaScript 对象，解析自服务器传递回来的JSON 字符串</li>
<li>“text” ==&gt; 字符串</li>
</ul>
<h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>请求的响应状态码<br><a href="https://www.jianshu.com/p/036df537e96d" target="_blank" rel="noopener">详见</a></p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p>请求的响应状态信息,包含一个状态码和原因短语（”200 OK”） </p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h5 id="1-open"><a href="#1-open" class="headerlink" title="1. open()"></a>1. open()</h5><p>初始化一个请求。该方法用于JavaScript代码中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open( method, url, async )</span><br></pre></td></tr></table></figure></p>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>methos ==&gt; 请求所使用的HTTP方法</li>
<li>url ==&gt; 该请求所要访问的 URL / 路径</li>
<li>async ==&gt; 默认为true（异步），表示是否执行异步操作</li>
</ul>
<h5 id="2-setRequestHeader"><a href="#2-setRequestHeader" class="headerlink" title="2. setRequestHeader()"></a>2. setRequestHeader()</h5><p>给指定的HTTP请求头赋值.在这之前,你必须确认已经调用 <code>open()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open( &apos;POST&apos;, &apos;/xxx&apos; )</span><br><span class="line">request.setRequestHeader( header, value )</span><br></pre></td></tr></table></figure></p>
<p><strong>request.setRequestHeader( ‘Content-type’ , ‘application/x-www-form=urlcoded’ )</strong></p>
<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><ul>
<li>header ==&gt; 将要被赋值的请求头名称</li>
<li>value ==&gt; 给指定的请求头赋的值</li>
</ul>
<h5 id="3-send"><a href="#3-send" class="headerlink" title="3. send()"></a>3. send()</h5><p>发送请求。如果该请求是异步模式(默认)，该方法会立刻返回。相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回</p>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h5><p>返回所有响应头信息(响应头名和值)，如果响应头还没接受,则返回null</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h5><p>返回指定的响应头的值，如果响应头还没被接受，或该响应头不存在，则返回null</p>
<h1 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h1><p><strong><code>JSON</code></strong>对象包含用于解析 JSON 的方法，并将值转换为 JSON。它不能被调用或者作为构造函数</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><p>解析一个JSON字符串，可选地转换生成的值及其属性，并返回值</p>
<h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p>返回与指定值相对应的一个JSON字符串，可选地仅包含某些属性或以用户定义的方式替换属性值</p>
<h1 id="原生-JavaScript-发送-AJAX-请求"><a href="#原生-JavaScript-发送-AJAX-请求" class="headerlink" title="原生 JavaScript 发送 AJAX 请求"></a>原生 JavaScript 发送 AJAX 请求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest()</span><br><span class="line">//open() 方法有第三个参数，true 为异步（默认），false为同步</span><br><span class="line">request.open( &apos;GET&apos;, &apos;路径&apos; )   // 配置 request </span><br><span class="line"></span><br><span class="line">//request.open( &apos;POST&apos;, &apos;路径&apos; )  </span><br><span class="line">// 配置 request ，如果是 POST 方法，必须设置 setRequestHeader</span><br><span class="line">//request.setRequestHeader( &apos;Content-type&apos; , &apos;application/x-www-form=urlcoded&apos; )</span><br><span class="line"></span><br><span class="line">request.send()</span><br><span class="line">request.onreadystatechange = () =&gt;&#123;</span><br><span class="line">    if( request.readyState === 4 )&#123; //请求响应都完毕了</span><br><span class="line">        if( request.status &gt;= 200 &amp;&amp; request.status &lt; 300 )&#123;</span><br><span class="line">            console.log( &apos;说明请求成功&apos; )</span><br><span class="line">            let string = request.responseText</span><br><span class="line">            // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class="line">            let object = window.JSON.parse( string )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><p>HTTP 第四部分永远是字符串，只不过是符合 JSON 对象语法的字符串（解析 JSON.parse()）</p>
</li>
<li><p>如何判断代码执行时长</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time()</span><br><span class="line">要判断的代码</span><br><span class="line">console.end()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断同步异步</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log( &apos;start&apos; )</span><br><span class="line">要判断的代码</span><br><span class="line">console.log( &apos;end&apos; )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON（JavaScript Object Notation）：JavaScript 对象表示法，它是存储和交换文本信息的语法，类似 XML，它采用键值对的方式来组织，易于人们阅读和编写，同时也易于机器解析和生成。<strong>它是一门新的语言</strong>。</p>
<h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p><a href="https://www.json.org/" target="_blank" rel="noopener">JSON 铁轨图</a><br>JSON 中有 String、null、Number、true、false、Array 和 Object</p>
<h3 id="JSON-和-JavaScript-的区别"><a href="#JSON-和-JavaScript-的区别" class="headerlink" title="JSON 和 JavaScript 的区别"></a>JSON 和 JavaScript 的区别</h3><p>JSON 和 JavaScript 是两门语言，JSON 是抄袭的 JavaScript，两者区别主要体现在：</p>
<ul>
<li>JSON 没有 undefined、function 和 Symbol</li>
<li>JSON 必须使用双引号</li>
<li>JSON 没有变量</li>
<li>JSON 中对象仅仅是一个哈希</li>
</ul>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>当一个资源从与该资源本身所在的服务器不同的域或端口<strong>发送 AJAX</strong> 请求一个资源时，资源会发起一个跨域 HTTP 请求，出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求</p>
</li>
<li><p>只有 AJAX 被限制，其他的都可以（img、form、link 和 script）</p>
</li>
<li><p>原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面的内容，所以浏览器认为这是安全的。而 AJAX 是可以读取相应内容的，因此浏览器将阻止你这样做</p>
</li>
<li><p>如果使用 AJAX 向其他源发送请求，会成功，但是报错（request.status === 0）</p>
</li>
<li><p>AJAX 请求已经发送出去了，却拿不到响应<br>request.status === 0</p>
</li>
<li><p>同源策略本质：一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容，但是浏览器并不阻止向另一个域名发送请求。<strong>只有协议、域名和端口一模一样才允许发送 AJAX 请求</strong></p>
</li>
</ul>
<h3 id="为什么要使用同源策略"><a href="#为什么要使用同源策略" class="headerlink" title="为什么要使用同源策略"></a>为什么要使用同源策略</h3><p><strong>安全</strong>，如果没有同源策略，AJAX 就可以向另一个域名发送 GET / POST 请求，GET 请求可以获取信息，POST 请求可以直接转账，那样互联网就没有隐私可言</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li><p>JSONP：但是 JSONP 有局限，不能发送 POST 请求</p>
</li>
<li><p>CORS（Cross-Orogin Resource Sharing 跨域资源共享）：请求的域名的<strong>后端</strong>需要在相应的接口添加<strong>响应头</strong>，此时就可以发送 POST 请求</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &quot;Access-Control-Allow-Origin&quot;, &quot;http://......&quot; )</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T08:56:11.000Z"><a href="/2018/01/20/HTTP系列 -- JSONP/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- JSONP/">HTTP系列 -- JSONP</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/server-Node.js-demo/tree/master/JSONP" target="_blank" rel="noopener">参考代码</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库是用来长久储存数据的。</p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h4 id="form-表单提交"><a href="#form-表单提交" class="headerlink" title="form 表单提交"></a><code>form</code> 表单提交</h4><p>缺点：刷新页面 + 用户后退 + 用户刷新 = 数据变动</p>
<h4 id="form-iframe-提交"><a href="#form-iframe-提交" class="headerlink" title="form + iframe 提交"></a><code>form</code> + <code>iframe</code> 提交</h4><p><code>form</code> 表单提交到 <code>iframe</code> 中，页面不会刷新。<br>缺点：用户刷新页面  ==&gt;  数据变动</p>
<h4 id="JS动态创建-img-标签"><a href="#JS动态创建-img-标签" class="headerlink" title="JS动态创建 img 标签"></a>JS动态创建 <code>img</code> 标签</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let img = document.createElement(&apos;img&apos;);</span><br><span class="line">img.src = &apos;路径&apos;</span><br><span class="line">img.onload = function()&#123;&#125;  ==&gt;  HTTP状态码</span><br><span class="line">img.onerror = function()&#123;&#125;  ==&gt;  HTTP状态码</span><br></pre></td></tr></table></figure>
</code></pre><p>通过路径，在 Nodejs 中设置成功或者失败，之后返回状态码，前端通过返回的HTTP状态码，进而来判断成功失败。</p>
<h4 id="动态创建-script-标签"><a href="#动态创建-script-标签" class="headerlink" title="动态创建 script 标签"></a>动态创建 <code>script</code> 标签</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.src = &apos;路径&apos;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">script.onload = function()&#123;&#125;</span><br><span class="line">script.onerror = function()&#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>通过设置响应头中的类型进而来确定返回内容的格式（第四部分），从而保证返回的是 JavaScript 代码。</li>
<li>当创建  <code>script</code> 标签插入 <code>body</code> 后，返回的内容会立即执行，之后再去执行 <code>onload</code> 和 <code>onerror</code> 事件，所以说  <code>onload</code> 可以进行删除， 之后将处理逻辑交给后端（处理逻辑中应该包括使用完 <code>script</code> 标签之后立刻删除），但是此时前后端耦合。</li>
<li><code>script</code> 的 <code>src</code> 属性可以访问其他地址</li>
</ul>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>动态创建 <code>script</code> 并调用前端传给后端的 callback 技术</p>
<h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h3><p>#####Nodejs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.write(` callback.call(undefined,&apos; success &apos;) `);</span><br></pre></td></tr></table></figure></p>
<h5 id="JS"><a href="#JS" class="headerlink" title="JS:"></a>JS:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.callback = function()&#123;&#125;  //返回之后进行处理</span><br><span class="line">script.src = http://....../路径?callback = xxx</span><br></pre></td></tr></table></figure>
<h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><h5 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.write(` $&#123; query.callback &#125;.call(undefined,&#123;</span><br><span class="line">    &quot;success&quot;: true,</span><br><span class="line">    &quot;left&quot;: $&#123; newAmount &#125;</span><br><span class="line">&#125;) `)</span><br></pre></td></tr></table></figure>
<p>返回的数据是 JSON 数据<br><strong>特点：</strong></p>
<ul>
<li>请求方创建 <code>script</code> ，<code>src</code> 属性指向响应方</li>
<li>响应方根据查询参数，构造形如 xxx.call(undefined,”传给前端的数据”) 这样的响应。</li>
</ul>
<h1 id="JSONP-1"><a href="#JSONP-1" class="headerlink" title="JSONP"></a>JSONP</h1><h3 id="什么是-JSONP"><a href="#什么是-JSONP" class="headerlink" title="什么是 JSONP"></a>什么是 JSONP</h3><p>请求方：前端（浏览器）<br>响应方：后端（服务器）</p>
<ol>
<li>请求方创建 <code>script</code> ，<code>src</code> 指向响应方，同时传入一个查询参数 ?callback = 随机数</li>
<li>响应方根据查询参数 callback ，构造形如 <code>随机数.call(undefined,&quot;传给前端的数据&quot;)</code> 这样的响应</li>
<li>浏览器接收到响应，就会执行 <code>随机数.call(undefined,&quot;传给前端的数据&quot;)</code> </li>
<li>请求方获取到数据<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h5 id="JS-1"><a href="#JS-1" class="headerlink" title="JS"></a>JS</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">button.addEventlistener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;);</span><br><span class="line">    let functionName = &apos;bowen&apos; + parseInt(Math.random()*100000,10);</span><br><span class="line">    window[ functionName ] = function(result)&#123;</span><br><span class="line">        if( result === &apos;success&apos; )&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = &apos;http://....../路径?callback = &apos; + functionName</span><br><span class="line">    document.body.appendChild( script );</span><br><span class="line">    script.onload = function(event)&#123;</span><br><span class="line">        event.currentTarget.remove();</span><br><span class="line">        delete window[ functionName ]</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = function()&#123;</span><br><span class="line">        alert(&apos;fail&apos;);</span><br><span class="line">        event.currentTarget.remove();</span><br><span class="line">        delete window[ functionName ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="jQ"><a href="#jQ" class="headerlink" title="jQ:"></a>jQ:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;,(event) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &apos;http://....../路径&apos;，</span><br><span class="line">        dataType: &apos;jsonp&apos;,</span><br><span class="line">        success: function( response )&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="套路：为什么-JSONP-不支持-POST-请求"><a href="#套路：为什么-JSONP-不支持-POST-请求" class="headerlink" title="套路：为什么 JSONP 不支持 POST 请求"></a>套路：为什么 JSONP 不支持 POST 请求</h3><p>JSONP 是动态创建 <code>script</code> 标签 + 传入 callback 查询参数，<code>script</code> 标签，只能发送 GET 请求，不能使用 POST。</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><p>如果后端没有写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.write(` $&#123; query.callback &#125;.call(undefined,&#123;</span><br><span class="line">    &quot;success&quot;: true,</span><br><span class="line">    &quot;left&quot;: $&#123; newAmount &#125;</span><br><span class="line">&#125;) `)</span><br></pre></td></tr></table></figure></p>
<p>前端虽然有响应内容，但是使用不到</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">Vorherige Seite</a>
  
  
    <a href="/page/4/" class="alignright next">Nächste Seite</a>
  
  <div class="clearfix"></div>
</nav></div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>2</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>2</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
