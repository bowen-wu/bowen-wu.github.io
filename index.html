<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-27T01:09:03.000Z"><a href="/2018/02/27/JS进阶 -- 工程化之 webpack/">2018-02-27</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/27/JS进阶 -- 工程化之 webpack/">JS进阶 -- 工程化之 webpack</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a><a href="https://github.com/bowen-wu/webpack-demo" target="_blank" rel="noopener">代码链接</a></h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工程化包括了自动化 + 模块化 + 性能优化，前端语言较多并且更新频率较快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CSS ==&gt; Less ==&gt; Sass ==&gt; Scss ==&gt; Stylus（结合Less + Sass）</span><br><span class="line">JS ==&gt; coffee ==&gt; ES6 ==&gt; babel ==&gt; TypeScript ==&gt; Elm</span><br><span class="line">HTML ==&gt; Jade ==&gt; Pug ==&gt; slim</span><br></pre></td></tr></table></figure></p>
<p>当我们面对这么多语言的时候，Webpack 应运而生，Webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，它主要为我们解决了工程化的问题。在本篇文章中将要介绍 SCSS + babel + Webpack</p>
<h2 id="Sass-Scss"><a href="#Sass-Scss" class="headerlink" title="Sass | Scss"></a>Sass | Scss</h2><p>Scss 是 CSS 的预处理语言 | 扩展，<code>Sass makes CSS fun again</code> 这是Scss 要做的事情。Scss添加了嵌套规则、变量、混入、选择器继承，还能和命令行工具 | Web框架插件将其转换为格式良好的标准 CSS</p>
<h4 id="Sass-与-Scss-区别"><a href="#Sass-与-Scss-区别" class="headerlink" title="Sass 与 Scss 区别"></a>Sass 与 Scss 区别</h4><p>Sass 使用换行 + 缩进进行工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">    background: red</span><br></pre></td></tr></table></figure></p>
<p>Scss 使用分号 + 花括号进行工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="安装-Scss"><a href="#安装-Scss" class="headerlink" title="安装 Scss"></a>安装 Scss</h4><p>Scss 是有 Ruby 社区创作出来的，所以要使用 <code>gem</code> 命令，但是 <code>node</code> 将 Scss 重写了一遍，所以可以使用 <code>node-sass</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">npm install -g node-sass  // 安装</span><br><span class="line">npm uninstall node-sass -g    // 卸载</span><br><span class="line"></span><br><span class="line">解决问题 4 连 </span><br><span class="line">npm update</span><br><span class="line">npm install</span><br><span class="line">nodejs node_modules/node-sass/scripts/install.js</span><br><span class="line">npm rebuild node-sass</span><br><span class="line"></span><br><span class="line">解决问题 7 连 查看 node-sass 是否存在</span><br><span class="line">npm -v</span><br><span class="line">node -v</span><br><span class="line">node -p process.versions</span><br><span class="line">node -p process.platform</span><br><span class="line">node -p process.arch</span><br><span class="line">node -p &quot;require(&apos;node-sass&apos;).info&quot;</span><br><span class="line">npm ls node-sass</span><br><span class="line"></span><br><span class="line">解决问题 3 连 重新生成 node_modules + package.json</span><br><span class="line">npm -rf node_modules</span><br><span class="line">rm package.json</span><br><span class="line">rm package-lock.json</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">npm cache clean  // 清除缓存</span><br><span class="line">npm cache clean --force  // 清除缓存</span><br><span class="line">npm install --unsafe-perm</span><br><span class="line">npm config set sass_binary_site http://npm.taobao.org/mirrors/node-sass/    // 切换淘宝源</span><br><span class="line">npm i -g node-sass --save_binary_path=/home/wubowen/Downloads/Linux-x64-48-binding.node   // 通过 .node 包安装</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org  // 安装 cnpm</span><br><span class="line">cnpm install -g node-sass  // cnpm 安装</span><br><span class="line"></span><br><span class="line">运行配置文件</span><br><span class="line">. ~/.bash_profile</span><br><span class="line">. ~/.npmrc</span><br><span class="line">source ~/.profile</span><br><span class="line">source .npmrc</span><br></pre></td></tr></table></figure></p>
<p>安装成功之后便可以使用 node-sass 了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node-sass [options] &lt;input&gt; [output]</span><br><span class="line">示例</span><br><span class="line">node-sass src/style.scss dist/style.css</span><br><span class="line">node-sass src/style.scss dist/style.css -w  // Watch a directory or file</span><br></pre></td></tr></table></figure></p>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>Babel is a JavaScript compiler。它是一款可以将 JS 语法编译为 ES5（IE能读）的编译器</p>
<h4 id="安装-使用"><a href="#安装-使用" class="headerlink" title="安装 + 使用"></a>安装 + 使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli babel-preset-env</span><br><span class="line">touch .babelrc</span><br><span class="line">编辑 .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br><span class="line">npm init   // 创建 package.json</span><br><span class="line">npm install --save-dev babel-cli</span><br><span class="line">package.json 多出一行</span><br><span class="line">&#123;</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">+   &quot;babel-cli&quot;: &quot;^6.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在 package.json 中 + </span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;my-project&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">+   &quot;scripts&quot;: &#123;</span><br><span class="line">+     &quot;build&quot;: &quot;babel src -d lib&quot;</span><br><span class="line">+   &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;</span><br><span class="line">      &quot;babel-cli&quot;: &quot;^6.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">npm run build   // 运行 package.json 中的 &quot;build&quot;: &quot;babel src -d lib&quot; 这句话</span><br><span class="line">./node_modules/.bin/babel src -d lib    // 将 src 中的文件翻译到 lib 文件中</span><br><span class="line"></span><br><span class="line">之后 index.html 引用 dist 中的文件</span><br><span class="line"></span><br><span class="line">自动监控</span><br><span class="line">./node_modules/.bin/babel path1 -d path2 --watch</span><br></pre></td></tr></table></figure>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch 命令行工具可以监控文件的改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g watch-cli</span><br><span class="line">watch -p &apos;path1&apos; -c &apos;cp path1 path2&apos;  // 只要 path1 中的文件改动就会将 path1 中的文件复制到 path2 中</span><br></pre></td></tr></table></figure></p>
<p>watch 也可以用于 img<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -p &apos;src/img/**/*&apos; -c &apos;cp -r src/img dist/img&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="前端目录规范"><a href="#前端目录规范" class="headerlink" title="前端目录规范"></a>前端目录规范</h2><p>src ==&gt; source 目录 ==&gt; 未经翻译的代码<br>dist ==&gt; distribution 目录 ==&gt; 待发布的代码<br>node_modules ==&gt; 第三方包<br>vendors ==&gt; 第三方代码（jQuery）</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>通过之前的介绍，我们使用<br> scss ==&gt; node-sass ==&gt; css<br>ES6 JS ==&gt; babel ==&gt; ES5（IE 使用）<br>HTML + img ==&gt; watch ==&gt; 复制<br>我们通过这么多的命令才能实现我们的自动化，那么为什么不使用一种工具，具有以上三者的作用呢，所以 Webpack 应运而生</p>
<h4 id="Webpack-核心"><a href="#Webpack-核心" class="headerlink" title="Webpack 核心"></a>Webpack 核心</h4><h6 id="入口（entry）"><a href="#入口（entry）" class="headerlink" title="入口（entry）"></a>入口（entry）</h6><p>entry 指示 webpack 使用哪个模块来作为构建其内部依赖图的开始，进入进口后，webpack 会找出有哪些模块和库是入口直接或间接依赖的，每个依赖项随即被处理，最后输出到 bundles 的文件中<br>通过在 webpack 配置中配置 <code>entry</code> 属性来指定起点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="出口（output）"><a href="#出口（output）" class="headerlink" title="出口（output）"></a>出口（output）</h6><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve( __dirname, &apos;dist&apos; )</span><br><span class="line">        filename: &apos;my-first-webpack-bundle.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h6><p>loader 让 webpack 能够去处理非 JavaScript 文件（webpack 自身只能理解 JavaScript）。webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。<strong>多数 loader 可以通过选项（<code>options</code>）自定义</strong><br>loader 实现的目标</p>
<ul>
<li>识别出应该被对应的 loader 进行转换的那些文件（使用 <code>text</code> 属性）</li>
<li>转换这些文件，使其能被添加到依赖图中（使用 <code>use</code> 属性）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve( __dirname, &apos;dist&apos; )</span><br><span class="line">        filename: &apos;my-first-webpack-bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                // 遇到匹配的文件，使用 loader 进行转换之后再进行打包</span><br><span class="line">                text: /\.txt$/,        // 匹配的文件</span><br><span class="line">                use: &apos;raw-loader&apos;    // 使用的 loader</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &apos;babel-loader&apos;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [ &apos;@babel/present-env&apos; ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h6><p>loader 被用于转换某些类型的模块，而插件则用于执行范围更广的任务。插件的范围包括：从打包优化 + 压缩，一直到重新定义环境中的变量<br>想使用一个插件，需要 <code>require()</code> 插件，然后把它添加到 <code>plugins</code> 数组中，多数插件可以通过选项 <code>options</code> 自定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装</span><br><span class="line">const webpack = require(&apos;webpack&apos;); // 用于访问内置插件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></p>
<h4 id="webpack-使用"><a href="#webpack-使用" class="headerlink" title="webpack 使用"></a>webpack 使用</h4><p><strong>注意：<code>npm i 找不到的module</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-demo</span><br><span class="line">cd webpack-demo</span><br><span class="line">npm init    // 初始化</span><br><span class="line">一路回车</span><br><span class="line">ls   ==&gt; package.json</span><br><span class="line">npm install --save-dev webpack  // package.json 中多了依赖 webpack</span><br><span class="line">touch webpack.config.js   // 创建配置文件并编辑</span><br><span class="line">vi webpack.config.js</span><br><span class="line">    ****************</span><br><span class="line">    const path = require(&apos;path&apos;);  </span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      entry: &apos;./src/js/&apos;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        filename: &apos;bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist/js/&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    *****************</span><br><span class="line"></span><br><span class="line">mkdir src src/css src/js </span><br><span class="line">touch src/css/main.scss src/js/index.js src/js/main.js src/index.html  </span><br><span class="line"></span><br><span class="line">    ****************</span><br><span class="line">    index.html 中引入 css，不引 scss</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/main.css&quot;&gt;</span><br><span class="line">    ***************</span><br><span class="line">npx webpack  // 将 src 中的 JS 文件转换 + 复制到 dist/js/</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-babel-loder"><a href="#使用-babel-loder" class="headerlink" title="使用 babel-loder"></a>使用 <a href="https://github.com/babel/babel-loader/tree/7.x" target="_blank" rel="noopener">babel-loder</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">index.js + main.js</span><br><span class="line"></span><br><span class="line">    ***********************</span><br><span class="line">    let a = 1</span><br><span class="line">    console.log(a)</span><br><span class="line">    </span><br><span class="line">    let b = 1</span><br><span class="line">    console.log(b)</span><br><span class="line">    **********************</span><br><span class="line"></span><br><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env webpack  </span><br><span class="line">// 使用 webpack 3.x babel-loader 7.x | babel 6.x，注意 github 点击[链接](https://github.com/babel/babel-loader/tree/7.x)</span><br><span class="line">vi webpack.config.js</span><br><span class="line"></span><br><span class="line">    **************************</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist/js/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    + module: &#123;</span><br><span class="line">    +   rules: [</span><br><span class="line">    +     &#123;</span><br><span class="line">    +       test: /\.js$/,    // 如果文件是 .js 结尾</span><br><span class="line">    +       exclude: /(node_modules|bower_components)/,</span><br><span class="line">    +       use: &#123;             // 使用 babel-loader 转换</span><br><span class="line">    +         loader: &apos;babel-loader&apos;,</span><br><span class="line">    +       options: &#123;       // 选项，参数 env</span><br><span class="line">    +           presets: [&apos;env&apos;]</span><br><span class="line">    +         &#125;</span><br><span class="line">    +       &#125;</span><br><span class="line">    +     &#125;</span><br><span class="line">    +   ]</span><br><span class="line">    + &#125;</span><br><span class="line">    ***************************</span><br><span class="line"></span><br><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">touch src/js/app.js</span><br><span class="line">// app.js 调用 main.js + index.js</span><br><span class="line">vi app.js</span><br><span class="line"></span><br><span class="line">    ***************************</span><br><span class="line">    import a from &apos;./main&apos;</span><br><span class="line">    import b from &apos;./index&apos;</span><br><span class="line">    </span><br><span class="line">    a()</span><br><span class="line">    console.log(&apos;app&apos;)</span><br><span class="line">    b()</span><br><span class="line">    **************************</span><br><span class="line"></span><br><span class="line">index.js</span><br><span class="line"></span><br><span class="line">    ********************************</span><br><span class="line">    let b = 1</span><br><span class="line">    function fn() &#123;</span><br><span class="line">        console.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    export default fn</span><br><span class="line">    *******************************</span><br><span class="line"></span><br><span class="line">main.js</span><br><span class="line"></span><br><span class="line">    **********************************</span><br><span class="line">    export default function()&#123;</span><br><span class="line">        let a =1</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    ***********************************</span><br><span class="line"></span><br><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line">    ********************************</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">    -    entry: &apos;./src/js/&apos;,</span><br><span class="line">    +    entry: &apos;./src/js/app.js&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">    ********************************</span><br><span class="line"></span><br><span class="line">rm -rf dist</span><br><span class="line">npx webpack  // 看终端 log 便可以看到，webpack 将三个 js 文件都转换并复制到了 dist/js 中</span><br></pre></td></tr></table></figure>
<h4 id="使用-scss-loader"><a href="#使用-scss-loader" class="headerlink" title="使用 scss-loader"></a>使用 <a href="https://github.com/webpack-contrib/sass-loader" target="_blank" rel="noopener">scss-loader</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader node-sass webpack --save-dev</span><br><span class="line">vi webpack.config.js</span><br><span class="line"></span><br><span class="line">    ********************************</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                exclude: /(node_modules|bower_components)/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &apos;babel-loader&apos;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&apos;env&apos;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        -      &#125;</span><br><span class="line">        +      &#125;,</span><br><span class="line">        +    &#123;</span><br><span class="line">        +        test: /\.scss$/,   // 1. 发现后缀 .scss 文件</span><br><span class="line">        +        use: [</span><br><span class="line">        +            &#123;</span><br><span class="line">        +                loader: &quot;style-loader&quot; // 4. 使用 style-loader 将 JS 字符串 ==&gt; &lt;style&gt; 标签（creates style nodes from JS strings）</span><br><span class="line">        +            &#125;, &#123;</span><br><span class="line">        +                loader: &quot;css-loader&quot; // 3. 使用 css-loader 将 css ==&gt; JS 字符串（translates CSS into CommonJS）</span><br><span class="line">        +            &#125;, &#123;</span><br><span class="line">        +                loader: &quot;sass-loader&quot; // 2. 使用 sass-loader 将 sass ==&gt; css (compiles Sass to CSS）</span><br><span class="line">        +            &#125;</span><br><span class="line">        +        ]</span><br><span class="line">        +    &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    *********************************</span><br><span class="line"></span><br><span class="line">vi app.js</span><br><span class="line"></span><br><span class="line">    **************************</span><br><span class="line">    + import &apos;../css/main.scss&apos;</span><br><span class="line">    **************************</span><br><span class="line"></span><br><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<h4 id="使用-postcss-loader"><a href="#使用-postcss-loader" class="headerlink" title="使用 postcss-loader"></a>使用 <a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">postcss-loader</a></h4><p>postcss-loader 能够使得 CSS 自动添加前缀，从而使我们的代码更加强健<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">npm i -D postcss-loader</span><br><span class="line">touch postcss.config.js</span><br><span class="line">vi postcss.config.js</span><br><span class="line"></span><br><span class="line">    *****************************</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      //parser: &apos;sugarss&apos;,</span><br><span class="line">      plugins: &#123;</span><br><span class="line">        &apos;postcss-import&apos;: &#123;&#125;,</span><br><span class="line">       // &apos;postcss-cssnext&apos;: &#123;&#125;,</span><br><span class="line">       // &apos;cssnano&apos;: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *******************************</span><br><span class="line"></span><br><span class="line">vi webpack.config.js</span><br><span class="line"></span><br><span class="line">    ************************</span><br><span class="line">    ......</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;, // translates CSS into CommonJS</span><br><span class="line">    +                  options: &#123; importLoaders: 1 &#125;</span><br><span class="line">    +              &#125;, &#123;</span><br><span class="line">    +                  loader: &apos;postcss-loader&apos;,</span><br><span class="line">    +                  options: &#123;                     // 如果没有 options 则不会添加后缀，先尝试不添加 options，如果 postcss-loader 不工作，再添加 options</span><br><span class="line">    +                      plugins: () =&gt; [</span><br><span class="line">    +                          require(&apos;autoprefixer&apos;)</span><br><span class="line">    +                      ]</span><br><span class="line">    +                  &#125;</span><br><span class="line">                    &#125;,&#123;</span><br><span class="line">                        loader: &quot;sass-loader&quot; // compiles Sass to CSS</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">    ***********************</span><br><span class="line"></span><br><span class="line">npx webpack</span><br></pre></td></tr></table></figure></p>
<h4 id="webpack-总结"><a href="#webpack-总结" class="headerlink" title="webpack 总结"></a>webpack 总结</h4><ul>
<li>webpack 将前端思想完全转变，将 CSS 写入 JS 中，使用 JS 生成 <style> 标签，这样使得 JS 执行的时候才能加载 CSS，这是一个弊端，可以使用 Cache Control 缓解，即当我们第二次访问的时候，会很快，因为一个 JS 包含了所有问题，可以使用混杂模式，既有传统 CSS，又有 webpack CSS，在 <head> 标签中加入 <style> 基础样式，使用 JS 添加动态样式</li>
<li>webpack 就是做一系列自动化的流程，例如，通过 babe-loader 将 ES6 转化为 ES5，通过 scss-loader 将 scss 转化为 css，通过 postcss-loader 添加 css 前缀。webpack 是一种基于预编译的模块化方案，把一切内容包括 JS 文件和静态文件都视为模块（module）</li>
</ul>
</style></li></ul>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-25T23:38:51.000Z"><a href="/2018/02/26/JS进阶 -- 面向对象（三）三面大旗 + 基础概念 + 总结/">2018-02-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/26/JS进阶 -- 面向对象（三）三面大旗 + 基础概念 + 总结/">JS进阶 -- 面向对象（三）三面大旗 + 基础概念 + 总结</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>面向对象是一种思维定势（套路），当遇到任何需求，都是用这一套思维解决。本篇我们进一步了解面向对象，主要了解面向对象的三面大旗，即封装 + 继承 + 多态，还有一些关于面向对象的概念</p>
<h2 id="三面大旗"><a href="#三面大旗" class="headerlink" title="三面大旗"></a>三面大旗</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装即是<strong>隐藏细节</strong>，可以是 A 对 A 隐藏细节，也可以是 A 对 B 隐藏细节。任何一个函数都是封装</p>
<ul>
<li>A - A ==&gt; 封装函数，解决自己的思想负担，需要使用时只需要调用自己封装的函数即可</li>
<li>A - B ==&gt; 例如一些第三方库（jQuery 的作者对于使用 jQuery 的人），A 给 B 提供 API，B 使用 API，有助于合作 + 交流</li>
</ul>
<p>面向对象可以实现封装，但不代表只有面向对象可以封装</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a href="https://www.jianshu.com/p/4a5170bc9afd" target="_blank" rel="noopener">继承</a></h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态使得一个东西<strong>灵活</strong>，如果没有多态，则经常要进行类型转换，指一个东西拥有两种甚至更多种属性<br>示例：div 同时是 Node + Element，可以调用两者任意的 API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.childNodes  // 子代节点 ==&gt; div 作为 Node 使用</span><br><span class="line">div.child    // 元素节点 ==&gt; div 作为 Element 使用</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 是动态语言，所有东西都是多态，所有东西都有多个状态</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>面向对象</strong>是把一组数据结构和处理它们的方法组成<strong>对象（Object）</strong>，把相同行为的对象归纳为<strong>类（Class）</strong>，通过类的<strong>封装（Encapsulation）</strong>隐藏内部细节，通过<strong>继承（Inheritance）</strong>实现类的<strong>特化（Specialization）</strong>/<strong>泛化（Generalization）</strong>，通过<strong>多态（Polymorphism）</strong>实现基于对象类型的<strong>动态分派（Dunamic Dispatch）</strong><br>面向对象是一套经验（套路）。它可以使得我们更快、更好的进行开发</p>
<h4 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h4><p>它是一种可以捆绑功能的容器，经常是一个对象，可以为这个对象添加属性和方法，这个对象就是命名空间，例如 window.jQuery</p>
<h4 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h4><p>定义对象的特征，它是对象属性和方法的模板定义</p>
<h4 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h4><p>类的一个实例</p>
<h4 id="Property-属性"><a href="#Property-属性" class="headerlink" title="Property 属性"></a>Property 属性</h4><p>对象的特征，比如大小</p>
<h4 id="Method-方法"><a href="#Method-方法" class="headerlink" title="Method 方法"></a>Method 方法</h4><p>对象的能力，比如行走</p>
<h4 id="Constructor-构造函数"><a href="#Constructor-构造函数" class="headerlink" title="Constructor 构造函数"></a>Constructor 构造函数</h4><p>对象初始化的瞬间，被调用的方法，通常它的名字和包含它的类一致</p>
<h4 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance 继承"></a>Inheritance 继承</h4><p>一个类可以继承另一个类的特征</p>
<h4 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a>Encapsulation 封装</h4><p>把数据和相关的方法绑定在一起使用的方法</p>
<h4 id="Abstraction-抽象"><a href="#Abstraction-抽象" class="headerlink" title="Abstraction 抽象"></a>Abstraction 抽象</h4><p>结合复杂的继承、方法和属性的对象可以模拟现实的模型</p>
<h4 id="Polymorphism-多态"><a href="#Polymorphism-多态" class="headerlink" title="Polymorphism 多态"></a>Polymorphism 多态</h4><p>不同的类可以定义为相同的方法或属性</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="JavaScript-实现面向对象"><a href="#JavaScript-实现面向对象" class="headerlink" title="JavaScript 实现面向对象"></a>JavaScript 实现面向对象</h4><p>JavaScript 中的面向对象都是对于复杂类型（Object）而言的，JavaScript 中 Object 又主要分为 <code>普通对象 + Array + Function</code>，JavaScript 中没有类的概念，所以 JavaScript 中使用原型（<code>__proto__</code>，原型链）实现继承</p>
<h4 id="代码层面的面向对象"><a href="#代码层面的面向对象" class="headerlink" title="代码层面的面向对象"></a>代码层面的面向对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person( name )&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = function()&#123;</span><br><span class="line">    console.log( ` My name is $&#123; this.name &#125; ` )</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = new Person( &apos;xiaoming&apos; )</span><br><span class="line">xiaoming.say()</span><br></pre></td></tr></table></figure>
<p>这就是代码层面的面向对象，<code>function Person(){}</code> 就是调用的函数， <code>Person.prototype.say = function(){}</code> 就是你生成的新对象的原型方法</p>
<h4 id="面向对象解决的问题"><a href="#面向对象解决的问题" class="headerlink" title="面向对象解决的问题"></a>面向对象解决的问题</h4><ol>
<li>组件化。使得代码划分明确，作用清晰</li>
<li>调用时只需要 <code>new</code>，即可把公共属性 + 私有属性继承</li>
<li>每一个 <code>new</code> 之间互不影响，之后便可以添加自己的属性（也可覆盖公共属性）</li>
</ol>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var app = app || &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来了解下 <code>&amp;&amp;</code> 和 <code>||</code> 这两个操作符的含义。这两个操作符返回的是一个 truey | falsey 值</p>
<h6 id="amp-amp-操作符"><a href="#amp-amp-操作符" class="headerlink" title="&amp;&amp; 操作符"></a>&amp;&amp; 操作符</h6><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ec8819c975b440dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="&amp;&amp; 操作符"></p>
<h6 id="操作符"><a href="#操作符" class="headerlink" title="|| 操作符"></a>|| 操作符</h6><p><img src="http://upload-images.jianshu.io/upload_images/9617841-2b30afb11d2718ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="|| 操作符"></p>
<p>所以当我们使用 <code>var app = app || {}</code> 这种写法是最佳实践，因为如果在这个语句之前，<code>app</code> 就有了定义，那么这个语句不会覆盖之前的定义。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-23T00:13:53.000Z"><a href="/2018/02/23/JS进阶 -- 面向对象（二）构造函数 + 继承/">2018-02-23</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/23/JS进阶 -- 面向对象（二）构造函数 + 继承/">JS进阶 -- 面向对象（二）构造函数 + 继承</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇主要讲述构造函数和继承</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><p>编程主要分为<strong>函数式编程</strong>和<strong>面向对象编程</strong></p>
<ul>
<li><p>函数式编程 ==&gt; 推崇函数</p>
</li>
<li><p>面向对象编程 ==&gt; 推崇<strong>类</strong>，没有函数概念</p>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>JavaScript 中的<strong>类</strong>可以理解为<strong>构造函数</strong></p>
</li>
<li><p>类 ==&gt; 如果一个东西返回一个 <code>Object</code> 就叫做类</p>
</li>
<li><p>构造函数 ==&gt; 如果一个函数返回一个 <code>Object</code> 就叫做<strong>构造函数</strong></p>
</li>
</ul>
<p>因为 JavaScript 中没有类的概念，所以 JavaScript 中的构造函数即可以看做是类，JavaScript 中 <code>new</code> 是构造函数的典范</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以实现<strong>代码复用</strong>，JavaScript 中使用原型（<code>__proto__</code>，原型链）实现继承，实例化对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.__proto__ === 函数.prototype   // 很重要</span><br></pre></td></tr></table></figure></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>对象之间的继承 ==&gt; <code>__proto__</code></p>
</li>
<li><p>函数与对象之间的继承通过 <code>this</code> 参数（关键字）传导</p>
</li>
<li><p>关键字 <code>new</code> 形成构造函数，从而使用函数创建对象，使得新创建的对象可以继承构造函数上的属性</p>
</li>
</ol>
<h3 id="模拟继承的具体方式"><a href="#模拟继承的具体方式" class="headerlink" title="模拟继承的具体方式"></a>模拟继承的具体方式</h3><ul>
<li>共有属性 ==&gt; <code>prototype</code> 属性</li>
<li>私有属性 ==&gt; 构造函数上的属性</li>
</ul>
<p>==&gt; 继承 === 共有属性 + 私有属性 === <code>prototype</code> 属性 + 构造函数上的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person( name )&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.think = true</span><br><span class="line">Person.prototype.foot = &apos;two&apos;</span><br><span class="line">Person.prototype.say = function()&#123;</span><br><span class="line">    console.log( &apos;I can say&apos; )</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.walk = function()&#123;</span><br><span class="line">    console.log( &apos;I can walk&apos; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="new-模拟继承"><a href="#new-模拟继承" class="headerlink" title="new 模拟继承"></a>new 模拟继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let xiaoming = new Person( &apos;xiaoming&apos; )</span><br><span class="line">xiaoming.a = 1</span><br><span class="line">xiaoming.xxx = function()&#123;</span><br><span class="line">    console.log( &apos;xxx&apos; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象 <code>xiaoming</code> 具有 <code>Person</code> 的私有属性 + 共有属性，还有自身的属性<br><img src="http://upload-images.jianshu.io/upload_images/9617841-61fa30713fb1959e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new 模拟继承"></p>
<h5 id="call-Object-create-new-模拟继承"><a href="#call-Object-create-new-模拟继承" class="headerlink" title="call + Object.create() + new 模拟继承"></a>call + Object.create() + new 模拟继承</h5><p>new 模拟的继承仅仅有一层，如果我们要模拟多层，即 <code>xiaoming</code> 继承 <code>Student</code>，<code>Student</code> 继承 <code>Person</code><br><img src="http://upload-images.jianshu.io/upload_images/9617841-195820e44e5b350f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图"><br>其中 <code>Student</code> 继承 <code>Person</code> 是<strong>构造函数与构造函数的继承（类与类的继承）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Student( name, school )&#123;</span><br><span class="line">    Person.call( this, name )   // 继承 Person 属性  === Person.bind( this ).( name )</span><br><span class="line">    this.school = school</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = Object.create( Person.prototype )   // 继承 Person 方法</span><br><span class="line">Student.prototype.learn = function()&#123;</span><br><span class="line">    console.log( `$&#123; this.name &#125; learn in $&#123; this.school &#125;` )</span><br><span class="line">&#125;</span><br><span class="line">let xiaoming = new Student( &apos;xiaoming&apos;, &apos;qinghua&apos; )</span><br><span class="line">xiaoming.a = 1</span><br><span class="line">xiaoming.xxx = function()&#123;</span><br><span class="line">    console.log( &apos;xxx&apos; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象 <code>xiaoming</code> 既继承了 <code>Student</code> 的共有属性 + 私有属性，又继承了 <code>Person</code> 的共有属性 + 私有属性，还有自己的属性<br><img src="http://upload-images.jianshu.io/upload_images/9617841-1caaa8c9aa72cd21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="call + Object.create() + new 实现继承"></p>
<h6 id="模拟构造函数与构造函数的继承（类与类的继承）"><a href="#模拟构造函数与构造函数的继承（类与类的继承）" class="headerlink" title="模拟构造函数与构造函数的继承（类与类的继承）"></a>模拟构造函数与构造函数的继承（类与类的继承）</h6><p>上面中模拟构造函数与构造函数的继承（类与类的继承）使用了 <code>Object.create()</code>。模拟构造函数与构造函数的继承（类与类的继承）即是实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.__proto__ = Person.prototype</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>方案1：前提 ==&gt; <code>Person</code> 为空（没有私有属性），若 <code>Person</code> 不为空，则 <code>Student</code> 上会多出 <code>Person</code> 上的私有属性</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = new Person()</span><br><span class="line">==&gt; Student.prototype === this</span><br><span class="line">==&gt; Student.prototype.__proto__ === Person.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案2：ES3 ==&gt; not care Person 上的私有属性</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function emptyPerson() &#123;&#125;</span><br><span class="line">emptyPerson.prototype = Person.prototype</span><br><span class="line">Student.prototype = new emptyPerson()</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案3：ES5 API</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype = Object.create( Proson.prototype )</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案4：ES6 ==&gt; class + extends ==&gt; prototype(共有属性)必须是函数</p>
<ol>
<li><p><code>class</code> 用法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        this.name = options.name</span><br><span class="line">    &#125;</span><br><span class="line">    say() &#123;  &#125;</span><br><span class="line">    walk() &#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line">== 等价于 ==</span><br><span class="line">function Example(options) &#123;</span><br><span class="line">    this.name = options.name</span><br><span class="line">&#125;</span><br><span class="line">Example.prototype.say = function() &#123;  &#125;</span><br><span class="line">Example.prototype.walk = function() &#123;  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>extends 用法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    class Student extends Person === Student.prototype = Object.create(Person.prototype)</span><br><span class="line">    super(options) === Example.call(this,options)</span><br><span class="line">    ``` </span><br><span class="line">3. 具体实现</span><br></pre></td></tr></table></figure>
<p> class Student extends Person{</p>
<pre><code>constructor(options){
    super(options)   // 继承私有属性
}
</code></pre><p> }</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    4. ` class + extends ` 不伦不类</span><br><span class="line">        ` Student ` 是 ` class `（类） ==&gt; JavaScript 中没有类这个数据类型</span><br><span class="line">        ` Student ` 是函数 ==&gt; Student 并不能 ` call `</span><br><span class="line"></span><br><span class="line">## 相关知识点</span><br><span class="line">` Object.create() ` 的实现</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>function inherit( base ){<br>    function fn(){}<br>    fn.prototype = base<br>    return new fn()<br>}<br>```</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-21T23:41:17.000Z"><a href="/2018/02/22/JS进阶 -- 面向对象（一）代码 + 函数 + this + new/">2018-02-22</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/22/JS进阶 -- 面向对象（一）代码 + 函数 + this + new/">JS进阶 -- 面向对象（一）代码 + 函数 + this + new</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇我们借助 MVC 来初步理解面向对象，之后理解一下 函数 + <code>this</code> + <code>new</code></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h4><p>当我们使用 MVC 思想将代码模块化后，每个 js 文件中代码没有重复，很精简，但是当我们跨文件观察我们的 js 时，发现每个 js 文件都有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let view = document.querySelect( &apos;xxx&apos; )</span><br><span class="line">let model = &#123;</span><br><span class="line">    init: function()&#123;&#125;,</span><br><span class="line">    fetch: function()&#123;&#125;,</span><br><span class="line">    save: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let controller = &#123;</span><br><span class="line">    view: null,</span><br><span class="line">    model: null,</span><br><span class="line">    init: function()&#123;</span><br><span class="line">        this.view = view</span><br><span class="line">        this.model = model</span><br><span class="line">        this.model.init()</span><br><span class="line">        this.init()</span><br><span class="line">        this.bingEvents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一种跨文件的重复，如果我们抽丝剥茧便可以对重复的地方进行分类，在全局范围内创造一个模板，每一个重复的地方都是由全局<strong>模板</strong>制造出来的</p>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>我们创建一个 base 文件目录，里面有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base/View.js</span><br><span class="line">    window.View = function()&#123;&#125;</span><br><span class="line">base/Model.js</span><br><span class="line">    window.Model = function()&#123;&#125;</span><br><span class="line">base/Controller.js</span><br><span class="line">    window.Controller = function()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后每个文件的重复的地方都使用全局变量 View()、Model() 和 Controller()</p>
<h2 id="函数-this"><a href="#函数-this" class="headerlink" title="函数 + this"></a>函数 + this</h2><p>函数是一种可执行代码组成的对象，<code>this</code> 仅仅是函数的一个<strong>参数</strong>而已</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>I/O + 一顿操作 + 隐藏细节，所有的 I( input ) === <code>this + arguments</code></p>
<h4 id="函数-lt-gt-this-lt-gt-对象"><a href="#函数-lt-gt-this-lt-gt-对象" class="headerlink" title="函数 &lt;==&gt; this &lt;==&gt; 对象"></a>函数 &lt;==&gt; this &lt;==&gt; 对象</h4><p>JavaScript 通过 <code>this</code> 连接 <code>Object</code> 和 <code>Function</code>，函数和对象没有一丢丢关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;xxx&apos;,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log( this.name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>obj.sayName 仅仅存储了函数的地址而已 ==&gt; 函数是一等公民 ==&gt; 函数是一个独立的，既不是附属品，也不是方法</p>
<h4 id="判断-this-的值"><a href="#判断-this-的值" class="headerlink" title="判断 this 的值"></a><a href="https://www.jianshu.com/p/66a32662e920" target="_blank" rel="noopener">判断 this 的值</a></h4><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>new 操作符主要是一个语法，它主要做了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当使用 let xiaoming = new Person( &apos;xiaoming&apos; ) 时，等价于</span><br><span class="line"></span><br><span class="line">let xiaoming = function(options) &#123;</span><br><span class="line">    // 1. var temp = &#123;&#125;</span><br><span class="line">    // 2. this = temp</span><br><span class="line">    this.name = &apos;xiaoming&apos;</span><br><span class="line">    // 3. 构造函数.prototype = &#123; constructor: 构造函数 &#125;</span><br><span class="line">    // 4. this.__proto__ = 构造函数.prototype</span><br><span class="line">    // 5. return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>请注意：new 返回值的类型是 Object</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-75082f65d6acfe94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器运行结果"></p>
<p><strong>说明</strong>：如果人为在 Person 中增加 <code>return</code>，两种情况</p>
<ul>
<li><code>return 基本类型</code> ==&gt; 无效 + 无视</li>
<li><code>return 复杂类型（对象）</code> ==&gt; 返回复杂类型（对象）</li>
</ul>
<h4 id="new-的实现"><a href="#new-的实现" class="headerlink" title="new 的实现"></a>new 的实现</h4><p><strong><code>var 对象 = new 函数</code></strong></p>
<h5 id="方法一：通过-Object-create-实现-new"><a href="#方法一：通过-Object-create-实现-new" class="headerlink" title="方法一：通过 Object.create() 实现 new"></a>方法一：通过 Object.create() 实现 new</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function _new()&#123;</span><br><span class="line">    let constructor = arguments[0]</span><br><span class="line">    let obj = Object.create( constructor.prototype )</span><br><span class="line">    constructor.apply( obj, [].slice.call( auguments, 1 ))</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-ad27b22da142fdae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过 Object.create() 实现 new"></p>
<h5 id="方法二：通过-Object-setPrototypeOf-实现-new"><a href="#方法二：通过-Object-setPrototypeOf-实现-new" class="headerlink" title="方法二：通过 Object.setPrototypeOf() 实现 new"></a>方法二：通过 Object.setPrototypeOf() 实现 new</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _new()&#123;</span><br><span class="line">    let constructor = arguments[0]</span><br><span class="line">    let obj = &#123;&#125;</span><br><span class="line">    Object.setPrototypeOf( obj, constructor.prototype )</span><br><span class="line">    constructor.apply( obj, [].slice.call( arguments, 1 ))</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-b73dae67e0ce13ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过 Object.setPrototypeOf() 实现 new"></p>
<h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><p>创建一个函数过程</p>
<ol>
<li><p>创建一个函数对象</p>
</li>
<li><p>创建一个原型对象</p>
</li>
<li><p>函数对象会有一个 <code>prototype</code> 属性，指向对应的原型对象</p>
</li>
<li><p>原型对象中有一个 <code>constructer</code> 属性，指向对应的构造函数</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-0d655d27ee7edf46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="函数"></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-20T23:36:20.000Z"><a href="/2018/02/21/总结篇（四）-- 进阶/">2018-02-21</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/21/总结篇（四）-- 进阶/">总结篇（四） -- 进阶</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇主要讲述声明前置、引用类型、函数作用域链、闭包、HTTP、Web安全和性能优化</p>
<h2 id="声明前置"><a href="#声明前置" class="headerlink" title="声明前置"></a>声明前置</h2><p>在进入一个执行环境后，先把 <code>var</code> 和 <code>function</code> 声明的变量前置，再去顺序执行代码，如果出现同名，则覆盖。如果一个变量已经有值（包括函数）再 <code>var</code> 无效</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型存储的是变量的地址，赋值仅仅是地址的拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function increase( num )&#123;</span><br><span class="line">    return num += 1</span><br><span class="line">&#125;</span><br><span class="line">increase( a )</span><br><span class="line">console.log( a )  // 1</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 中引用类型即对象，对象存储方式是，栈内存中存储地址，堆内存中存储数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1 &#125;</span><br><span class="line">function increase( obj )&#123;</span><br><span class="line">    obj.a += 1</span><br><span class="line">&#125;</span><br><span class="line">increase( obj )</span><br><span class="line">console.log( obj.a )  // 2</span><br></pre></td></tr></table></figure></p>
<h2 id="函数作用域链"><a href="#函数作用域链" class="headerlink" title="函数作用域链"></a>函数作用域链</h2><p>函数在执行过程中，先从自己内部找变量，之后去<strong>创建当前函数所在的作用域</strong>中寻找，依次向上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function fn1()&#123;</span><br><span class="line">    function fn2()&#123;</span><br><span class="line">        cnsole.log( a )</span><br><span class="line">    &#125;</span><br><span class="line">    var a = 2</span><br><span class="line">    return fn2</span><br><span class="line">&#125;</span><br><span class="line">var fn = fn1()</span><br><span class="line">fn()   // 2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function fn1()&#123;</span><br><span class="line">    var a = 2</span><br><span class="line">    return fn2</span><br><span class="line">&#125;</span><br><span class="line">function fn2()&#123;</span><br><span class="line">    console.log( a )</span><br><span class="line">&#125;</span><br><span class="line">var fn = fn1()</span><br><span class="line">fn()  // 1</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>一个函数引用了外部的变量，这个变量 + 函数 === 闭包，外部作用域中的变量不能被释放，可以通过函数来操作这个变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bindName( name )&#123;</span><br><span class="line">    return function( action )&#123;  // 此函数 + name（argument[0]）就是闭包</span><br><span class="line">        console.log( ` $&#123; name &#125; is $&#123; action &#125;ing ` )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var doing = bindName( &apos;xxx&apos; )</span><br><span class="line">doing( &apos;work&apos; )  // xxx is working</span><br><span class="line">doing( &apos;play&apos; )  // xxx is playing</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP（Hypertext Transfer Protocol）超文本传输协议，它是一种应用层的协议，主要规定了电脑之间传输内容的协议</p>
<ul>
<li>应用层协议：HTTP、DNS、SSH</li>
<li>传输层协议：TCP、UDP</li>
<li>网络层协议：IP</li>
<li>URI ==&gt; 统一资源标识符</li>
<li>URL ==&gt; 统一资源定位符<h4 id="HTTP-报文（HTTP-Message）"><a href="#HTTP-报文（HTTP-Message）" class="headerlink" title="HTTP 报文（HTTP Message）"></a>HTTP 报文（HTTP Message）</h4><h6 id="请求报文（Request-Message）"><a href="#请求报文（Request-Message）" class="headerlink" title="请求报文（Request Message）"></a>请求报文（Request Message）</h6><img src="http://upload-images.jianshu.io/upload_images/9617841-fb7f325b7d9a41d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求报文"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 请求行</span><br><span class="line">method path HTTP/1.1</span><br><span class="line">// 请求头</span><br><span class="line">key: value</span><br><span class="line">Host: 域名</span><br><span class="line">connection: 决定当前的事务完成之后，是否会关闭网络连接，如果该值是 keep-alive ，网络连接就是持久的，不会关闭，使得对同一服务器的请求可以继续在该连接上完成</span><br><span class="line">Pragma: no-cache ==&gt; 与 Cache-Control: no-cache 效果一致，强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证</span><br><span class="line">Cache-Control: no-cache ==&gt; 同上</span><br><span class="line">User-Agent: 用户代理软件的应用类型、操作系统、软件开发商以及版本号</span><br><span class="line">Accept: 告知客户端可以处理的内容类型</span><br><span class="line">Referer: 当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的</span><br><span class="line">Accept-Encoding: 将客户端能够理解的内容编码方式--通常是某种压缩算法--进行通知</span><br><span class="line">Accept-Language: 客户端声明它可以理解的自然语言，以及优先选择的语言</span><br><span class="line">If-None-Match: 条件式请求首部。对于 GET 和 HEAD 请求方法来说，当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 200</span><br><span class="line">Cookie:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="响应报文（Response-Message）"><a href="#响应报文（Response-Message）" class="headerlink" title="响应报文（Response Message）"></a>响应报文（Response Message）</h6><p><img src="http://upload-images.jianshu.io/upload_images/9617841-889b574fe093eb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应报文"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 响应行</span><br><span class="line">HTTP/1.1 HTTP-Status-Code </span><br><span class="line">// 响应头</span><br><span class="line">Cache-Control: 被用于在 HTTP 请求和响应中通过指定指令来实现缓存机制</span><br><span class="line">Content-Encoding: 对特定媒体类型的数据进行压缩</span><br><span class="line">Content-Type: 实际返回的内容的内容类型</span><br><span class="line">Expires: 指定一个日期 | 时间，在这个 日期 | 时间之后，HTTP 响应被认为是过时的</span><br><span class="line">Server: 处理请求的源头服务器所用到的软件相关信息</span><br><span class="line">Set-Cookie: 服务器端向客户端发送 Cookie</span><br><span class="line">Strict-Transport-Security: 安全功能，告知浏览器只能通过 HTTPS 访问当前资源，禁止 HTTP 方式</span><br></pre></td></tr></table></figure>
<h4 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie + Session"></a>Cookie + Session</h4><p>使用 Cookie + Session 可以使得无状态的 HTTP 请求可以记录稳定的状态信息</p>
<ul>
<li>Cookie 是存储在浏览器里的一小段数据</li>
<li>Session 是一种让服务器能够识别某个用户的机制，或者说特指服务器存储的 Session 数据<h6 id="很多网站的静态资源使用-CDN-地址而非使用当前网站域名"><a href="#很多网站的静态资源使用-CDN-地址而非使用当前网站域名" class="headerlink" title="很多网站的静态资源使用 CDN 地址而非使用当前网站域名"></a>很多网站的静态资源使用 CDN 地址而非使用当前网站域名</h6>使用 CDN 加速。从 Cookie 角度上说，发送请求时都会带上 Cookie，但是 Cookie 有跨域限制，即请求相同域名才会带上 Cookie，CDN 与当前域名不一致，故请求 CDN 资源时不会带上 Cookie，使得请求加快，从而达到加速的目的</li>
</ul>
<h6 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h6><ul>
<li>Session 在生产环境中保存在数据库中</li>
<li>Session 是基于 Cookie 实现的</li>
</ul>
<h2 id="Web-安全"><a href="#Web-安全" class="headerlink" title="Web 安全"></a>Web 安全</h2><ol>
<li>传输数据安全</li>
<li>浏览器安全机制</li>
<li>常见攻击： XSS 攻击、CSRF 攻击、点击挟持</li>
</ol>
<h4 id="数据传输安全"><a href="#数据传输安全" class="headerlink" title="数据传输安全"></a>数据传输安全</h4><p>只要使用 HTTP 协议，无论做任何安全措施都是徒劳的，只有 HTTPS 协议才能保证数据在传输过程中的安全</p>
<h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h4><ol>
<li>对称加密：加密和解密都是用同一密钥<ul>
<li>特点： 速度快</li>
<li>常见算法：AES</li>
</ul>
</li>
<li>非对称加密：加密和解密使用不同的密钥，成为公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。<ul>
<li>特点：速度慢，CPU 开销大</li>
<li>常见算法：RSA</li>
</ul>
</li>
<li>Hash：把任意长度数据经过处理变成一个长度固定且唯一的字符串，无法反向解密成原始数据<ul>
<li>特点：验证数据完整性</li>
<li>常见算法：MD5、SHA1、SHA256</li>
</ul>
</li>
</ol>
<h4 id="攻击方式（传输过程中）"><a href="#攻击方式（传输过程中）" class="headerlink" title="攻击方式（传输过程中）"></a>攻击方式（传输过程中）</h4><ul>
<li>拒绝服务：攻击者让目标机器停止提供服务</li>
<li>信息泄露：攻击者获取用户信息</li>
<li>中间人攻击：攻击者通过各种手段，在服务端发出的 HTTP | HTML 报文与显示屏呈现出的 Web 页面之间做一些手脚，篡改网页的部分或者全部内容，从而改变用户在浏览器视窗中看到的内容</li>
<li>重放攻击： 攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性</li>
</ul>
<h4 id="HTTPS-实现安全数据传输"><a href="#HTTPS-实现安全数据传输" class="headerlink" title="HTTPS 实现安全数据传输"></a>HTTPS 实现安全数据传输</h4><h6 id="主要方案"><a href="#主要方案" class="headerlink" title="主要方案"></a>主要方案</h6><ol>
<li>服务器生成一对公钥<strong>服</strong>和私钥<strong>服</strong>，公钥<strong>服</strong>给浏览器</li>
<li>浏览器做对称加密，产生密钥<strong>浏</strong>，使用公钥<strong>服</strong>加密密钥<strong>浏</strong>，发送给服务器</li>
<li>服务器接收到公钥<strong>服</strong>加密的密钥<strong>浏</strong>，服务器使用私钥<strong>服</strong>解密，从而得到密钥<strong>浏</strong></li>
<li>服务器和浏览器使用密钥<strong>浏</strong>进行交流</li>
</ol>
<h6 id="确保浏览器得到的是真正的公钥服"><a href="#确保浏览器得到的是真正的公钥服" class="headerlink" title="确保浏览器得到的是真正的公钥服"></a>确保浏览器得到的是真正的公钥<em>服</em></h6><p>根 CA + 上级 CA + CA 机构</p>
<p>根 CA 担保上级 CA，上级 CA 担保 CA 机构</p>
<p>当一个网站要使用 HTTPS 时先需在一些国际认证的 CA 机构填写网站信息申请证书，而这些 CA机构还有上层 CA，最终有一个根 CA</p>
<p>上述三者都做对称加密，分别得到</p>
<ul>
<li>公钥<strong>根CA</strong> + 私钥<strong>根CA</strong></li>
<li>公钥<strong>上级CA</strong> + 私钥<strong>上级CA</strong></li>
<li>公钥<strong>CA机构</strong> + 私钥<strong>CA机构</strong></li>
</ul>
<p>私钥<strong>根CA</strong> 加密 公钥<strong>上级CA</strong><br>私钥<strong>上级CA</strong> 加密 公钥<strong>CA机构</strong><br>私钥<strong>CA机构</strong> 加密 公钥<strong>服</strong></p>
<p>浏览器都会内置根 CA 和一些顶级 CA 的证书</p>
<p>浏览器所要做的</p>
<ol>
<li>根据 公钥<strong>根CA</strong> 解密 私钥<strong>根CA</strong></li>
<li>根据解密出的 私钥<strong>根CA</strong> 解密 公钥<strong>上级CA</strong></li>
<li>根据解密出的 公钥<strong>上级CA</strong> 解密 私钥<strong>上级CA</strong></li>
<li>根据解密出的 私钥<strong>上级CA</strong> 解密 公钥<strong>CA机构</strong></li>
<li>根据解密出的 公钥<strong>CA机构</strong> 解密 私钥<strong>CA机构</strong></li>
<li>根据解密出的 私钥<strong>CA机构</strong> 解密 公钥<strong>服</strong></li>
</ol>
<p>至此浏览器得到真正的 公钥<strong>服</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-f18b37af49d6383e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12306 网站"><br>说明了 12306 网站的 HTTPS 证书没有机构为其担保，所以浏览器提示连接不安全</p>
<h4 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h4><p>XSS 攻击是一种安全漏洞，攻击者利用这种漏洞在网上注入恶意的客户端代码，<a href="https://bowen-wu.github.io/2018/02/07/HTTP%E7%B3%BB%E5%88%97%20--%20%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%20+%20Cookie/" target="_blank" rel="noopener">详细请看</a></p>
<h6 id="避免方式"><a href="#避免方式" class="headerlink" title="避免方式"></a>避免方式</h6><ol>
<li>所有用户输入的地方都是不安全的，所以不要把用户提交的东西作为 HTML 去运行，即不使用 <code>innerHTML</code></li>
<li>JavaScript 中不要使用 <code>eval()</code></li>
</ol>
<h4 id="CSRF（跨站请求伪造）-攻击"><a href="#CSRF（跨站请求伪造）-攻击" class="headerlink" title="CSRF（跨站请求伪造） 攻击"></a>CSRF（跨站请求伪造） 攻击</h4><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或用特殊方法让该请求地址自动加载，用户在登录状态下这个请求被服务端接受后会被误以为是用户合法的操作，对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户带 Form 表单可用 POST 方式提交参数的页面</p>
<h6 id="避免方式-1"><a href="#避免方式-1" class="headerlink" title="避免方式"></a>避免方式</h6><ol>
<li>用户提交数据时 + 验证步骤</li>
<li>后端给前端传输的数据中，生成随机数，把随机数使用 Set-Cookie 写入到 Cookie 中，同时把随机数写到 Form 表单中（<code>&lt;input type=&#39;hidden&#39; CSRF=&#39;随机数&#39;</code>），当用户提交表单时，服务器收到请求后查看 Form 表单中随机数是否 === Cookie 中随机数</li>
</ol>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>性能优化主要分为加载优化 + 体验优化两方面</p>
<h6 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h6><ol>
<li>服务器网速要好，宽带够，使用 CDN</li>
<li>把所有资源压缩，尤其是图片压缩，选择合适的图片大小，HTML、CSS、JS 压缩</li>
<li>减少请求，生产环境资源打包合并</li>
<li>后端接口速度加快</li>
<li>利用缓存，能重复利用的都重复利用，Cache-Control + ETag</li>
</ol>
<h6 id="体验优化"><a href="#体验优化" class="headerlink" title="体验优化"></a>体验优化</h6><ol>
<li>只给用户暂时需要的东西，按需加载 + 懒加载</li>
<li>代码性能优化</li>
<li>CSS3 动画优先，其次是 JS 动画，transform &gt; position + left &gt; margin-left</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/总结/">总结</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-20T00:39:41.000Z"><a href="/2018/02/20/总结篇（三）-- 你知道-log-出来的-this-是什么么/">2018-02-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/20/总结篇（三）-- 你知道-log-出来的-this-是什么么/">总结篇（三） -- 你知道 log 出来的 this 是什么么</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>函数中的 <code>this</code> 是一个很重要的知识点，如果能清楚的知道各种场景下函数中 <code>this</code> 所代表的值，那么对于我们去理解库 | 框架是很有帮助的，也可以让我们去运用一些更加高级的思想</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this</code> 的使用情况大致分为两种</p>
<ul>
<li>函数中</li>
<li>对象的方法中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this === call | apply | bind 的第一个参数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在判断 <code>this</code> 的值的时候，进行相应的转化是很有必要的</p>
<h4 id="严格模式-非严格模式"><a href="#严格模式-非严格模式" class="headerlink" title="严格模式 + 非严格模式"></a>严格模式 + 非严格模式</h4><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;</span><br><span class="line">function fn( a, b )&#123;</span><br><span class="line">    console.log( this )</span><br><span class="line">&#125;</span><br><span class="line">fn( 1, 2 )</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn( 1, 2 ) === fn.call( undefined, 1, 2 ) === fn.apply( undefined, [1, 2] )</span><br></pre></td></tr></table></figure></p>
<p>答案</p>
<ul>
<li>严格模式 ==&gt; <code>this === undefined</code></li>
<li>非严格模式 ==&gt; <code>this === undefined == 浏览器转化 ==&gt; window</code></li>
</ul>
<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    fn: function( a, b )&#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;,</span><br><span class="line">    child: &#123;</span><br><span class="line">        fn2: function()&#123;</span><br><span class="line">            console.log( this )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn( 1, 2 )</span><br><span class="line">obj.child.fn2()</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.fn( 1, 2 ) === obj.fn.call( obj, 1, 2 ) === obj.fn.apply( undefined, [ 1, 2 ] )  ==&gt; this === obj</span><br><span class="line">obj.child.fn2() === obj.child.fn2.call( obj.child )  ==&gt; this === obj.child</span><br></pre></td></tr></table></figure></p>
<h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">for( let i = 0; i &lt; 3; i++ )&#123;</span><br><span class="line">    arr[ i ] = function()&#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let fn = arr[ 0 ]</span><br><span class="line">arr[ 0 ]</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[ 0 ] ==&gt; arr 对象&#123; 0: fn, 1: fn, 2: fn &#125; ==&gt; arr.0 ==&gt; arr.0.call( this ) ==&gt; this === arr</span><br><span class="line">fn() ==&gt; fn.call( undefined ) ==&gt; this === undefined == 浏览器转化 ==&gt; window</span><br></pre></td></tr></table></figure></p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p><code>bind</code> 的<a href="https://www.jianshu.com/p/e8ad9fdf8e07" target="_blank" rel="noopener">用法</a>在之前有讲过，这个 API 就是返回一个函数 + 绑定 <code>this</code> </p>
<h2 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: 1 &#125;</span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log( this )</span><br><span class="line">    console.log( this.a )</span><br><span class="line">&#125;</span><br><span class="line">let newFn = fn.bind( obj )</span><br><span class="line">newFn()</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newFn() === fn.bind( obj )() ==&gt; this === obj ==&gt; this.a === 1</span><br></pre></td></tr></table></figure></p>
<h2 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    container: document.querySeletor( &apos;body&apos; )</span><br><span class="line">    bind: function()&#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">        this.container.addEventListener( &apos;click&apos;, this.sayHello )</span><br><span class="line">        this.container.addEventListener( &apos;click&apos;, this.sayHello.bind( this ) )</span><br><span class="line">    &#125;,</span><br><span class="line">    sayHello: function()&#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.bind()</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind 中的 ` this ` ==&gt; obj.bind.call( obj ) ==&gt; this === obj</span><br><span class="line">this.container.addEventListener( &apos;click&apos;, this.sayHello ) 当点击事件触发时，sayHello 打印出的 this ==&gt; this === 绑定事件的元素（this.container） ==&gt; this === obj.container</span><br><span class="line">this.container.addEventListener( &apos;click&apos;, this.sayHello.bind( this ) ) 当点击事件触发时，sayHello 打印出的 this ==&gt;  bind 绑定了 this[ this === obj ] ==&gt; sayHello 打印出的 this === obj</span><br></pre></td></tr></table></figure></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数没有 this + arguments</p>
<h2 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    fn1: function()&#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2() &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;,</span><br><span class="line">    fn3: () =&gt; &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn1()</span><br><span class="line">obj.fn2()</span><br><span class="line">obj.fn3()</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj.fn1() === obj.fn1.call( obj ) ==&gt; this === obj</span><br><span class="line">obj.fn2() === obj.fn2.call( obj ) ==&gt; this === obj</span><br><span class="line">fn1 的写法 === fn2 的写法</span><br><span class="line">obj.fn3() === obj.fn3.call( 与 obj 同级 this ) ==&gt; this === window</span><br></pre></td></tr></table></figure></p>
<h2 id="示例七"><a href="#示例七" class="headerlink" title="示例七"></a>示例七</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">        let prop = &#123;</span><br><span class="line">            init: () =&gt; &#123;</span><br><span class="line">                console.log( this )</span><br><span class="line">            &#125;,</span><br><span class="line">            bind() &#123;</span><br><span class="line">                console.log( this )</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        prop.init()</span><br><span class="line">        prop.bind()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.init()</span><br></pre></td></tr></table></figure>
<p>上述中的 <code>this</code> 会打印出什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log( this )  // 2.  this === obj</span><br><span class="line">        let prop = &#123;</span><br><span class="line">            init: () =&gt; &#123;</span><br><span class="line">                console.log( this )  // 4. this === prop 同级 this ==&gt; this === obj </span><br><span class="line">            &#125;,</span><br><span class="line">            bind() &#123;</span><br><span class="line">                console.log( this )  // 6. this === prop</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        prop.init()  // 3. init() 是箭头函数 ==&gt; prop.init.call( prop 同级 this )</span><br><span class="line">        prop.bind()  // 5. bind 不是箭头函数 ==&gt; prop.bind.call( prop )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.init()  // 1.  === obj.init.call( obj )</span><br></pre></td></tr></table></figure></p>
<h2 id="示例八"><a href="#示例八" class="headerlink" title="示例八"></a>示例八</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    x: console.log( this )</span><br><span class="line">    fn1() &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">        setTimeout( function()&#123;</span><br><span class="line">            console.log( this )</span><br><span class="line">        &#125;, 10 )</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2() &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            console.log( this )</span><br><span class="line">        &#125;, 20 )</span><br><span class="line">    &#125;,</span><br><span class="line">    fn3() &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">        setTimeout( function()&#123;</span><br><span class="line">            console.log( this )</span><br><span class="line">        &#125;.bind( this ), 30 )</span><br><span class="line">    &#125;,</span><br><span class="line">    fn4: () =&gt; &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            console.log( this )</span><br><span class="line">        &#125;, 40 )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn1()</span><br><span class="line">obj.fn2()</span><br><span class="line">obj.fn3()</span><br><span class="line">obj.fn4()</span><br></pre></td></tr></table></figure>
<p><strong>obj.x 的值是什么？</strong></p>
<p>上述中的 <code>this</code> 会打印出什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    x: console.log( this )  // console.log( this ) 的值是 undefined ==&gt; obj.x === undefined  其中的 this === window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fn1()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn1() &#123;</span><br><span class="line">    console.log( this )   // 2. this === obj</span><br><span class="line">    setTimeout( function()&#123;</span><br><span class="line">        console.log( this )  </span><br><span class="line">    &#125;, 10 )</span><br><span class="line">    // 3. 等价于</span><br><span class="line">    // function fn()&#123;</span><br><span class="line">    //     console.log( this )  // 5. this === undefined == 浏览器转化 ==&gt; window</span><br><span class="line">    // &#125;</span><br><span class="line">    // 过 10s 执行函数 fn</span><br><span class="line">    // fn()   // 4. fn 非箭头函数  fn.call( undefined ) </span><br><span class="line">&#125;</span><br><span class="line">obj.fn1()  // 1. fn1 非箭头函数  obj.fn1.call( obj )</span><br></pre></td></tr></table></figure></p>
<p><strong>fn2()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn2() &#123;</span><br><span class="line">    console.log( this )   // 2. this === obj</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        console.log( this )  // 5. this === 上级 this  ==&gt; this === obj</span><br><span class="line">    &#125;, 20 )</span><br><span class="line">    // 3. 等价于</span><br><span class="line">    // () =&gt; &#123;</span><br><span class="line">    //     console.log( this )</span><br><span class="line">    // &#125;</span><br><span class="line">    // 过 20s 执行箭头函数</span><br><span class="line">    // 箭头函数()  // 4. 箭头函数 箭头函数.call( 上级this )</span><br><span class="line">&#125;</span><br><span class="line">obj.fn2()  // 1. fn2 非箭头函数  obj.fn2.call( obj )</span><br></pre></td></tr></table></figure></p>
<p><strong>fn3()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn3() &#123;</span><br><span class="line">    console.log( this )  // 2.  this === obj</span><br><span class="line">    setTimeout( function()&#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;.bind( this ), 30 )</span><br><span class="line">    // 3.  等价于</span><br><span class="line">    // function fn()&#123;</span><br><span class="line">    //     console.log( this )  // 5. this === obj</span><br><span class="line">    // &#125;.bind( this )</span><br><span class="line">    // 过 30s 执行函数 fn</span><br><span class="line">    // fn.bind(this)  // 4. fn 非箭头函数 + bind 绑定 this[ this === obj ]</span><br><span class="line">&#125;</span><br><span class="line">obj.fn3()  // 1. fn3 非箭头函数  obj.fn3.call( obj )</span><br></pre></td></tr></table></figure></p>
<p><strong>fn4()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn4: () =&gt; &#123;</span><br><span class="line">    console.log( this )  // 2. this === obj 同级 this  ==&gt; this === window</span><br><span class="line">    setTimeout( () =&gt; &#123;</span><br><span class="line">        console.log( this )</span><br><span class="line">    &#125;, 40 )</span><br><span class="line">    // 3. 等价于</span><br><span class="line">    // () =&gt; &#123;</span><br><span class="line">    //     console.log( this )  // 5. this === window</span><br><span class="line">    // &#125;</span><br><span class="line">    // 过 40s 后执行箭头函数</span><br><span class="line">    // 箭头函数()   // 4. 箭头函数  箭头函数.call( 上级 this )</span><br><span class="line">&#125;</span><br><span class="line">obj.fn4() // 1. fn4 箭头函数  obj.fn4.call( obj 同级 this )</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>判断函数中 <code>this</code> 步骤</p>
<ol>
<li>查看调用函数的类型</li>
<li>箭头函数<ul>
<li>箭头函数.call( 上级 this )</li>
<li>obj.箭头函数.call( obj 同级 this )</li>
</ul>
</li>
<li>非箭头函数<ul>
<li>非箭头函数.call( undefined )</li>
<li>obj.非箭头函数.call( obj )</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/总结/">总结</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:43:26.000Z"><a href="/2018/02/19/前端基础系列（四） -- 内存/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（四） -- 内存/">前端基础系列（四） -- 内存</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>电脑开机之后就把硬盘中的数据传输到内存中，例如操作系统，把硬盘中的操作系统读到内存中即是开机。内存特点是：存储数据快，一旦断电，数据就丢失了。与内存相对应的是外存，表示无论断电与否，数据都存在，外存的存储速度慢。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Chrome 浏览器打开之后大约占用了 1G 的内存，分别分配给每个页面，每个页面大约占用 100M ，其中包括了：</p>
<pre><code>1. HTML + CSS
2. JavaScript
3. 网络 HTTP
4. 其他
</code></pre><p>所以 JavaScript 最多占用约 100M 的内存。</p>
<h2 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h2><p>JS 将内存划分为两个大区，分别是<strong>代码区（存储代码）</strong>和<strong>数据区（存储数据）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  a = 1  // 变量 a 存储在代码区  数字 1 存储在数据区 二者以 JS 引擎关联</span><br></pre></td></tr></table></figure></p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><p>数据区分为 <strong>Stack(栈内存)</strong> 和 <strong>Heap(堆内存)</strong>。</p>
<ul>
<li><p><strong>Stack（栈内存）</strong>存储方式是以一行一行存储，类似栈，故而叫做栈内存</p>
</li>
<li><p><strong>Heap（堆内存）</strong>存储方式是以堆存储</p>
</li>
</ul>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ol>
<li>数字是以 64 位浮点数进行存储</li>
<li>字符是以 16 位的进行存储。</li>
</ol>
<ul>
<li><p>存储 <code>var a = 1</code> 时，a 在代码区，1 以64位浮点数存储在栈内存。</p>
</li>
<li><p>存储 <code>var b = 2</code> 时，b 在代码区，2 以64位浮点数存储在栈内存。</p>
</li>
</ul>
<p><strong>注意：</strong>当 <code>b = a</code> 时，将 a 中的数据复制并覆盖到 b 的数据上。</p>
<ul>
<li><p>存储 <code>var a = true</code> 时，a 在代码区，true 转化为 1 ，之后以64位浮点数存储在栈内存。</p>
</li>
<li><p>存储 <code>var obj1 = {}</code> 时，obj1 在代码区，在栈内存中会存有一个以64位浮点数的地址，<strong>引用</strong>的是堆内存中的一个地址，obj1 中的数据将存储在堆内存中的一个地址，如果在后面在 <strong>添加 obj1 的属性</strong> ，继续放在堆内存中。</p>
</li>
<li><p>存储 <code>var obj2 = {}</code> 时，obj2 在代码区，在栈内存中会存有一个以64位浮点数的地址，<strong>引用</strong>的是堆内存中的一个地址，obj2 中的数据将存储在堆内存中的一个地址。</p>
</li>
</ul>
<p><strong>注意：</strong>当 <code>obj2 = obj1</code> 时，和 <code>b = a</code> 做的事情完全相同，即将 obj1 中的数据地址复制并覆盖到 obj2 的数据地址上。</p>
<h2 id="数据类型存储方法："><a href="#数据类型存储方法：" class="headerlink" title="数据类型存储方法："></a>数据类型存储方法：</h2><p>JavaScript 中有 7 种数据类型</p>
<ol>
<li><p>简单数据类型（6种）直接存储在 <strong>Stack（栈内存）</strong>中</p>
</li>
<li><p>复杂数据类型（Object）在 <strong>Stack（栈内存）</strong>中存储 <strong>Heap（堆内存）</strong>的地址</p>
<p><strong>所有的变量和对象的关系都是引用关系。</strong></p>
</li>
</ol>
<h2 id="套路："><a href="#套路：" class="headerlink" title="套路："></a>套路：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; n: 1 &#125;;  </span><br><span class="line">var b = a;</span><br><span class="line">a.x = a = &#123; n:2 &#125;;  //当浏览器运行这句话时，首先确定 a 的值，之后执行    &#123; n:2 &#125;，之后执行 a = &#123;  n:2 &#125;，之后执行 a.x (此时的 a 是之前确定的 a )。</span><br><span class="line">alert( a.x );  //undefined</span><br><span class="line">alert( b.x );  //[object Object]</span><br></pre></td></tr></table></figure>
<p>  <img src="http://upload-images.jianshu.io/upload_images/9617841-f91366eefddfc88f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存图"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>如果一个对象没有被引用，就是垃圾，将会被回收（释放内存）。</p>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>由于浏览器的 BUG ，使得应该被标记为垃圾的东西，没有被标记为垃圾，造成内存被永久占用，除非把浏览器关闭。<br><strong>解决方法</strong>：在关闭页面之前把所有的事件设置为 null 。</p>
<h4 id="浅拷贝-amp-深拷贝"><a href="#浅拷贝-amp-深拷贝" class="headerlink" title="浅拷贝&amp;深拷贝"></a>浅拷贝&amp;深拷贝</h4><h6 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = a;  </span><br><span class="line">b = 2;        // b 变不影响 a，即是深拷贝</span><br><span class="line">alert( a );  // 1</span><br></pre></td></tr></table></figure>
<p>对于<strong>基本类型</strong>，所有的赋值 “ = “ 都是深拷贝</p>
<p>所以在谈及深拷贝和浅拷贝时是不考虑基本类型的，因为基本类型的赋值都是深拷贝</p>
<h6 id="复杂数据类型（Object）"><a href="#复杂数据类型（Object）" class="headerlink" title="复杂数据类型（Object）"></a>复杂数据类型（Object）</h6><p>浅拷贝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; name : &apos;a&apos; &#125;;</span><br><span class="line">var b = a;</span><br><span class="line">b.name = &apos;b&apos; ;   // b 变致 a 变，即是浅拷贝</span><br><span class="line">alert( a.name );  // &apos;b&apos;</span><br></pre></td></tr></table></figure></p>
<p>深拷贝：b 复制 a 的所有数据，但是地址不同，最终的结果就是 b 变是 b 自己的事情，与 a 无关，即 b 变不影响 a </p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:41:25.000Z"><a href="/2018/02/19/前端基础系列（三） -- 算法 + 数据结构基础/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（三） -- 算法 + 数据结构基础/">前端基础系列（三） -- 算法 + 数据结构基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h1><ol>
<li>一行一行执行</li>
<li>有条件控制语句 if…else…</li>
<li>有循环控制语句 while(exp) do…<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2></li>
</ol>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol>
<li><strong>输入</strong>：一个算法必须有<strong>零个</strong>或以上输入量。</li>
<li><strong>输出</strong>：一个算法应有一个或以上输出量，输出量是算法计算的结果。</li>
<li><strong>明确性</strong>：算法的描述必须无歧义，以保证算法的实际执行结果是精确地 匹配要求或期望，通常要求实际运行结果是确定的。</li>
<li><strong>有限性</strong>：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。</li>
<li><strong>有效性</strong>：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>即数据的结构</p>
<h3 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h3><p>键值对： <code>{ &#39;键&#39;  : &#39;值&#39; }</code> ==&gt;  Array / Object</p>
<ul>
<li><p><strong>计数排序</strong>：计数排序使用一个额外的数组 <code>arr</code> （<em>hash</em>），其中第 i 个元素是待排序数组  <code>Arr</code> 中值等于 i 的元素的个数。然后根据数组 <code>arr</code> 来将 <code>Arr</code> 中的元素排到正确的位置（用到了桶，但是每个桶中只有相同的数字，空间浪费）（<strong>所有的桶是Hash，桶里是队列，先进先出</strong>）。<br>  <strong>复杂度：<code>n + max</code></strong><br>  <strong>缺点：</strong></p>
<pre><code>1. 需要一个哈希表示计数工具。
2. 无法对小数和负数排序
</code></pre></li>
<li><p><strong>桶排序</strong>：将数组分到有限数量的桶里。每个桶再个别排序，此时可以用其他排序方法（<strong>所有的桶是Hash，桶里是队列，先进先出</strong>）</p>
</li>
<li><p><strong>基数排序</strong>：只有十个桶（0 - 9），先排个位，之后十位，依次到最高位（<strong>所有的桶是Hash，桶里是队列，先进先出</strong>）<br><strong>说明：比较排序的极限 <code>n*logN</code></strong></p>
</li>
</ul>
<h3 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h3><ul>
<li>特点：<strong>先进先出</strong></li>
<li>可以用数组实现</li>
</ul>
<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><ul>
<li>特点：<strong>先进后出</strong></li>
<li>可以用数组实现</li>
</ul>
<h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h3><ul>
<li><p>是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<strong>指针(Pointer)</strong>。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</p>
</li>
<li><p>数组无法直接删除中间的一项，但是链表可以，链表是<strong>动态数组</strong></p>
</li>
<li><p>Hash 实现链表，<strong>head</strong> 表示第一个 Hash ，所有的 Hash 都是节点（<strong>node</strong>）</p>
</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li><p>是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有<strong>层次关系</strong>的集合</p>
</li>
<li><p><strong>特点</strong>：</p>
<ol>
<li>每个节点有零个或多个子节点</li>
<li>没有父节点的节点称为根节点</li>
<li>每一个非根节点有且只有一个父节点</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树</li>
</ol>
</li>
<li><p><strong>术语</strong>：</p>
<ol>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
</ol>
</li>
<li><p><strong>二叉树（Binary tree）</strong>：每个节点<strong>最多</strong>含有<strong>两个子树</strong>的树称为二叉树</p>
<ol>
<li>二叉树的第 i 层至多拥有<strong>2的( i-1 )次幂</strong>个节点数</li>
</ol>
</li>
<li><p><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树</p>
<ol>
<li><p>在一棵二叉树中，除<strong>最后一层</strong>外，若其余层都是满的，并且最后一层<strong>或者</strong>是满的，<strong>或者</strong>是在<strong>右边</strong>缺少连续若干节点，则此二叉树为<strong>完全二叉树</strong>（Complete Binary Tree）</p>
</li>
<li><p>具有n个节点的完全二叉树的深度为<strong>log以2为底n的对数＋1</strong>。深度为k的完全二叉树，至少有<strong>2的ｋ次幂</strong>个节点，至多有<strong>2的( k+1 )次幂 - 1</strong>个节点</p>
</li>
</ol>
</li>
<li><p><strong>满二叉树</strong>：所有叶节点都在最底层的完全二叉树</p>
<ol>
<li><p>一棵深度为k，且有<strong>2的( k+1 )次幂 - 1</strong>个节点的二叉树，称为<strong>满二叉树（Full Binary Tree）</strong></p>
</li>
<li><p>每一层上的节点数都是最大节点数</p>
</li>
</ol>
</li>
</ul>
<p><strong>说明：用数组存储满二叉树和完全二叉树，用Hash存储其他的树</strong></p>
<h1 id="算法和数据结构结合"><a href="#算法和数据结构结合" class="headerlink" title="算法和数据结构结合"></a>算法和数据结构结合</h1><ol>
<li>我们要解决一个跟数据相关的问题</li>
<li>分析这个问题，想出对应的数据结构</li>
<li>分析数据结构，想出算法<br><strong>数据结构和算法是互相依存、不可分开的</strong></li>
</ol>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ol>
<li><p><strong>分治法</strong>：把一个问题分区成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。<strong>前端主要使用分治法</strong></p>
</li>
<li><p><strong>动态规划法</strong>：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法</p>
</li>
<li><p><strong>贪婪算法</strong>：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法</p>
</li>
<li><p><strong>线性规划法</strong>：见词条</p>
</li>
<li><p><strong>简并法</strong>：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法</p>
</li>
</ol>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ul>
<li><strong>冒泡排序</strong>：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</li>
</ul>
<ul>
<li><strong>选择排序</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
</ul>
<ul>
<li><strong>插入排序</strong>：通过构建有序序列，对于未排序数据，在<strong>已排序序列</strong>中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>
</ul>
<ul>
<li><strong>基数排序</strong>：将整数按位数切割成不同的数字，然后按每个位数分别比较。将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从<strong>最低位</strong>开始，依次进行一次排序。这样从<strong>最低位</strong>排序一直到<strong>最高位</strong>排序完成以后，数列就变成一个有序序列。</li>
</ul>
<ul>
<li><strong>快速排序</strong>：快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。<br>步骤为：<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）</strong>操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>
</ol>
</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:40:03.000Z"><a href="/2018/02/19/前端基础系列（二） -- 命令行基础/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（二） -- 命令行基础/">前端基础系列（二） -- 命令行基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>命令行操作会解放我们的鼠标，让我们更加流畅的进行我们想要的操作</p>
<h1 id="文件与文件夹（目录）"><a href="#文件与文件夹（目录）" class="headerlink" title="文件与文件夹（目录）"></a>文件与文件夹（目录）</h1><ul>
<li><code>~</code> ==&gt; 用户目录</li>
<li><code>/</code> ==&gt; 所有硬盘</li>
<li><code>.</code> ==&gt; 当前目录</li>
<li><code>..</code> ==&gt; 父级目录</li>
<li><code>$</code> ==&gt; 已准备好</li>
<li><code>directory</code> ==&gt; 目录文件夹</li>
<li><code>file</code> ==&gt; 文件</li>
<li><code>make</code> ==&gt; 新建</li>
<li><code>remove</code> ==&gt; 删除</li>
<li><code>move</code> ==&gt; 移动</li>
<li><code>list</code> ==&gt; 枚举</li>
<li><code>link</code> ==&gt; 链接（windows不支持）</li>
<li><code>find</code> ==&gt; 查找</li>
<li><code>echo</code> ==&gt; 发出回音、重复</li>
<li><code>touch</code> ==&gt; 触摸</li>
<li><code>change</code> ==&gt; 改变</li>
<li><code>copy</code> ==&gt; 复制</li>
</ul>
<h1 id="缩写规则"><a href="#缩写规则" class="headerlink" title="缩写规则"></a>缩写规则</h1><p>删除元音字母（A E I O U）,保留前两个到三个辅音</p>
<ul>
<li><code>mkdir</code> ==&gt; <code>make directory</code> ==&gt; 创建目录</li>
<li><code>rm</code> ==&gt; <code>remove</code> ==&gt; 删除</li>
<li><code>mv</code> ==&gt; <code>move</code> ==&gt; 移动、重命名</li>
<li><code>cp</code> ==&gt; <code>copy</code> ==&gt; 复制</li>
<li><code>ls</code> ==&gt; <code>list</code> ==&gt; 枚举</li>
<li><code>cd</code> ==&gt; <code>change directory</code> ==&gt; 改变目录</li>
<li><code>-rf</code> ==&gt; 用于删除目录，其中：<ul>
<li><code>-r</code> ==&gt; 文件夹的递归操作</li>
<li><code>-f</code> ==&gt; 强制，否则每个文件都要询问</li>
</ul>
</li>
</ul>
<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><ul>
<li><p><code>cd</code> ==&gt; 进入目录</p>
</li>
<li><p><code>pwd</code> ==&gt; 显示当前目录 </p>
</li>
<li><p><code>mkdir 目录名</code> ==&gt; 创建目录</p>
</li>
<li><p><code>mkdir -p 目录路径</code> ==&gt; 创建目录（<em>eg.：mkdir -p demo/outter/inner</em>），如果<code>目录路径</code>有特殊字符（<em>eg.：空格</em>）要加引号。所以坚决避免有特殊字符</p>
</li>
<li><p><code>whoami</code> ==&gt; 我是谁</p>
</li>
<li><p><code>ls</code> ==&gt; 查看路径</p>
</li>
<li><p><code>ls -a</code> ==&gt; 查看路径（显示所有文件【包括隐藏文件】）</p>
</li>
<li><p><code>ls -l</code> ==&gt; 查看路径（包括详细信息）</p>
</li>
<li><p><code>ls -al</code> | <code>ls -la</code> ==&gt; <code>ls -a</code> + <code>ls -l</code></p>
</li>
<li><p><code>touch 文件名</code> ==&gt; 创建文件</p>
</li>
<li><p><code>touch 文件名（已存在的文件名）</code> ==&gt; 改变文件更新时间</p>
</li>
<li><p><code>cp 源路径 目标路径</code> ==&gt; 复制文件</p>
</li>
<li><p><code>cp -r 源路径 目标路径</code> ==&gt; 复制目录</p>
</li>
<li><p><code>mv 源路径 目标路径</code> ==&gt; 移动节点</p>
</li>
<li><p><code>rm 文件路径</code> ==&gt; 删除文件</p>
</li>
<li><p><code>rm -f 文件路径</code> ==&gt; 强制删除文件</p>
</li>
<li><p><code>rm -r 目录路径</code> ==&gt; 删除目录</p>
</li>
<li><p><code>rm -rf 目录路径</code> ==&gt; 强制删除目录</p>
</li>
<li><p><code>curl -L http://www.baidu.com &gt; baidu.html</code> ==&gt; 下载文件</p>
</li>
<li><p><code>df -kh</code> ==&gt; 磁盘占用</p>
</li>
<li><p><code>du -sh</code> ==&gt; 当前目录大小</p>
</li>
<li><p><code>du -h</code> ==&gt; 各文件大小</p>
</li>
</ul>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>使用 git 三种方式</p>
<ol>
<li>只在本地上使用</li>
<li>将本地仓库上传到github</li>
<li>下载github上的仓库</li>
</ol>
<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone &apos;SSH地址&apos; ==&gt; 下载仓库</span><br><span class="line">git init  ==&gt; 初始化本地仓库 .git 目录</span><br><span class="line">git status -sb ==&gt; 显示当前所有文件状态</span><br><span class="line">git add . ==&gt; 把当前目录（&apos;.&apos; 表示当前目录）里面的变动添加到【暂存区】</span><br><span class="line">git commit -m &apos;信息&apos; ==&gt; 将 &apos;add&apos; 的内容【正式提交】到本地仓库，并添加注释信息</span><br><span class="line">git commit --amend -m &apos;信息&apos; ==&gt; 修改上次的注释信息</span><br><span class="line">git log ==&gt; 历史变动</span><br></pre></td></tr></table></figure>
<p><code>git status -sb</code> ==&gt; <code>-s(summary)：显示总结</code> + <code>-b(branch)：显示分支</code><br><code>start css/style.css</code> ==&gt; 使用默认编辑器打开 style.css<br>如果有新的变动，需要一次执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;信息&apos;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>git status -sb</code> ==&gt; 显示当前所有文件状态，其中：<br>  <code>??</code> ==&gt; 表示待处理<br>  <code>A</code> ==&gt; 表示添加<br>  <code>M</code> ==&gt; 表示这个文件被修改了（Modified）</li>
</ul>
<h3 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">mkdir + touch</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;信息&apos;</span><br></pre></td></tr></table></figure>
<h3 id="将本地仓库上传到github"><a href="#将本地仓库上传到github" class="headerlink" title="将本地仓库上传到github"></a>将本地仓库上传到github</h3><p>create a new repository on the command line<br>创建一个新仓库在命令行中<br>push an existing repository from the command line<br>添加一个现有的仓库从命令行<br><strong>注</strong>：existing — 现有</p>
<h3 id="直接在github创建一个仓库然后下载本地"><a href="#直接在github创建一个仓库然后下载本地" class="headerlink" title="直接在github创建一个仓库然后下载本地"></a>直接在github创建一个仓库然后下载本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create a new repository</span><br><span class="line">repository name</span><br><span class="line">Decription</span><br><span class="line">Initilize this repository with a README</span><br><span class="line">Add .gitignore : Node</span><br><span class="line">Add a license : MIT License</span><br><span class="line">clone or download</span><br><span class="line">Use SSH ==&gt; git@github.com开头地址</span><br><span class="line">在要粘贴的文件夹 git bash here</span><br><span class="line">git clone &apos;地址&apos;</span><br></pre></td></tr></table></figure>
<h3 id="上传更新"><a href="#上传更新" class="headerlink" title="上传更新"></a>上传更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. git add 文件路径</span><br><span class="line">2. git commit -m &apos;信息&apos;</span><br><span class="line">3. git pull</span><br><span class="line">4. git push</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：在命令行中输入命令是区分大小写</p>
<h3 id="github-上删除-node-modules"><a href="#github-上删除-node-modules" class="headerlink" title="github 上删除 node_modules"></a>github 上删除 node_modules</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached node_modules  // --cached不会把本地的.idea删除</span><br><span class="line">git commit -m &apos;delete node_modules&apos;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h1 id="命令行技巧"><a href="#命令行技巧" class="headerlink" title="命令行技巧"></a>命令行技巧</h1><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p>~/.bashrc 文件的功能很强大</p>
<p>自动运行</p>
<ol>
<li><code>touch ~/.bashrc</code></li>
<li><code>start ~/.bashrc</code></li>
<li>编辑 <code>~/.bashrc</code>，内容为 <code>cd ~/Desktop</code>，重启 Git Bash，默认就进入桌面目录了<br>可以用 <code>~/.bashrc</code> 在进入 Git Bash 前执行任何命令，十分方便</li>
</ol>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><ol>
<li>在 <code>~/.bashrc</code> 里新增一行 <code>alias b=&quot;echo &#39;bowen is awesome&#39;&quot;</code></li>
<li>运行 <code>source ~/.bashrc</code>，作用是执行 <code>~/.bashrc</code></li>
<li>运行<code>b</code>，就会看到 <code>bowen is awesome</code></li>
<li>也就是说，现在 <code>b</code> 就是 <code>echo &#39;bowen is awesome&#39;</code> 的缩写了</li>
</ol>
<h5 id="常见命令缩写"><a href="#常见命令缩写" class="headerlink" title="常见命令缩写"></a>常见命令缩写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alias la=&apos;ls -a&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;</span><br><span class="line">alias gst=&apos;git status -sb&apos;</span><br><span class="line">alias ga=&apos;git add&apos;</span><br><span class="line">alias ga.=&apos;git add .&apos;</span><br><span class="line">alias gc=&apos;git commit&apos;</span><br><span class="line">alias gc.=&apos;git commit .&apos;</span><br></pre></td></tr></table></figure>
<p>保存退出，然后运行 <code>source ~/.bashrc</code></p>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ul>
<li>绝对路径： 以 <code>/</code> 开头的路径就是绝对路径</li>
<li>隐藏文件以 <code>.</code> 开头</li>
<li>d — 目录、r — 可读、w — 可写、x — 可执行<br>rwx（管理员权限）<br>r-x（用户所在组权限）<br>r-x（任意用户权限）<br><img src="http://upload-images.jianshu.io/upload_images/9617841-96efb0bf3fef1021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更多信息"></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:37:54.000Z"><a href="/2018/02/19/前端基础系列（一） -- 编程基础/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（一） -- 编程基础/">前端基础系列（一） -- 编程基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>操作系统</strong>运行于<strong>硬件</strong>之上，<strong>浏览器</strong>运行于<strong>操作系统</strong>之上，<strong>HTML | CSS | JavaScript</strong>运行于<strong>浏览器</strong>之上，HTML | CSS | JavaScript 的所有<strong>数据</strong>都来自于服务器</p>
<h1 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h1><h3 id="如何存储0和1"><a href="#如何存储0和1" class="headerlink" title="如何存储0和1"></a>如何存储0和1</h3><p>1 — 充电<br>0 — 不充电<br>充完电之后立刻放电<br>cpu — 表示每秒钟可以充多少次电</p>
<h3 id="如何储存数字"><a href="#如何储存数字" class="headerlink" title="如何储存数字"></a>如何储存数字</h3><p><strong>十进制 — 十六进制</strong></p>
<p>0—0    1—1    2—2    3—3    4—4    5—5    6—6    7—7    8—8</p>
<p>9—9    10—A    11—B    12—C    13—D    14—E    15—F</p>
<p><strong>二进制 — 十六进制（4位，不足位数补0）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000---0    0001---1    0010---2    0011---3    0100---4    </span><br><span class="line"></span><br><span class="line">0101---5    0110---6    0111---7    1000---8    1001---9    </span><br><span class="line"></span><br><span class="line">1010---A   1011---B    1100---C    1101---D    1110---E    1111-F</span><br></pre></td></tr></table></figure></p>
<h3 id="如何存储字符（二进制）"><a href="#如何存储字符（二进制）" class="headerlink" title="如何存储字符（二进制）"></a>如何存储字符（二进制）</h3><p>ASCII</p>
<h3 id="如何存储中文-十六进制"><a href="#如何存储中文-十六进制" class="headerlink" title="如何存储中文(十六进制)"></a>如何存储中文(十六进制)</h3><p>GB2312 ==&gt; GBK </p>
<h3 id="如何存储所有字符（32位）"><a href="#如何存储所有字符（32位）" class="headerlink" title="如何存储所有字符（32位）"></a>如何存储所有字符（32位）</h3><p>Unicode字符集 ==&gt; UTF-8（是一种编码方式，不是字符集，减少内存使用）<br><img src="http://upload-images.jianshu.io/upload_images/9617841-668635fe2645fe2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-6edf22ac8e6ca336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>javascript使用了Unicode字符集，但是没有使用UTF-8编码（ES6解决了）。ES5只能表示两个字节以内的字符</p>
<h1 id="GitHub-的使用"><a href="#GitHub-的使用" class="headerlink" title="GitHub 的使用"></a>GitHub 的使用</h1><h3 id="新建库"><a href="#新建库" class="headerlink" title="新建库"></a>新建库</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-8deb8a7ddcda4ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="库的名字"><a href="#库的名字" class="headerlink" title="库的名字"></a>库的名字</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ae36665ad523fb02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-12f6b7c2c15c713b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<ul>
<li>在本地新建一个文件夹，之后用 git bash 打开，在 git bash 中输入<br><img src="http://upload-images.jianshu.io/upload_images/9617841-a3d89a0edd565a46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></li>
</ul>
<p>代表成功。此处若出现问题，则需要配置git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &apos;your username&apos; </span><br><span class="line">git config --global user.email &apos;your email&apos;</span><br><span class="line">git config --global push.default simple </span><br><span class="line">git config --global core.quotepath false </span><br><span class="line">git config --global core.editor &quot;vim&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-3017859e723e5ab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="若-git-push-u-origin-master出现错误，则需要进行下面的配置，点击-settings"><a href="#若-git-push-u-origin-master出现错误，则需要进行下面的配置，点击-settings" class="headerlink" title="若 git push -u origin master出现错误，则需要进行下面的配置，点击 settings"></a>若 <code>git push -u origin master</code>出现错误，则需要进行下面的配置，点击 <code>settings</code></h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-362acb3e91510047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="点击-SSH-and-GPG-keys"><a href="#点击-SSH-and-GPG-keys" class="headerlink" title="点击  SSH and GPG keys"></a>点击  <code>SSH and GPG keys</code></h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-96e958352b0fd829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-fdabe695803b8cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-92781ddcb31041a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><strong>注意添加自己的邮箱，回车。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-45f8b29e96ea12bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="将生成的文件打印"><a href="#将生成的文件打印" class="headerlink" title="将生成的文件打印"></a>将生成的文件打印</h3><p>在 git bash 中输入 <code>cat ~/.ssh/id_rsa.pub</code> 将输出的东西复制</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-0d0209c20a027a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="title-随意填写，将刚刚复制的粘贴到-Key-中"><a href="#title-随意填写，将刚刚复制的粘贴到-Key-中" class="headerlink" title="title 随意填写，将刚刚复制的粘贴到 Key 中"></a>title 随意填写，将刚刚复制的粘贴到 <code>Key</code> 中</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-06da618856a7d9ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="之后再一次在-git-bash-中输入git-push-u-origin-master-即可，出现下面的即表示成功。"><a href="#之后再一次在-git-bash-中输入git-push-u-origin-master-即可，出现下面的即表示成功。" class="headerlink" title="之后再一次在 git bash 中输入git push -u origin master 即可，出现下面的即表示成功。"></a>之后再一次在 git bash 中输入<code>git push -u origin master</code> 即可，出现下面的即表示成功。</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-768c35ff60764678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-1be5010b6ee210a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-9a82d100b485c46e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="之后运用-vs-Code-编辑在本地创建的文件夹"><a href="#之后运用-vs-Code-编辑在本地创建的文件夹" class="headerlink" title="之后运用 vs Code 编辑在本地创建的文件夹"></a>之后运用 vs Code 编辑在本地创建的文件夹</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-d5f34e0530589b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<ul>
<li>进行提交<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b25c7fae9b69d1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"><br><img src="http://upload-images.jianshu.io/upload_images/9617841-534685159088a058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></li>
</ul>
<h3 id="点击-推送，之后刷新-github-页面，即可看到更新"><a href="#点击-推送，之后刷新-github-页面，即可看到更新" class="headerlink" title="点击 推送，之后刷新 github 页面，即可看到更新"></a>点击 <code>推送</code>，之后刷新 github 页面，即可看到更新</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-a3a9e4422b103879.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-528cc4d48bc6a620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="之后填写内容，提交推送，刷新-github"><a href="#之后填写内容，提交推送，刷新-github" class="headerlink" title="之后填写内容，提交推送，刷新 github"></a>之后填写内容，提交推送，刷新 github</h3><h3 id="在-github-上查看HTML文件"><a href="#在-github-上查看HTML文件" class="headerlink" title="在 github 上查看HTML文件"></a>在 github 上查看HTML文件</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-5cc389c5db29614b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-4053f515854eb58f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-c12e5d26330d3a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="先在浏览器中粘贴地址，并加上文件名，之后复制地址"><a href="#先在浏览器中粘贴地址，并加上文件名，之后复制地址" class="headerlink" title="先在浏览器中粘贴地址，并加上文件名，之后复制地址!"></a>先在浏览器中粘贴地址，并加上文件名，之后复制地址!</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-899dbd492369dc42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-88fa798f1f640992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Nächste Seite</a>
  
  <div class="clearfix"></div>
</nav></div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>5</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>4</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
