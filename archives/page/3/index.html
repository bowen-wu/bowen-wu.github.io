<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Seite 3 | Archiv | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/archives/page/3/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">Archiv</h2>
<p></p>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:54:17.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（三）-- 堆叠上下文/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（三）-- 堆叠上下文/">CSS 最佳实践 + 套路（三） -- 堆叠上下文</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p>
<ul>
<li>根元素（HTML）</li>
<li><strong>z-index 不为 auto 的 absolute/relative</strong></li>
<li>一个 z-index 值不为 auto 的 flex 项目，即父元素 display: flex/inline-flex</li>
<li>opacity 属性值小于 1 的元素</li>
<li>transform 属性不为 none 的元素</li>
<li>mix-blend-mode 属性值不为 normal 的元素</li>
<li>filter 不为 none 的元素</li>
<li>perspective 值不为 none 的元素</li>
<li>isolation 属性被设置为 isolate 的元素</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即使没有直接指定这些属性的值</li>
<li>-webkit-overflow-scrolling 属性被设置为 touch 的元素</li>
</ul>
<p>#堆叠层级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负z-index(父元素没有position: relative/absolute) &lt; position: static（background-color &lt; border &lt; 负z-index(父元素position: relative/absolute)  &lt; div/块级元素 &lt; 浮动元素 &lt; 浮动元素内的文字/内联元素 &lt; 浮动元素外面的文字/内联元素） &lt; position: relative/absolute &lt; 正z-index</span><br></pre></td></tr></table></figure></p>
<ul>
<li>相同的属性按先后顺序排列</li>
<li>具有相同 <code>position</code> 属性的 + <code>z-index</code> 只能覆盖相同 <code>position</code> 属性（<code>relative === absolute</code>）的元素</li>
</ul>
<h1 id="作用-影响"><a href="#作用-影响" class="headerlink" title="作用 + 影响"></a>作用 + 影响</h1><p>堆叠上下文主要是影响 <code>z-index</code><br><code>z-index: 2</code> 永远在 <code>z-index: 0</code> 的上方么？<br><img src="http://upload-images.jianshu.io/upload_images/9617841-d931d5aaeb0f0ab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 01"><br><img src="http://upload-images.jianshu.io/upload_images/9617841-461257c3d745833f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 02"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-5b575d02cd7bb458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 03"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-c35c60561e808a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 04"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-0ee2aa3c1c265b62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆叠上下文影响 z-index 05"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-868517d973ef2db3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="具体使用示例"></p>
<h1 id="最佳实践-amp-套路"><a href="#最佳实践-amp-套路" class="headerlink" title="最佳实践 &amp; 套路"></a>最佳实践 &amp; 套路</h1><p><code>z-index</code> 需要配合 <code>position: relative | absolute</code> 使用</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:53:08.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（二）-- height & width/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（二）-- height & width/">CSS 最佳实践 + 套路（二） -- height width</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>文档内元素的流动方向</p>
<ul>
<li>内联元素 ==&gt; 从左向右依次流动，若 <code>width</code> 不足，则换行</li>
<li>块级元素 ==&gt; 从上到下依次流动，每个块级元素独占一行</li>
</ul>
<h1 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h1><p>将会影响其祖先元素（块级元素）的 height </p>
<p>脱离文档流的三种方式：</p>
<ul>
<li><code>position: fixed</code> 相对于窗口定位</li>
<li><code>position: absolute</code> 相对于定位包含框定位（<code>position: absolute; top: 100%;</code>）</li>
<li><code>float:</code> 浮动，可以利用 <code>.clearfix</code> 类清除浮动</li>
</ul>
<h1 id="height-问题"><a href="#height-问题" class="headerlink" title="height 问题"></a>height 问题</h1><ul>
<li><code>div</code> （块级元素）==&gt; 由其内部文档流元素的 <code>height</code> 总和<strong>决定</strong>。</li>
<li><code>span</code> （内联元素） ==&gt; <code>span</code> 的 <code>height</code> 决定于具体的字体（<strong>建议行高</strong> + 设计字体的设计师决定）。</li>
</ul>
<h3 id="建议行高"><a href="#建议行高" class="headerlink" title="建议行高"></a>建议行高</h3><p>字体都有一个<strong>建议行高</strong>，每种字体的<strong>建议行高</strong>是不同的。以下面的 <code>span</code> 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style= &apos;font-family: 字体A; font-size: 20px; line-height: 40px;&apos;&gt;字体hug&lt;/span&gt;</span><br><span class="line">&lt;span style= &apos;font-family: 字体B; font-size: 20px; line-height: 40px;&apos;&gt;字体hug&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>两个 <code>span</code> 的字体不同，所以两个 <code>span</code> 的 <code>height</code> 就不相同。</li>
<li><code>font-size: 20px;</code> 指的是英文字母 <code>h</code> 的上部 <strong>距</strong> 英文字母 <code>g</code> 的下部的距离为 <code>20px</code> ，中文汉字会比 <code>20px</code> 偏小一些。</li>
</ul>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li><p>将 <code>line-height</code> 设置的比 <code>font-size</code> 大一些，那么行内元素的 <code>height</code> 将会等于 <code>line-height</code> 的值</p>
</li>
<li><p>内联元素设置 <code>width</code> 和 <code>height</code> 时，不要使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: block;</span><br><span class="line">height: </span><br><span class="line">line-height: </span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure>
<p> <strong>通过添加 <code>padding</code> 从而达到想要的 <code>width</code> 和 <code>height</code> （添加 <code>line-height</code> 明确 <code>height</code>），并且宽度（max-width）自适应</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding: </span><br><span class="line">line-height:</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><h3 id="设置一个-height-为-40px-（近似）的-div-其内部包含内敛元素-span-："><a href="#设置一个-height-为-40px-（近似）的-div-其内部包含内敛元素-span-：" class="headerlink" title="设置一个 height 为 40px （近似）的 div ,其内部包含内敛元素 span ："></a>设置一个 <code>height</code> 为 <code>40px</code> （近似）的 <code>div</code> ,其内部包含内敛元素 <code>span</code> ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style= &apos;line-height: 24px; border: 1px solid green; padding: 6px 0;&apos;&gt;</span><br><span class="line">    &lt;span style= &apos;font-size: 14px; border: 1px solid red;&apos;&gt;hug&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="两个-span-两端对齐方法"><a href="#两个-span-两端对齐方法" class="headerlink" title="两个 span 两端对齐方法"></a>两个 <code>span</code> 两端对齐方法</h3><p><code>text-align: justify</code> ==&gt; 定义行内内容（例如文字）如何相对它的块父    元素对齐。<code>text-align</code> 并不控制块元素自己的对齐，只控制它的行内内容    的对齐。<strong>文字向两侧对齐（必须是多行文本）</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">span&#123; </span><br><span class="line">  display: block;</span><br><span class="line">  width:            // 设置宽度，从而让两端对齐</span><br><span class="line">  line-height:    //设置行高和高度，固定下来</span><br><span class="line">  height: </span><br><span class="line">  taxt-align: justify;  //设置两端对齐 </span><br><span class="line">  overflow: hidden;  </span><br><span class="line">&#125;</span><br><span class="line">span::after&#123;   // 设置伪类，从而有第二行。</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>可以将 <code>span</code> 设置为 <code>display: inline-block</code> ，之后在第一个 <code>span</code> 后面加上 <code>&lt;br&gt;</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-6bb605df69f4cd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两端对齐"></p>
<h3 id="文字省略溢出"><a href="#文字省略溢出" class="headerlink" title="文字省略溢出"></a>文字省略溢出</h3><h5 id="单行文本省略溢出"><a href="#单行文本省略溢出" class="headerlink" title="单行文本省略溢出"></a>单行文本省略溢出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis</span><br></pre></td></tr></table></figure>
<h5 id="多行文本省略溢出（css-multi-line-text-ellipsis）"><a href="#多行文本省略溢出（css-multi-line-text-ellipsis）" class="headerlink" title="多行文本省略溢出（css multi line text ellipsis）"></a>多行文本省略溢出（css multi line text ellipsis）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">-webkit-line-clamp: 3; //控制行数</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure>
<h3 id="实现一个-1-1-的-div"><a href="#实现一个-1-1-的-div" class="headerlink" title="实现一个 1:1 的 div"></a>实现一个 1:1 的 div</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">padding-top: 100%;</span><br></pre></td></tr></table></figure>
<h3 id="margin-合并"><a href="#margin-合并" class="headerlink" title="margin 合并"></a><code>margin</code> 合并</h3><p>一个 <code>div</code> 标签中有一个子标签 <code>div</code> ，如果父标签有以下属性，则子标签中的 <code>margin</code>（上下） 属性不会合并。</p>
<ul>
<li>border：</li>
<li>padding: </li>
<li>overflow: hidden;( 不推荐 )</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p>文字和单词、单词和单词都是以<strong>基线</strong>对齐。</p>
</li>
<li><p>内联元素的 <code>padding</code> 、 <code>margin</code> 和 <code>border</code> 不会影响 <code>height</code> ，但是会影响 <code>width</code></p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-26T02:51:19.000Z"><a href="/2018/01/26/CSS-最佳实践-套路（一）-- 概述/">2018-01-26</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/26/CSS-最佳实践-套路（一）-- 概述/">CSS 最佳实践 + 套路（一） -- 概述</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ol>
<li>Google: 关键词 MDN</li>
<li><a href="https://css-tricks.com/" title="null" target="_blank" rel="noopener">CSS Tricks</a></li>
<li><a href="https://www.google.com/search?q=%E9%98%AE%E4%B8%80%E5%B3%B0+css" title="null" target="_blank" rel="noopener">Google: 阮一峰 css</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/category/css/page/25/" title="null" target="_blank" rel="noopener">张鑫旭的 240 多篇 CSS 博客</a></li>
<li><a href="https://tympanus.net/codrops/category/playground/" title="null" target="_blank" rel="noopener">Codrops 炫酷 CSS 效果</a></li>
<li><a href="http://www.ituring.com.cn/book/1695" title="null" target="_blank" rel="noopener">CSS揭秘</a></li>
<li><a href="http://cndevdocs.com/" title="null" target="_blank" rel="noopener">CSS 2.1 中文 spec</a></li>
<li><a href="http://adamschwartz.co/magic-of-css/" title="null" target="_blank" rel="noopener">Magic of CSS</a> 免费在线书<h1 id="引入CSS"><a href="#引入CSS" class="headerlink" title="引入CSS"></a>引入CSS</h1></li>
<li>内联样式 ==&gt; style属性 ==&gt; <code>style= &#39;color: red; width: 200px; height:200px;&#39;</code></li>
<li><p>内嵌样式 ==&gt; <code>style</code> 标签 ==&gt; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">    background: gray;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外联样式 ==&gt; <code>&lt;link&gt;</code> 标签 ==&gt; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel= &apos;stylesheet&apos; href= &apos;&apos;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@import url(./b/css)</code></p>
</li>
</ol>
<h1 id="最佳实践-amp-套路"><a href="#最佳实践-amp-套路" class="headerlink" title="最佳实践 &amp; 套路"></a>最佳实践 &amp; 套路</h1><h3 id="reset-CSS"><a href="#reset-CSS" class="headerlink" title="reset CSS"></a>reset CSS</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*&#123; margin: 0; padding: 0; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6, p&#123; margin: 0; padding: 0; &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>添加到浮动元素的父元素上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><p>元素分类：</p>
<ul>
<li>块级元素：<code>block</code> ==&gt; <code>display: block;</code></li>
<li>内联元素：<code>inline</code> ==&gt; <code>display: inline;</code></li>
<li>内联块级元素：<code>inline-block</code> ==&gt; <code>display: inline-block;</code></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/CSS/">CSS</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-22T14:13:10.000Z"><a href="/2018/01/22/JS进阶 -- MVC 思想/">2018-01-22</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/22/JS进阶 -- MVC 思想/">JS高级 -- MVC 思想</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MVC 是一种思想，它会让我们写代码时更加简洁、高效、模块化，了解这种方法对于前端程序员来说是很有必要的。首先说明下 MVC 代表的含义：</p>
<ul>
<li>M ==&gt; Model ==&gt; 模型</li>
<li>V ==&gt; View ==&gt; 视图</li>
<li>C ==&gt; Controller ==&gt; 控制器</li>
</ul>
<h1 id="MVC-各自作用"><a href="#MVC-各自作用" class="headerlink" title="MVC 各自作用"></a>MVC 各自作用</h1><p>MVC 主要是按功能划分模块</p>
<ol>
<li>view：js 代码所操纵的视图（HTML），负责显示给用户和通知 controller（控制器）</li>
<li><p>Model：view（视图）所需要的所有的数据操作,包括：</p>
<ul>
<li>初始化数据</li>
<li>读取数据</li>
<li><p>存入数据</p>
<p>负责和向 server（服务器）请求数据和响应 server（服务器） </p>
</li>
</ul>
</li>
<li><p>controller：所有的逻辑操作，负责监控和更新 view（视图） + 调用和接收 model（数据） </p>
</li>
</ol>
<h1 id="MVC-使用技术点"><a href="#MVC-使用技术点" class="headerlink" title="MVC 使用技术点"></a>MVC 使用技术点</h1><ol>
<li><p>立即执行函数，<a href="https://www.jianshu.com/p/e8ad9fdf8e07" target="_blank" rel="noopener">这里</a>有所有的立即执行函数的写法，但是这里推荐大家使用 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;&#125;.call()</span><br></pre></td></tr></table></figure>
<p> 立即执行函数避免了我们是用全局变量，隔离作用域，从而达到了使用局部变量的目的</p>
</li>
<li><p>闭包<br> 闭包就是如果一个函数使用了它范围外的值，那么这个函数 + 这个变量就叫做闭包<br> 闭包使得模块之间可以进行相互访问。具体实现：<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-10ee3cec1d8d6750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包 + 操作局部变量"></p>
<ul>
<li>函数 fn 中局部变量 obj 和 return 的函数构成了闭包</li>
<li>return 的函数便是接口，可以供外部调用，从而来操纵局部变量 obj</li>
<li><strong>外部除了使用函数 fn 的接口，没有任何其他方法可以访问到局部变量 obj</strong></li>
</ul>
</li>
<li><p>全局变量<br>模块与模块之间是在不同的 js 文件中，例如模块2想去操纵模块1的数据，通过上述方式显然是不够的，那么只能退而求其次，使用全局变量。具体实现：<br><img src="http://upload-images.jianshu.io/upload_images/9617841-9012bcc7bdc3e5fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全局变量"><br>通过使用全局变量保存了匿名函数的地址，从而全局都可以使用这个全局属性</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上3种技术点的结合 ==&gt; <strong>立即执行函数 + 闭包 + 全局变量</strong> 实现了 MVC 中 Controller（控制器） 的相应需求，从而让前端更好的使用 MVC 思想</p>
<h4 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h4><ol>
<li>this 的使用，在 MVC 中要着重使用 this </li>
<li>箭头函数，其实在 MVC 中使用箭头函数，主要就是为了 this ，原因在于<strong>箭头函数内外 this 不变</strong></li>
<li>HTML 中每一块都是一个 view ，当我们为 HTML 分块的时候，是可以嵌套的，所以我们的 view 也是可以嵌套的</li>
</ol>
<h1 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    let view = 操纵的 HTML 模块</span><br><span class="line">    let model = &#123;</span><br><span class="line">        init: function()&#123;&#125;,</span><br><span class="line">        fetch: function()&#123;&#125;  // 注意此处最好返回 Promise 对象</span><br><span class="line">        save: function()&#123;&#125;  // 注意此处最好返回 Promise 对象</span><br><span class="line">    &#125;</span><br><span class="line">    let controller = &#123;</span><br><span class="line">        view = null,</span><br><span class="line">        model = null,</span><br><span class="line">        ...... = null,</span><br><span class="line">        init: function()&#123;</span><br><span class="line">            this.view = view</span><br><span class="line">            this.model = model</span><br><span class="line">            ......</span><br><span class="line">            this.bindEvents()</span><br><span class="line">        &#125;,</span><br><span class="line">        bindEvents: function()&#123;</span><br><span class="line">            // 绑定事件，与绑定事件无关的放在 controller 属性上</span><br><span class="line">        &#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    controller.init( controller,model )</span><br><span class="line">    //controller.init.call( controller,view, model )</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p><a href="https://github.com/bowen-wu/resume/blob/master/js/leaveMessage-system-database.js" target="_blank" rel="noopener">代码示例</a></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T09:10:21.000Z"><a href="/2018/01/20/HTTP系列 -- AJAX 进阶/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- AJAX 进阶/">HTTP系列 -- AJAX 进阶</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/master/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">相关代码链接</a></p>
<h1 id="AJAX-设置响应-和-获取请求"><a href="#AJAX-设置响应-和-获取请求" class="headerlink" title="AJAX 设置响应 和 获取请求"></a>AJAX 设置响应 和 获取请求</h1><h3 id="AJAX-设置请求-header"><a href="#AJAX-设置请求-header" class="headerlink" title="AJAX 设置请求 header"></a>AJAX 设置请求 header</h3><p>第一部分：<code>request.open( &#39;POST&#39;, &#39;http://www.baidu.com/search&#39; )</code><br>第二部分：<code>request.setRequestHeader( hander, value )</code><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setRequestHeader( &apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos; )</span><br><span class="line">request.setRequestHeader( &apos;who&apos;, &apos;bowen&apos; )</span><br></pre></td></tr></table></figure></p>
<p>第四部分：<code>request.send( &#39;a=1&amp;b=2&#39; )</code></p>
<h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. POST /search HTTP/1.1</span><br><span class="line">2. Host: www.baidu.com</span><br><span class="line">   Content-Type: application/x-www-form-urlencoded</span><br><span class="line">   who: bowen</span><br><span class="line">   Content-Length: </span><br><span class="line">   Cookie: </span><br><span class="line">3. </span><br><span class="line">4. a=1&amp;b=2</span><br></pre></td></tr></table></figure>
<h3 id="AJAX-获取响应-header"><a href="#AJAX-获取响应-header" class="headerlink" title="AJAX 获取响应 header"></a>AJAX 获取响应 header</h3><p>第一部分：<code>request.status</code> 和 <code>request.statusText</code><br>第二部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.getResponseHeader( headerName ) </span><br><span class="line">request.getAllResponseHeaders()</span><br></pre></td></tr></table></figure></p>
<p>第四部分：<code>request.responseText</code></p>
<h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. HTTP/1.1 200 ok</span><br><span class="line">2. key: value</span><br><span class="line">3. </span><br><span class="line">4. 数据</span><br></pre></td></tr></table></figure>
<h3 id="Node-js（后端）设置响应-header"><a href="#Node-js（后端）设置响应-header" class="headerlink" title="Node.js（后端）设置响应 header"></a>Node.js（后端）设置响应 header</h3><p><a href="https://bowen-wu.github.io/2018/01/19/HTTP%E7%B3%BB%E5%88%97-Node-js/" target="_blank" rel="noopener">详解</a></p>
<h1 id="callback（回调）"><a href="#callback（回调）" class="headerlink" title="callback（回调）"></a>callback（回调）</h1><p>callback 就是一个回调函数，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-580ea1a7bb64c8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callback 示例"></p>
<ol>
<li>给 window 添加一个方法 fn123 ，这个方法接受一个对象 options 。</li>
<li>使用 window 下的方法 fn123 ，并传入一个对象，这个对象有一个方法 fn456 ，它是一个函数。</li>
<li>window 下的 fn123 接受到对象后将调用 fn456，将其 call back</li>
<li>fn456 中接受的 this 就是 window 下的方法中 call 时传的第一个参数，x 就是 call 时传的第二个参数</li>
</ol>
<h1 id="实现-jQuery-ajax"><a href="#实现-jQuery-ajax" class="headerlink" title="实现 jQuery.ajax"></a>实现 jQuery.ajax</h1><ol>
<li><p>首先回顾下 <a href="https://www.jianshu.com/p/3eb5f1c7937e" target="_blank" rel="noopener">window.jQuery</a></p>
</li>
<li><p>将 AJAX-基础 的<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/master/AJAX-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">代码</a> 进行封装，封装为 window.jQuery.ajax，<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/da549df5393a229f1d3e878d27b491755e6e99bb" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>将封装的 window.jQuery.ajax 进行代码优化（给参数命名）。由于传入参数过多，将其参数设置为有结构的数据 ==&gt; 对象，<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/80c6de9166b9efb60b2c34a5fb115aa9d0f61fcf" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>实现传入不定个参数的优化。既可以传入一个对象，也可以传入 url + 对象。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/3ca84506652fa89c4f3854da77420d7f6094e240" target="_blank" rel="noopener">代码地址</a>。此时由于要使用 arguments ，所以不能使用箭头函数。</p>
</li>
<li><p>优化代码，使用 ES6 解构赋值达到优化代码的目的，并增加 request.setRequestHeader() 功能。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/5118accb4c21f0ed2b8da6f2c5677867d238bf51" target="_blank" rel="noopener">代码地址</a>。</p>
</li>
<li><p>如果不实现传入不定个参数，还可以进一步使用 ES6 解构赋值优化。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/88436fc2378cec3a814a96cc3260a5de133038da/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>使用 Promise 规范进行优化，<code>return new Promise(function(resolve,reject){})</code>，成功 === 调用 resolve，失败 === 调用 reject，之后在调用时使用 <code>.then</code> 方法。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/1ea0e7728b98f008f077e7b7f77b2eb80ec77e6b/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>Promise 实现原理</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.Promise = function(fn)&#123;</span><br><span class="line">  // ......</span><br><span class="line">   return &#123;</span><br><span class="line">        then: function()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T09:01:25.000Z"><a href="/2018/01/20/HTTP系列 -- AJAX 基础/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- AJAX 基础/">HTTP系列 -- AJAX 基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/server-Node.js-demo/tree/master/AJAX-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">参考代码</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AJAX（Async JavaScript And XML）：异步 JavaScript 和XML，远程编程脚本，使 JavaScript 能够在 Web 服务器上运行的程序通信，它是一种无需重新加载整个网页的情况之下能够更新部分网页的技术。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>使用 XMLHttpRequest 发请求</li>
<li>服务器返回 XML / <strong>JSON</strong> 格式的<strong>字符串</strong></li>
<li>JS 解析 XML / <strong>JSON</strong>，并更新局部页面<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3>HTTP 的 path（路径）都是绝对路径</li>
</ol>
<h1 id="如何发送请求"><a href="#如何发送请求" class="headerlink" title="如何发送请求"></a>如何发送请求</h1><h3 id="form-表单"><a href="#form-表单" class="headerlink" title="form 表单"></a>form 表单</h3><p>使用 form 表单可以发请求，但是会刷新页面或新开页面<br>    <img src="http://upload-images.jianshu.io/upload_images/9617841-a4cd551b880d7edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-fa120004a4c5d9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送请求"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-9f0cfec4a4ad3a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送 GET 请求"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-13288ee474125f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送 POST 请求"></p>
<h3 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h3><p>使用 a 标签可以发 GET 请求，但是也会刷新页面或新开页面<br><img src="http://upload-images.jianshu.io/upload_images/9617841-f8081f7df640b734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-1b8aad5535592eed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 标签发送 GET 请求"></p>
<h3 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h3><p>使用 img 标签可以发 GET 请求，但是只能以图片的形式展示<br><img src="http://upload-images.jianshu.io/upload_images/9617841-419575e6ec290994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-78c17819094b4e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img 标签发送 GET 请求"></p>
<h3 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h3><p>使用 link 标签可以发 GET 请求，但是只能以 CSS、favicon 的形式展示<br><img src="http://upload-images.jianshu.io/upload_images/9617841-67c1f5fea5f0cd93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-396bbc64663e8d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link 标签发送 GET 请求"></p>
<h3 id="script-标签（JSONP）"><a href="#script-标签（JSONP）" class="headerlink" title="script 标签（JSONP）"></a>script 标签（JSONP）</h3><p>使用 script 标签可以发 GET 请求，但是只能以脚本的形式运行<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b11d2c9d39d32347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="script 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-16b27a15892f6486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="script 标签发送 GET 请求"></p>
<h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p><code>XMLHttpRequest</code> 是一个 API，它为客户端<strong>提供了在客户端和服务器之间传输数据的功能</strong>。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。<code>XMLHttpRequest</code> 在 <a href="https://developer.mozilla.org/zh-CN/docs/AJAX" target="_blank" rel="noopener">AJAX</a> 中被大量使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-15f0d81c590baedd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="挂载在 window 下的 XMLHttpRequest 对象"></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><ul>
<li>类型：function</li>
<li>JavaScript函数对象，当readyState属性改变时会调用它。</li>
</ul>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>类型：Number<br>显示 XMLHttpRequest  代理当前所处的状态，值：</p>
<ul>
<li>0 ==&gt; 代理被创建，但尚未调用 open() 方法</li>
<li>1 ==&gt; open() 方法已经被调用</li>
<li>2 ==&gt; send() 方法已经被调用，并且头部和状态已经可获得</li>
<li>3 ==&gt; 下载中，requestText 属性已经包含部分数据</li>
<li>4 ==&gt; 下载操作以完成</li>
</ul>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><ul>
<li>类型：String<br>响应的文本</li>
</ul>
<h5 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h5><p>设置响应类型，值：</p>
<ul>
<li>“” ==&gt; 字符串（默认值）</li>
<li>“arraybuffer”</li>
<li>“blob”</li>
<li>“document”</li>
<li>“json” ==&gt; JavaScript 对象，解析自服务器传递回来的JSON 字符串</li>
<li>“text” ==&gt; 字符串</li>
</ul>
<h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>请求的响应状态码<br><a href="https://www.jianshu.com/p/036df537e96d" target="_blank" rel="noopener">详见</a></p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p>请求的响应状态信息,包含一个状态码和原因短语（”200 OK”） </p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h5 id="1-open"><a href="#1-open" class="headerlink" title="1. open()"></a>1. open()</h5><p>初始化一个请求。该方法用于JavaScript代码中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open( method, url, async )</span><br></pre></td></tr></table></figure></p>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>methos ==&gt; 请求所使用的HTTP方法</li>
<li>url ==&gt; 该请求所要访问的 URL / 路径</li>
<li>async ==&gt; 默认为true（异步），表示是否执行异步操作</li>
</ul>
<h5 id="2-setRequestHeader"><a href="#2-setRequestHeader" class="headerlink" title="2. setRequestHeader()"></a>2. setRequestHeader()</h5><p>给指定的HTTP请求头赋值.在这之前,你必须确认已经调用 <code>open()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open( &apos;POST&apos;, &apos;/xxx&apos; )</span><br><span class="line">request.setRequestHeader( header, value )</span><br></pre></td></tr></table></figure></p>
<p><strong>request.setRequestHeader( ‘Content-type’ , ‘application/x-www-form=urlcoded’ )</strong></p>
<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><ul>
<li>header ==&gt; 将要被赋值的请求头名称</li>
<li>value ==&gt; 给指定的请求头赋的值</li>
</ul>
<h5 id="3-send"><a href="#3-send" class="headerlink" title="3. send()"></a>3. send()</h5><p>发送请求。如果该请求是异步模式(默认)，该方法会立刻返回。相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回</p>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h5><p>返回所有响应头信息(响应头名和值)，如果响应头还没接受,则返回null</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h5><p>返回指定的响应头的值，如果响应头还没被接受，或该响应头不存在，则返回null</p>
<h1 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h1><p><strong><code>JSON</code></strong>对象包含用于解析 JSON 的方法，并将值转换为 JSON。它不能被调用或者作为构造函数</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><p>解析一个JSON字符串，可选地转换生成的值及其属性，并返回值</p>
<h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p>返回与指定值相对应的一个JSON字符串，可选地仅包含某些属性或以用户定义的方式替换属性值</p>
<h1 id="原生-JavaScript-发送-AJAX-请求"><a href="#原生-JavaScript-发送-AJAX-请求" class="headerlink" title="原生 JavaScript 发送 AJAX 请求"></a>原生 JavaScript 发送 AJAX 请求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest()</span><br><span class="line">//open() 方法有第三个参数，true 为异步（默认），false为同步</span><br><span class="line">request.open( &apos;GET&apos;, &apos;路径&apos; )   // 配置 request </span><br><span class="line"></span><br><span class="line">//request.open( &apos;POST&apos;, &apos;路径&apos; )  </span><br><span class="line">// 配置 request ，如果是 POST 方法，必须设置 setRequestHeader</span><br><span class="line">//request.setRequestHeader( &apos;Content-type&apos; , &apos;application/x-www-form=urlcoded&apos; )</span><br><span class="line"></span><br><span class="line">request.send()</span><br><span class="line">request.onreadystatechange = () =&gt;&#123;</span><br><span class="line">    if( request.readyState === 4 )&#123; //请求响应都完毕了</span><br><span class="line">        if( request.status &gt;= 200 &amp;&amp; request.status &lt; 300 )&#123;</span><br><span class="line">            console.log( &apos;说明请求成功&apos; )</span><br><span class="line">            let string = request.responseText</span><br><span class="line">            // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class="line">            let object = window.JSON.parse( string )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><p>HTTP 第四部分永远是字符串，只不过是符合 JSON 对象语法的字符串（解析 JSON.parse()）</p>
</li>
<li><p>如何判断代码执行时长</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time()</span><br><span class="line">要判断的代码</span><br><span class="line">console.end()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断同步异步</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log( &apos;start&apos; )</span><br><span class="line">要判断的代码</span><br><span class="line">console.log( &apos;end&apos; )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON（JavaScript Object Notation）：JavaScript 对象表示法，它是存储和交换文本信息的语法，类似 XML，它采用键值对的方式来组织，易于人们阅读和编写，同时也易于机器解析和生成。<strong>它是一门新的语言</strong>。</p>
<h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p><a href="https://www.json.org/" target="_blank" rel="noopener">JSON 铁轨图</a><br>JSON 中有 String、null、Number、true、false、Array 和 Object</p>
<h3 id="JSON-和-JavaScript-的区别"><a href="#JSON-和-JavaScript-的区别" class="headerlink" title="JSON 和 JavaScript 的区别"></a>JSON 和 JavaScript 的区别</h3><p>JSON 和 JavaScript 是两门语言，JSON 是抄袭的 JavaScript，两者区别主要体现在：</p>
<ul>
<li>JSON 没有 undefined、function 和 Symbol</li>
<li>JSON 必须使用双引号</li>
<li>JSON 没有变量</li>
<li>JSON 中对象仅仅是一个哈希</li>
</ul>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>当一个资源从与该资源本身所在的服务器不同的域或端口<strong>发送 AJAX</strong> 请求一个资源时，资源会发起一个跨域 HTTP 请求，出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求</p>
</li>
<li><p>只有 AJAX 被限制，其他的都可以（img、form、link 和 script）</p>
</li>
<li><p>原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面的内容，所以浏览器认为这是安全的。而 AJAX 是可以读取相应内容的，因此浏览器将阻止你这样做</p>
</li>
<li><p>如果使用 AJAX 向其他源发送请求，会成功，但是报错（request.status === 0）</p>
</li>
<li><p>AJAX 请求已经发送出去了，却拿不到响应<br>request.status === 0</p>
</li>
<li><p>同源策略本质：一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容，但是浏览器并不阻止向另一个域名发送请求。<strong>只有协议、域名和端口一模一样才允许发送 AJAX 请求</strong></p>
</li>
</ul>
<h3 id="为什么要使用同源策略"><a href="#为什么要使用同源策略" class="headerlink" title="为什么要使用同源策略"></a>为什么要使用同源策略</h3><p><strong>安全</strong>，如果没有同源策略，AJAX 就可以向另一个域名发送 GET / POST 请求，GET 请求可以获取信息，POST 请求可以直接转账，那样互联网就没有隐私可言</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li><p>JSONP：但是 JSONP 有局限，不能发送 POST 请求</p>
</li>
<li><p>CORS（Cross-Orogin Resource Sharing 跨域资源共享）：请求的域名的<strong>后端</strong>需要在相应的接口添加<strong>响应头</strong>，此时就可以发送 POST 请求</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &quot;Access-Control-Allow-Origin&quot;, &quot;http://......&quot; )</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T08:56:11.000Z"><a href="/2018/01/20/HTTP系列 -- JSONP/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- JSONP/">HTTP系列 -- JSONP</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/server-Node.js-demo/tree/master/JSONP" target="_blank" rel="noopener">参考代码</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库是用来长久储存数据的。</p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h4 id="form-表单提交"><a href="#form-表单提交" class="headerlink" title="form 表单提交"></a><code>form</code> 表单提交</h4><p>缺点：刷新页面 + 用户后退 + 用户刷新 = 数据变动</p>
<h4 id="form-iframe-提交"><a href="#form-iframe-提交" class="headerlink" title="form + iframe 提交"></a><code>form</code> + <code>iframe</code> 提交</h4><p><code>form</code> 表单提交到 <code>iframe</code> 中，页面不会刷新。<br>缺点：用户刷新页面  ==&gt;  数据变动</p>
<h4 id="JS动态创建-img-标签"><a href="#JS动态创建-img-标签" class="headerlink" title="JS动态创建 img 标签"></a>JS动态创建 <code>img</code> 标签</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let img = document.createElement(&apos;img&apos;);</span><br><span class="line">img.src = &apos;路径&apos;</span><br><span class="line">img.onload = function()&#123;&#125;  ==&gt;  HTTP状态码</span><br><span class="line">img.onerror = function()&#123;&#125;  ==&gt;  HTTP状态码</span><br></pre></td></tr></table></figure>
</code></pre><p>通过路径，在 Nodejs 中设置成功或者失败，之后返回状态码，前端通过返回的HTTP状态码，进而来判断成功失败。</p>
<h4 id="动态创建-script-标签"><a href="#动态创建-script-标签" class="headerlink" title="动态创建 script 标签"></a>动态创建 <code>script</code> 标签</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.src = &apos;路径&apos;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">script.onload = function()&#123;&#125;</span><br><span class="line">script.onerror = function()&#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>通过设置响应头中的类型进而来确定返回内容的格式（第四部分），从而保证返回的是 JavaScript 代码。</li>
<li>当创建  <code>script</code> 标签插入 <code>body</code> 后，返回的内容会立即执行，之后再去执行 <code>onload</code> 和 <code>onerror</code> 事件，所以说  <code>onload</code> 可以进行删除， 之后将处理逻辑交给后端（处理逻辑中应该包括使用完 <code>script</code> 标签之后立刻删除），但是此时前后端耦合。</li>
<li><code>script</code> 的 <code>src</code> 属性可以访问其他地址</li>
</ul>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>动态创建 <code>script</code> 并调用前端传给后端的 callback 技术</p>
<h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h3><p>#####Nodejs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.write(` callback.call(undefined,&apos; success &apos;) `);</span><br></pre></td></tr></table></figure></p>
<h5 id="JS"><a href="#JS" class="headerlink" title="JS:"></a>JS:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.callback = function()&#123;&#125;  //返回之后进行处理</span><br><span class="line">script.src = http://....../路径?callback = xxx</span><br></pre></td></tr></table></figure>
<h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><h5 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.write(` $&#123; query.callback &#125;.call(undefined,&#123;</span><br><span class="line">    &quot;success&quot;: true,</span><br><span class="line">    &quot;left&quot;: $&#123; newAmount &#125;</span><br><span class="line">&#125;) `)</span><br></pre></td></tr></table></figure>
<p>返回的数据是 JSON 数据<br><strong>特点：</strong></p>
<ul>
<li>请求方创建 <code>script</code> ，<code>src</code> 属性指向响应方</li>
<li>响应方根据查询参数，构造形如 xxx.call(undefined,”传给前端的数据”) 这样的响应。</li>
</ul>
<h1 id="JSONP-1"><a href="#JSONP-1" class="headerlink" title="JSONP"></a>JSONP</h1><h3 id="什么是-JSONP"><a href="#什么是-JSONP" class="headerlink" title="什么是 JSONP"></a>什么是 JSONP</h3><p>请求方：前端（浏览器）<br>响应方：后端（服务器）</p>
<ol>
<li>请求方创建 <code>script</code> ，<code>src</code> 指向响应方，同时传入一个查询参数 ?callback = 随机数</li>
<li>响应方根据查询参数 callback ，构造形如 <code>随机数.call(undefined,&quot;传给前端的数据&quot;)</code> 这样的响应</li>
<li>浏览器接收到响应，就会执行 <code>随机数.call(undefined,&quot;传给前端的数据&quot;)</code> </li>
<li>请求方获取到数据<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h5 id="JS-1"><a href="#JS-1" class="headerlink" title="JS"></a>JS</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">button.addEventlistener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;);</span><br><span class="line">    let functionName = &apos;bowen&apos; + parseInt(Math.random()*100000,10);</span><br><span class="line">    window[ functionName ] = function(result)&#123;</span><br><span class="line">        if( result === &apos;success&apos; )&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = &apos;http://....../路径?callback = &apos; + functionName</span><br><span class="line">    document.body.appendChild( script );</span><br><span class="line">    script.onload = function(event)&#123;</span><br><span class="line">        event.currentTarget.remove();</span><br><span class="line">        delete window[ functionName ]</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = function()&#123;</span><br><span class="line">        alert(&apos;fail&apos;);</span><br><span class="line">        event.currentTarget.remove();</span><br><span class="line">        delete window[ functionName ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="jQ"><a href="#jQ" class="headerlink" title="jQ:"></a>jQ:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;,(event) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &apos;http://....../路径&apos;，</span><br><span class="line">        dataType: &apos;jsonp&apos;,</span><br><span class="line">        success: function( response )&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="套路：为什么-JSONP-不支持-POST-请求"><a href="#套路：为什么-JSONP-不支持-POST-请求" class="headerlink" title="套路：为什么 JSONP 不支持 POST 请求"></a>套路：为什么 JSONP 不支持 POST 请求</h3><p>JSONP 是动态创建 <code>script</code> 标签 + 传入 callback 查询参数，<code>script</code> 标签，只能发送 GET 请求，不能使用 POST。</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><p>如果后端没有写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.write(` $&#123; query.callback &#125;.call(undefined,&#123;</span><br><span class="line">    &quot;success&quot;: true,</span><br><span class="line">    &quot;left&quot;: $&#123; newAmount &#125;</span><br><span class="line">&#125;) `)</span><br></pre></td></tr></table></figure></p>
<p>前端虽然有响应内容，但是使用不到</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-19T00:01:38.000Z"><a href="/2018/01/19/HTTP系列 -- Node.js/">2018-01-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/19/HTTP系列 -- Node.js/">HTTP系列 -- Node.js</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/blob/master/server.js" target="_blank" rel="noopener">Node.js 服务器代码</a></p>
<h1 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let string = fs.readFileSync( &apos;路径&apos;, &apos;UTF-8&apos; )</span><br><span class="line">response.setHeader( &apos;Content-Type&apos;, &apos;类型&apos; )</span><br><span class="line">response.statusCode = 200</span><br><span class="line">response.write()</span><br><span class="line">response.end()</span><br></pre></td></tr></table></figure>
<h3 id="response-setHeader-‘Content-Type’-‘类型’"><a href="#response-setHeader-‘Content-Type’-‘类型’" class="headerlink" title="response.setHeader( ‘Content-Type’, ‘类型’ )"></a>response.setHeader( ‘Content-Type’, ‘类型’ )</h3><p>类型：</p>
<ul>
<li>HTML ==&gt; response.setHeader( ‘Content-Type’, ‘text/html; charset = utf-8’ )</li>
<li>CSS ==&gt; response.setHeader( ‘Content-Type’, ‘text/css’ )</li>
<li>JavaScript ==&gt; response.setHeader( ‘Content-Type’, ‘application/javascript’ )</li>
</ul>
<h1 id="创建-Node-js-服务器"><a href="#创建-Node-js-服务器" class="headerlink" title="创建 Node.js 服务器"></a>创建 Node.js 服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)</span><br><span class="line">var port = process.argv[2]</span><br><span class="line"></span><br><span class="line">if(!port)&#123;</span><br><span class="line">  console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;)</span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(request, response)&#123;</span><br><span class="line">  var parsedUrl = url.parse(request.url, true)</span><br><span class="line">  var path = request.url </span><br><span class="line">  var query = &apos;&apos;</span><br><span class="line">  if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125;</span><br><span class="line">  var pathNoQuery = parsedUrl.pathname</span><br><span class="line">  var queryObject = parsedUrl.query</span><br><span class="line">  var method = request.method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(&apos;HTTP 路径为\n&apos; + path)</span><br><span class="line">  if(path == &apos;/style&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/script&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/index&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)</span><br></pre></td></tr></table></figure>
<h1 id="解析-Node-js-服务器"><a href="#解析-Node-js-服务器" class="headerlink" title="解析 Node.js 服务器"></a>解析 Node.js 服务器</h1><ol>
<li><p><code>console.log(&#39;HTTP 路径为\n&#39; + path)</code> 表示在命令行中或者<code>Console</code>面板中打印出当前请求的 HTTP 路径</p>
</li>
<li><p>下方代码表示如果请求路径为<code>/style</code>，设置响应头信息为<code>&#39;Content-Type&#39;, &#39;text/css; charset=utf-8&#39;</code>（即响应内容 [ 第四部分 ] 的类型 [ css ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 <code>body{background-color: #ddd;}h1{color: red;}</code> ，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/style&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求路径为 <code>/script</code> ，设置响应头信息为 <code>&#39;Content-Type&#39;, &#39;text/javascript; charset=utf-8&#39;</code> （即响应内容 [ 第四部分 ] 的类型 [ javascript ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 <code>alert(&quot;这是JS执行的&quot;)</code>，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/script&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求路径为 <code>/index</code> ，设置响应头信息为 <code>(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;</code> （即响应内容 [ 第四部分 ] 的类型 [ html ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 HTML 页面，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/index&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求的路径不是上述路径，则返回状态码为 <code>404</code> ，之后完成响应。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h1><ol>
<li><p>新建目录和进入</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir node-demo</span><br><span class="line">cd node-demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件并编辑</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch server.js</span><br><span class="line">start server.js //内容如上</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js 端口号</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#使用 Node.js 发起请求</p>
<ol>
<li><p>在新的 Bash 窗口运行 <code>curl http://localhost:你的指定的端口/xxx</code> 或者 <code>curl http://127.0.0.1:你指定的端口/xxx</code>即可发起请求</p>
</li>
<li><p>在浏览器窗口地址栏中输入 <code>http://localhost:你的指定的端口/xxx</code> 或者 <code>http://127.0.0.1:你指定的端口/xxx</code> 回车，即可发起请求。</p>
</li>
<li><p><code>curl -s -v -- &quot;http://localhost:port/xxx&quot;</code>可以查看完整的请求体和响应体。</p>
</li>
</ol>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><ul>
<li><p>在运行 <code>node server.js 端口号</code> Bash 窗口中可以查看到打印出来的路径（<code>console.log(&#39;HTTP 路径为\n&#39; + path)</code>），并且在发起请求的 Bash 窗口中可以查看请求体和响应体</p>
</li>
<li><p>在浏览器窗口中可以看到实际运行效果</p>
</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p>任意一台电脑都是服务器</p>
</li>
<li><p>创建的<em>Node.js服务器</em>提供 HTTP 服务，所以需要提供 HTTP 服务的程序</p>
</li>
<li><p>用脚本可以提供 HTTP 服务</p>
</li>
</ol>
<h1 id="当在浏览器地址栏输入地址回车后发生的事情"><a href="#当在浏览器地址栏输入地址回车后发生的事情" class="headerlink" title="当在浏览器地址栏输入地址回车后发生的事情"></a>当在浏览器地址栏输入地址回车后发生的事情</h1><ol>
<li><p>DNS 域名解析。首先浏览器会查找缓存，如果没有，就向运营商查找，运营商会提供 DNS 服务，从而得到域名所对应的 IP 地址。DNS 域名解析就是一个域名到 IP 地址的转换</p>
</li>
<li><p>TCP 连接。浏览器根据 IP 地址向服务器发起 TCP 连接，与服务器建立 TCP 三次握手，浏览器对服务器说：“您好，我可以链接你么？”，服务器对浏览器说：“您好，你可以连接我”，浏览器对服务器说：“好的，那我连接你了！”，通过 TCP 的三次握手，从而确定双方都有收发文件的能力，自此浏览器和服务器建立了链接</p>
</li>
<li><p>浏览器发送 HTTP 请求。请求包括了请求行、请求头和请求正文</p>
</li>
<li><p>浏览器拿到响应、解析并渲染页面。浏览器是一个边解析边渲染的过程，首先浏览器解析HTML文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上</p>
</li>
<li><p>通过四次挥手关闭 TCP 连接。浏览器对服务器说：“不早了，我该走了”，服务器对浏览器说：“知道了”，之后服务器又对浏览器说：“我也该走了”，浏览器回应服务器：“好的”，至此 TCP 连接结束</p>
</li>
</ol>
<p><strong>注意</strong>：后缀是没有用的。HTTP 路径不是文件路径。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-18T23:59:03.000Z"><a href="/2018/01/19/HTTP系列 -- 网络与 IP /">2018-01-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/19/HTTP系列 -- 网络与 IP /">HTTP系列 -- 网络 与 IP</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP协议的底层是由 <strong>TCP 协议</strong>和 <strong>IP 协议</strong>（简称<strong>TCP/IP</strong>）构建的。HTTP只规定了请求格式和相应格式，即如何书写内容的协议。</p>
<h1 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h1><p>TCP 是传输控制协议，它规定了如何传输协议。</p>
<h3 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h3><ul>
<li>TCP 可靠、面向连接、相对 UDP 较慢</li>
<li>UDP 不可靠，不面向连接、相对 TCP 较快。</li>
</ul>
<h3 id="TCP-的三次握手指的是什么"><a href="#TCP-的三次握手指的是什么" class="headerlink" title="TCP 的三次握手指的是什么"></a>TCP 的三次握手指的是什么</h3><p>每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端：我要连接你了，可以吗</span><br><span class="line">2. 服务端：嗯，我准备好了，连接我吧</span><br><span class="line">3. 客户端：那我连接你咯。</span><br><span class="line">4. 开始后面步骤</span><br></pre></td></tr></table></figure></p>
<p>通过上述对话，从而确定了双方都可以收发内容。</p>
<h1 id="IP（Internet-Protocol）"><a href="#IP（Internet-Protocol）" class="headerlink" title="IP（Internet Protocol）"></a>IP（Internet Protocol）</h1><p>IP 是网络协议，它规定了如何联网协议。</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ol>
<li><p>只要在互联网中，那么就会有一个 IP。IP 分为<strong>内网 IP</strong> 和<strong>外网 IP</strong>。</p>
</li>
<li><p>内网：以路由器为核心的以及所有连接路由器的设备统称为内网</p>
</li>
<li><p>外网：以路由器为出口的外面的网络都是外网</p>
</li>
<li><p>服务商提供 DNS 服务（告知你你想要请求的域名所对应的 IP<br>地址）</p>
</li>
<li><p>路由器可以广播出来 WIFI ，连接之后便可以上网</p>
</li>
<li><p>路由器连接服务商的服务器，那么路由器就会有一个<strong>外网IP</strong>，表示用户在<strong>互联网</strong>中的地址</p>
</li>
<li><p>如果重启路由器，则有可能会重新分配<strong>外网IP</strong>，所以<strong>路由器没有固定的外网IP</strong></p>
</li>
<li><p>可以租用<strong>固定的外网IP</strong>，从而为用户提供稳定的服务（eg. 阿里、腾讯等公司）</p>
</li>
<li><p>内网中的设备使用<strong>内网IP</strong>，一般来说这个 IP 的格式都是<strong>192.168.xxx.xxx</strong></p>
</li>
<li><p>一般路由会给自己分配一个好记的<strong>内网 IP</strong>，如<em>192.168.1.1</em>。之后给每个设备分配不同的<strong>内网IP</strong></p>
</li>
<li><p>路由器会有两个IP，分别是<strong>内网IP</strong>和<strong>外网IP</strong></p>
</li>
<li><p>内网中的设备可以互相访问（比如你可以用电脑或手机进入<a href="http://192.168.1.1/" title="null" target="_blank" rel="noopener">http://192.168.1.1</a>来查看你的路由器<strong>「因为路由器内置一个HTTP服务器」</strong>），但是不能<strong>直接</strong>访问外网，内网设备想要访问外网，就必须经过路由器中转</p>
</li>
<li><p>外网中的设备可以互相访问（比如 qq.com 可以把首页发送给你的路由器，你的路由器有<strong>外网 IP</strong>），但是外网中的设备无法访问你的内网设备（这很好理解，内网是一个封闭的网络，外人进不来，所以实际上 qq.com 无法直接把首页放送给你的电脑和手机）</p>
</li>
<li><p>路，就是「必由之路」中的路。由，就是「必由之路」中的由（由是经过、缘由的意思）。所有的信息都要经过路由器，然后被指向一条它该去的路</p>
</li>
<li><p><strong>内网</strong>和<strong>外网</strong>通过<strong>路由器</strong>连接</p>
</li>
<li><p><strong>本地IP：127.0.0.1</strong>：表示设备本身</p>
</li>
<li><p>hosts：可以设置任意域名对应的IP</p>
</li>
<li><p>hosts文件中会有一行<code>127.0.0.1 localhost</code>，意思就是 <strong>localhost</strong> 指向 <strong>127.0.0.1</strong>，所以 <strong>localhost</strong> 也表示设备本身</p>
</li>
<li><p>特别特殊的 IP：<code>0.0.0.0</code>，它不表示任何设备。这个 IP 不同的地方含义不同</p>
</li>
<li><p>使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可。如果没有提供，浏览器会加上默认端口号80。</p>
</li>
</ol>
<h1 id="端口（port）"><a href="#端口（port）" class="headerlink" title="端口（port）"></a>端口（port）</h1><p>端口其实就是一个编号。一个服务器（硬件）不一定只提供一种服务，比如一个服务器既提供 HTTP 服务（网页服务），又提供 FTP 服务（文件下载服务），还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务，所以<strong>一个端口对应一个服务</strong>，是固定的。</p>
<h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><ol>
<li><p>提供 <strong>HTTP 服务</strong> ==&gt; <strong>80 端口</strong></p>
</li>
<li><p>提供 <strong>HTTPS 服务</strong> ==&gt; <strong>443 端口</strong></p>
</li>
<li><p>提供 <strong>FTP 服务</strong> ==&gt; <strong>21 端口</strong></p>
</li>
<li><p>提供<strong>代理服务器端口</strong> ==&gt; <strong>1080端口</strong></p>
</li>
</ol>
<h3 id="端口基础"><a href="#端口基础" class="headerlink" title="端口基础"></a>端口基础</h3><p>每个机器一共有 65535（2的16次方减1）个端口（这是协议规定的）。不过这些端口的使用有一些规定</p>
<ol>
<li><p>0 到 1023（2的10次方减1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口</p>
</li>
<li><p>其他端口可以给普通用户使用</p>
</li>
<li><p>如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。以后你们会经常遇到这个问题</p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-15T10:27:13.000Z"><a href="/2018/01/15/HTTP系列 -- 请求与响应/">2018-01-15</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/15/HTTP系列 -- 请求与响应/">HTTP系列 -- 请求与响应</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li><p><strong>Server（服务器）</strong>：服务器作为硬件来说，通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机</p>
</li>
<li><p><strong>Client（客户端）</strong>：是指与服务器相对应，为客户提供本地服务的程序</p>
</li>
</ol>
<h1 id="浏览器-服务器-HTTP-三者关系"><a href="#浏览器-服务器-HTTP-三者关系" class="headerlink" title="浏览器 + 服务器 + HTTP 三者关系"></a>浏览器 + 服务器 + HTTP 三者关系</h1><ul>
<li>浏览器负责发起请求</li>
<li>服务器在<strong>80端口</strong>接收请求</li>
<li>服务器负责返回内容（响应）</li>
<li>浏览器负责下载响应内容</li>
</ul>
<p><strong>HTTP 的作用就是指导浏览器和服务器如何进行沟通。</strong></p>
<h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><h3 id="请求头（Request-Headers）格式"><a href="#请求头（Request-Headers）格式" class="headerlink" title="请求头（Request Headers）格式"></a>请求头（Request Headers）格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.请求类型 路径 协议/版本 // 请求行</span><br><span class="line">2.key: value  // 请求头</span><br><span class="line">3.</span><br><span class="line">4.要上传的数据  // 其他消息体</span><br></pre></td></tr></table></figure>
<h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><ol>
<li><p>GET ==&gt; 用于获取数据。</p>
</li>
<li><p>POST ==&gt; 用于提交数据，请求服务器进行处理。</p>
</li>
<li><p>PUT ==&gt; 向指定资源位置上传其最新内容（所有内容都更新）。</p>
</li>
<li><p>PATCH ==&gt; 用于将局部修改应用到资源。</p>
</li>
<li><p>DELETE ==&gt; 请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>HEAD ==&gt; 向服务器发出指定资源的请求，但服务器将不传回资源的本文部分。</p>
</li>
<li><p>OPTIONS ==&gt; 使服务器传回该资源所支持的所有HTTP请求方法，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
</ol>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>必须以 <code>/</code> 开头，如果不设置，默认为 <code>/</code> ，路径包括<strong>查询参数</strong>，但是不包括<strong>锚点</strong></p>
<h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><p>版本大部分都是 <code>HTTP/1.1</code>，还有<code>HTTP/2</code>.</p>
<h3 id="请求头（key-value）："><a href="#请求头（key-value）：" class="headerlink" title="请求头（key: value）："></a>请求头（key: value）：</h3><p>请求头定义一些操作参数。其中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host: www.baidu.com  // 域名</span><br><span class="line">User-Agent:      // 用的什么软件发起的请求</span><br><span class="line">Content-Type: application/x-www-form-urlcoded    //标识了第4部分的格式，POST 请求</span><br><span class="line">Content-Length: </span><br><span class="line">Cookie:</span><br></pre></td></tr></table></figure></p>
<h3 id="第3部分："><a href="#第3部分：" class="headerlink" title="第3部分："></a>第3部分：</h3><p>是一个空行（回车）。</p>
<h3 id="第4部分："><a href="#第4部分：" class="headerlink" title="第4部分："></a>第4部分：</h3><p>上传的数据，可以没有 </p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>https 协议 ==&gt; 所有数据在网络上请求和传输的时候都是加密的</li>
<li>http 协议  ==&gt; 所有数据在网络上请求和传输的时候都是明文的</li>
</ul>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><h3 id="响应头（Response-Headers）格式"><a href="#响应头（Response-Headers）格式" class="headerlink" title="响应头（Response Headers）格式"></a>响应头（Response Headers）格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.协议/版本 状态码 状态解释</span><br><span class="line">2.key: value  </span><br><span class="line">3.</span><br><span class="line">4.要下载的数据</span><br></pre></td></tr></table></figure>
<h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><p>表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<ul>
<li><p>2xx成功 ==&gt; 代表请求已成功被服务器接收、理解、并接受。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回（GET）。</span><br><span class="line">b.204 No Content 服务器成功处理了请求，没有返回任何内容（创建成功 ==&gt; POST）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>3xx重定向 ==&gt; 类状态码代表需要客户端采取进一步的操作才能完成请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.301 Move Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。</span><br><span class="line">b.302 Found 要求客户端执行临时重定向。</span><br><span class="line">c.304 Not Modified 表示资源未被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</span><br></pre></td></tr></table></figure>
</li>
<li><p>4xx客户端错误 ==&gt; 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.403 Forbidden 客户端错误，服务器已经理解请求，但是拒绝执行  它。</span><br><span class="line">b.404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发    现，但允许用户的后续请求。</span><br></pre></td></tr></table></figure>
</li>
<li><p>5xx服务器错误 ==&gt; 表示服务器无法完成明显有效的请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.500 Internal Server Error 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</span><br><span class="line">b.502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HTML-与-HTTP"><a href="#HTML-与-HTTP" class="headerlink" title="HTML 与 HTTP"></a>HTML 与 HTTP</h1><p>所有 App 都会内置一个浏览器（WebView）用来展示 HTML，而 HTML 都是通过 HTTP 下载的，而如果你要使用 HTTP 一般都会用到 URL。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  

  <nav id="pagination">
  
    <a href="/archives/page/2/" class="alignleft prev">Vorherige Seite</a>
  
  
    <a href="/archives/page/4/" class="alignright next">Nächste Seite</a>
  
  <div class="clearfix"></div>
</nav>


</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>2</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>1</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>6</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>2</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
