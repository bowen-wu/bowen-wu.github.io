<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Seite 3 | Archiv: 2018/1 | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/archives/2018/01/page/3/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2018/1</h2>
<p></p>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-19T00:01:38.000Z"><a href="/2018/01/19/HTTP系列 -- Node.js/">2018-01-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/19/HTTP系列 -- Node.js/">HTTP系列 -- Node.js</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/blob/master/server.js" target="_blank" rel="noopener">Node.js 服务器代码</a></p>
<h1 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let string = fs.readFileSync( &apos;路径&apos;, &apos;UTF-8&apos; )</span><br><span class="line">response.setHeader( &apos;Content-Type&apos;, &apos;类型&apos; )</span><br><span class="line">response.statusCode = 200</span><br><span class="line">response.write()</span><br><span class="line">response.end()</span><br></pre></td></tr></table></figure>
<h3 id="response-setHeader-‘Content-Type’-‘类型’"><a href="#response-setHeader-‘Content-Type’-‘类型’" class="headerlink" title="response.setHeader( ‘Content-Type’, ‘类型’ )"></a>response.setHeader( ‘Content-Type’, ‘类型’ )</h3><p>类型：</p>
<ul>
<li>HTML ==&gt; <code>response.setHeader( &#39;Content-Type, &#39;text/html; charset = utf-8&#39; )</code></li>
<li>CSS ==&gt; <code>response.setHeader( &#39;Content-Type&#39;, &#39;text/css&#39; )</code></li>
<li>JavaScript ==&gt; <code>response.setHeader( &#39;Content-Type&#39;, &#39;application/javascript&#39; )</code></li>
</ul>
<h1 id="创建-Node-js-服务器"><a href="#创建-Node-js-服务器" class="headerlink" title="创建 Node.js 服务器"></a>创建 Node.js 服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)</span><br><span class="line">var port = process.argv[2]</span><br><span class="line"></span><br><span class="line">if(!port)&#123;</span><br><span class="line">  console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;)</span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(request, response)&#123;</span><br><span class="line">  var parsedUrl = url.parse(request.url, true)</span><br><span class="line">  var path = request.url </span><br><span class="line">  var query = &apos;&apos;</span><br><span class="line">  if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125;</span><br><span class="line">  var pathNoQuery = parsedUrl.pathname</span><br><span class="line">  var queryObject = parsedUrl.query</span><br><span class="line">  var method = request.method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(&apos;HTTP 路径为\n&apos; + path)</span><br><span class="line">  if(path == &apos;/style&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/script&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/index&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)</span><br></pre></td></tr></table></figure>
<h1 id="解析-Node-js-服务器"><a href="#解析-Node-js-服务器" class="headerlink" title="解析 Node.js 服务器"></a>解析 Node.js 服务器</h1><ol>
<li><p><code>console.log(&#39;HTTP 路径为\n&#39; + path)</code> 表示在命令行中或者<code>Console</code>面板中打印出当前请求的 HTTP 路径</p>
</li>
<li><p>下方代码表示如果请求路径为<code>/style</code>，设置响应头信息为<code>&#39;Content-Type&#39;, &#39;text/css; charset=utf-8&#39;</code>（即响应内容 [ 第四部分 ] 的类型 [ css ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 <code>body{background-color: #ddd;}h1{color: red;}</code> ，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/style&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求路径为 <code>/script</code> ，设置响应头信息为 <code>&#39;Content-Type&#39;, &#39;text/javascript; charset=utf-8&#39;</code> （即响应内容 [ 第四部分 ] 的类型 [ javascript ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 <code>alert(&quot;这是JS执行的&quot;)</code>，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/script&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求路径为 <code>/index</code> ，设置响应头信息为 <code>(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;</code> （即响应内容 [ 第四部分 ] 的类型 [ html ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 HTML 页面，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/index&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求的路径不是上述路径，则返回状态码为 <code>404</code> ，之后完成响应。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h1><ol>
<li><p>新建目录和进入</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir node-demo</span><br><span class="line">cd node-demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件并编辑</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch server.js</span><br><span class="line">start server.js //内容如上</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js 端口号</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用-Node-js-发起请求"><a href="#使用-Node-js-发起请求" class="headerlink" title="使用 Node.js 发起请求"></a>使用 Node.js 发起请求</h1><ol>
<li><p>在新的 Bash 窗口运行 <code>curl http://localhost:你的指定的端口/xxx</code> 或者 <code>curl http://127.0.0.1:你指定的端口/xxx</code>即可发起请求</p>
</li>
<li><p>在浏览器窗口地址栏中输入 <code>http://localhost:你的指定的端口/xxx</code> 或者 <code>http://127.0.0.1:你指定的端口/xxx</code> 回车，即可发起请求。</p>
</li>
<li><p><code>curl -s -v -- &quot;http://localhost:port/xxx&quot;</code>可以查看完整的请求体和响应体。</p>
</li>
</ol>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><ul>
<li><p>在运行 <code>node server.js 端口号</code> Bash 窗口中可以查看到打印出来的路径（<code>console.log(&#39;HTTP 路径为\n&#39; + path)</code>），并且在发起请求的 Bash 窗口中可以查看请求体和响应体</p>
</li>
<li><p>在浏览器窗口中可以看到实际运行效果</p>
</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p>任意一台电脑都是服务器</p>
</li>
<li><p>创建的<em>Node.js服务器</em>提供 HTTP 服务，所以需要提供 HTTP 服务的程序</p>
</li>
<li><p>用脚本可以提供 HTTP 服务</p>
</li>
</ol>
<h1 id="当在浏览器地址栏输入地址回车后发生的事情"><a href="#当在浏览器地址栏输入地址回车后发生的事情" class="headerlink" title="当在浏览器地址栏输入地址回车后发生的事情"></a>当在浏览器地址栏输入地址回车后发生的事情</h1><ol>
<li><p>DNS 域名解析。首先浏览器会查找缓存，如果没有，就向运营商查找，运营商会提供 DNS 服务，从而得到域名所对应的 IP 地址。DNS 域名解析就是一个域名到 IP 地址的转换</p>
</li>
<li><p>TCP 连接。浏览器根据 IP 地址向服务器发起 TCP 连接，与服务器建立 TCP 三次握手，浏览器对服务器说：“您好，我可以链接你么？”，服务器对浏览器说：“您好，你可以连接我”，浏览器对服务器说：“好的，那我连接你了！”，通过 TCP 的三次握手，从而确定双方都有收发文件的能力，自此浏览器和服务器建立了链接</p>
</li>
<li><p>浏览器发送 HTTP 请求。请求包括了请求行、请求头和请求正文</p>
</li>
<li><p>浏览器拿到响应、解析并渲染页面。浏览器是一个边解析边渲染的过程，首先浏览器解析HTML文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上</p>
</li>
<li><p>通过四次挥手关闭 TCP 连接。浏览器对服务器说：“不早了，我该走了”，服务器对浏览器说：“知道了”，之后服务器又对浏览器说：“我也该走了”，浏览器回应服务器：“好的”，至此 TCP 连接结束</p>
</li>
</ol>
<p><strong>注意</strong>：后缀是没有用的。HTTP 路径不是文件路径。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-18T23:59:03.000Z"><a href="/2018/01/19/HTTP系列 -- 网络与 IP /">2018-01-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/19/HTTP系列 -- 网络与 IP /">HTTP系列 -- 网络 与 IP</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP协议的底层是由 <strong>TCP 协议</strong>和 <strong>IP 协议</strong>（简称<strong>TCP/IP</strong>）构建的。HTTP只规定了请求格式和相应格式，即如何书写内容的协议。</p>
<h1 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h1><p>TCP 是传输控制协议，它规定了如何传输协议。</p>
<h3 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h3><ul>
<li>TCP 可靠、面向连接、相对 UDP 较慢</li>
<li>UDP 不可靠，不面向连接、相对 TCP 较快。</li>
</ul>
<h3 id="TCP-的三次握手指的是什么"><a href="#TCP-的三次握手指的是什么" class="headerlink" title="TCP 的三次握手指的是什么"></a>TCP 的三次握手指的是什么</h3><p>每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端：我要连接你了，可以吗</span><br><span class="line">2. 服务端：嗯，我准备好了，连接我吧</span><br><span class="line">3. 客户端：那我连接你咯。</span><br><span class="line">4. 开始后面步骤</span><br></pre></td></tr></table></figure></p>
<p>通过上述对话，从而确定了双方都可以收发内容。</p>
<h1 id="IP（Internet-Protocol）"><a href="#IP（Internet-Protocol）" class="headerlink" title="IP（Internet Protocol）"></a>IP（Internet Protocol）</h1><p>IP 是网络协议，它规定了如何联网协议。</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ol>
<li><p>只要在互联网中，那么就会有一个 IP。IP 分为<strong>内网 IP</strong> 和<strong>外网 IP</strong>。</p>
</li>
<li><p>内网：以路由器为核心的以及所有连接路由器的设备统称为内网</p>
</li>
<li><p>外网：以路由器为出口的外面的网络都是外网</p>
</li>
<li><p>服务商提供 DNS 服务（告知你你想要请求的域名所对应的 IP<br>地址）</p>
</li>
<li><p>路由器可以广播出来 WIFI ，连接之后便可以上网</p>
</li>
<li><p>路由器连接服务商的服务器，那么路由器就会有一个<strong>外网IP</strong>，表示用户在<strong>互联网</strong>中的地址</p>
</li>
<li><p>如果重启路由器，则有可能会重新分配<strong>外网IP</strong>，所以<strong>路由器没有固定的外网IP</strong></p>
</li>
<li><p>可以租用<strong>固定的外网IP</strong>，从而为用户提供稳定的服务（eg. 阿里、腾讯等公司）</p>
</li>
<li><p>内网中的设备使用<strong>内网IP</strong>，一般来说这个 IP 的格式都是<strong>192.168.xxx.xxx</strong></p>
</li>
<li><p>一般路由会给自己分配一个好记的<strong>内网 IP</strong>，如<em>192.168.1.1</em>。之后给每个设备分配不同的<strong>内网IP</strong></p>
</li>
<li><p>路由器会有两个IP，分别是<strong>内网IP</strong>和<strong>外网IP</strong></p>
</li>
<li><p>内网中的设备可以互相访问（比如你可以用电脑或手机进入<a href="http://192.168.1.1/" title="null" target="_blank" rel="noopener">http://192.168.1.1</a>来查看你的路由器<strong>「因为路由器内置一个HTTP服务器」</strong>），但是不能<strong>直接</strong>访问外网，内网设备想要访问外网，就必须经过路由器中转</p>
</li>
<li><p>外网中的设备可以互相访问（比如 qq.com 可以把首页发送给你的路由器，你的路由器有<strong>外网 IP</strong>），但是外网中的设备无法访问你的内网设备（这很好理解，内网是一个封闭的网络，外人进不来，所以实际上 qq.com 无法直接把首页放送给你的电脑和手机）</p>
</li>
<li><p>路，就是「必由之路」中的路。由，就是「必由之路」中的由（由是经过、缘由的意思）。所有的信息都要经过路由器，然后被指向一条它该去的路</p>
</li>
<li><p><strong>内网</strong>和<strong>外网</strong>通过<strong>路由器</strong>连接</p>
</li>
<li><p><strong>本地IP：127.0.0.1</strong>：表示设备本身</p>
</li>
<li><p>hosts：可以设置任意域名对应的IP</p>
</li>
<li><p>hosts文件中会有一行<code>127.0.0.1 localhost</code>，意思就是 <strong>localhost</strong> 指向 <strong>127.0.0.1</strong>，所以 <strong>localhost</strong> 也表示设备本身</p>
</li>
<li><p>特别特殊的 IP：<code>0.0.0.0</code>，它不表示任何设备。这个 IP 不同的地方含义不同</p>
</li>
<li><p>使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可。如果没有提供，浏览器会加上默认端口号80。</p>
</li>
</ol>
<h1 id="端口（port）"><a href="#端口（port）" class="headerlink" title="端口（port）"></a>端口（port）</h1><p>端口其实就是一个编号。一个服务器（硬件）不一定只提供一种服务，比如一个服务器既提供 HTTP 服务（网页服务），又提供 FTP 服务（文件下载服务），还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务，所以<strong>一个端口对应一个服务</strong>，是固定的。</p>
<h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><ol>
<li><p>提供 <strong>HTTP 服务</strong> ==&gt; <strong>80 端口</strong></p>
</li>
<li><p>提供 <strong>HTTPS 服务</strong> ==&gt; <strong>443 端口</strong></p>
</li>
<li><p>提供 <strong>FTP 服务</strong> ==&gt; <strong>21 端口</strong></p>
</li>
<li><p>提供<strong>代理服务器端口</strong> ==&gt; <strong>1080端口</strong></p>
</li>
</ol>
<h3 id="端口基础"><a href="#端口基础" class="headerlink" title="端口基础"></a>端口基础</h3><p>每个机器一共有 65535（2的16次方减1）个端口（这是协议规定的）。不过这些端口的使用有一些规定</p>
<ol>
<li><p>0 到 1023（2的10次方减1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口</p>
</li>
<li><p>其他端口可以给普通用户使用</p>
</li>
<li><p>如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。</p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-15T10:27:13.000Z"><a href="/2018/01/15/HTTP系列 -- 请求与响应/">2018-01-15</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/15/HTTP系列 -- 请求与响应/">HTTP系列 -- 请求与响应</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li><p><strong>Server（服务器）</strong>：服务器作为硬件来说，通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机</p>
</li>
<li><p><strong>Client（客户端）</strong>：是指与服务器相对应，为客户提供本地服务的程序</p>
</li>
</ol>
<h1 id="浏览器-服务器-HTTP-三者关系"><a href="#浏览器-服务器-HTTP-三者关系" class="headerlink" title="浏览器 + 服务器 + HTTP 三者关系"></a>浏览器 + 服务器 + HTTP 三者关系</h1><ul>
<li>浏览器负责发起请求</li>
<li>服务器在<strong>80端口</strong>接收请求</li>
<li>服务器负责返回内容（响应）</li>
<li>浏览器负责下载响应内容</li>
</ul>
<p><strong>HTTP 的作用就是指导浏览器和服务器如何进行沟通。</strong></p>
<h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><h3 id="请求头（Request-Headers）格式"><a href="#请求头（Request-Headers）格式" class="headerlink" title="请求头（Request Headers）格式"></a>请求头（Request Headers）格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.请求类型 路径 协议/版本 // 请求行</span><br><span class="line">2.key: value  // 请求头</span><br><span class="line">3.</span><br><span class="line">4.要上传的数据  // 其他消息体</span><br></pre></td></tr></table></figure>
<h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><ol>
<li><p>GET ==&gt; 用于获取数据。</p>
</li>
<li><p>POST ==&gt; 用于提交数据，请求服务器进行处理。</p>
</li>
<li><p>PUT ==&gt; 向指定资源位置上传其最新内容（所有内容都更新）。</p>
</li>
<li><p>PATCH ==&gt; 用于将局部修改应用到资源。</p>
</li>
<li><p>DELETE ==&gt; 请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>HEAD ==&gt; 向服务器发出指定资源的请求，但服务器将不传回资源的本文部分。</p>
</li>
<li><p>OPTIONS ==&gt; 使服务器传回该资源所支持的所有HTTP请求方法，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
</ol>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>必须以 <code>/</code> 开头，如果不设置，默认为 <code>/</code> ，路径包括<strong>查询参数</strong>，但是不包括<strong>锚点</strong></p>
<h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><p>版本大部分都是 <code>HTTP/1.1</code>，还有<code>HTTP/2</code>.</p>
<h3 id="请求头（key-value）："><a href="#请求头（key-value）：" class="headerlink" title="请求头（key: value）："></a>请求头（key: value）：</h3><p>请求头定义一些操作参数。其中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host: www.baidu.com  // 域名</span><br><span class="line">User-Agent:      // 用的什么软件发起的请求</span><br><span class="line">Content-Type: application/x-www-form-urlcoded    //标识了第4部分的格式,POST 请求</span><br><span class="line">Content-Length: </span><br><span class="line">Cookie:</span><br></pre></td></tr></table></figure></p>
<h3 id="第3部分："><a href="#第3部分：" class="headerlink" title="第3部分："></a>第3部分：</h3><p>是一个空行（回车）。</p>
<h3 id="第4部分："><a href="#第4部分：" class="headerlink" title="第4部分："></a>第4部分：</h3><p>上传的数据，可以没有 </p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>https 协议 ==&gt; 所有数据在网络上请求和传输的时候都是加密的</li>
<li>http 协议  ==&gt; 所有数据在网络上请求和传输的时候都是明文的</li>
</ul>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><h3 id="响应头（Response-Headers）格式"><a href="#响应头（Response-Headers）格式" class="headerlink" title="响应头（Response Headers）格式"></a>响应头（Response Headers）格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.协议/版本 状态码 状态解释</span><br><span class="line">2.key: value  </span><br><span class="line">3.</span><br><span class="line">4.要下载的数据</span><br></pre></td></tr></table></figure>
<h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><p>表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<ul>
<li><p>2xx成功 ==&gt; 代表请求已成功被服务器接收、理解、并接受。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回（GET）。</span><br><span class="line">b.204 No Content 服务器成功处理了请求，没有返回任何内容（创建成功 ==&gt; POST）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>3xx重定向 ==&gt; 类状态码代表需要客户端采取进一步的操作才能完成请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.301 Move Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。</span><br><span class="line">b.302 Found 要求客户端执行临时重定向。</span><br><span class="line">c.304 Not Modified 表示资源未被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</span><br></pre></td></tr></table></figure>
</li>
<li><p>4xx客户端错误 ==&gt; 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.403 Forbidden 客户端错误，服务器已经理解请求，但是拒绝执行  它。</span><br><span class="line">b.404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发    现，但允许用户的后续请求。</span><br></pre></td></tr></table></figure>
</li>
<li><p>5xx服务器错误 ==&gt; 表示服务器无法完成明显有效的请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.500 Internal Server Error 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</span><br><span class="line">b.502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HTML-与-HTTP"><a href="#HTML-与-HTTP" class="headerlink" title="HTML 与 HTTP"></a>HTML 与 HTTP</h1><p>所有 App 都会内置一个浏览器（WebView）用来展示 HTML，而 HTML 都是通过 HTTP 下载的，而如果你要使用 HTTP 一般都会用到 URL。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-15T10:21:51.000Z"><a href="/2018/01/15/HTTP系列 -- 基础知识/">2018-01-15</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/15/HTTP系列 -- 基础知识/">HTTP系列 -- 基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/bash-create-file-script-demo" target="_blank" rel="noopener">代码链接</a></p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>JavaScript 是一门动态类型、面向对象的脚本语言</p>
<h3 id="bash-脚本"><a href="#bash-脚本" class="headerlink" title="bash 脚本"></a>bash 脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/local</span><br><span class="line">cd ~/local</span><br><span class="line">touch demo.txt</span><br><span class="line">start demo.txt</span><br><span class="line"></span><br><span class="line">    //内容如下：</span><br><span class="line">    //mkdir demo</span><br><span class="line">    //cd demo</span><br><span class="line">    //mkdir css js</span><br><span class="line">    //touch index.html css/style.css js/main.js</span><br><span class="line">    //exit</span><br><span class="line"></span><br><span class="line">    //（Windows 用户请跳过这一步）给 demo.sh 添加执行权限，加上可执行的操作</span><br><span class="line">    //chmod +x demo.txt</span><br><span class="line"></span><br><span class="line">    // 在任意位置执行 &apos;sh ~/local/demo.txt&apos; 即可运行此脚本，sh ==&gt; shell</span><br><span class="line">cd ~/desktop</span><br><span class="line">sh ~/local/demo.txt</span><br><span class="line">    // 你会看到当前目录里多出一个 demo 目录，demo 目录里面还有一些文件</span><br><span class="line">    // demo.txt 就是你写出的第一个 Bash 脚本了。</span><br><span class="line"></span><br><span class="line">    // 将 ~/local 添加到 PATH 里</span><br><span class="line">cd ~/local;pwd</span><br><span class="line">touch ~/.bashrc</span><br><span class="line">start ~/.bashrc</span><br><span class="line">    //在最后一行添加 </span><br><span class="line">export PATH=&quot;local的绝对路径:$PATH&quot;</span><br><span class="line">source ~/.bashrc</span><br><span class="line">    // 之前你要运行 sh ~/local/demo.txt，现在你只需要运行 demo.txt 就行  了</span><br><span class="line">    // 原因：将这个路径添加到 &apos;~/.bashrc&apos; 之后，就是在进入 git bash 之前就运行了 &apos;~/.bashrc&apos; </span><br><span class="line"></span><br><span class="line">    // 删掉demo.txt 的后缀 .txt </span><br><span class="line">mv ~/local/demo.txt ~/local/demo</span><br><span class="line">    // 现在只要运行 demo 就能执行该脚本了。</span><br></pre></td></tr></table></figure>
<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol>
<li>PATH 的作用<br>你每次在 Bash 里面输入一个命令时（比如 ls、cp、demo），Bash 都会去 PATH 列表里面寻找对应的文  件，如果找到了就执行。(<code>each $PATH</code>查看PATH，’目录：目录…’)</li>
<li><code>type demo</code> 可以看到寻找过程</li>
<li><code>which demo</code> 可以看到寻找结果,最终结果</li>
<li>文件后缀的作用：毫无作用，windows有一个用处，告诉计算机，用什么打开文件</li>
<li>所有命令都是可执行文件，都是一个脚本文件，可执行文件就是命令，不可执行文件就是配置</li>
</ol>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>让 demo 脚本创建的目录可变，更改 demo 的内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir $1</span><br><span class="line">cd $1   //  $1 ==&gt; 表示传递的第一个参数</span><br><span class="line">mkdir css js</span><br><span class="line">touch index.html css/style js/main.js</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p><code>exit 1</code> 表示错误代码1</p>
<p><code>exit 0</code>表示没有错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo xxx &amp;&amp; echo &apos;end&apos; //表示之后 demo xxx 成功了才会执行 echo &apos;end&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Node-js-脚本"><a href="#Node-js-脚本" class="headerlink" title="Node.js 脚本"></a><a href="https://github.com/bowen-wu/node-create-file" target="_blank" rel="noopener">Node.js 脚本</a></h3><h1 id="www（World-Wide-Web）"><a href="#www（World-Wide-Web）" class="headerlink" title="www（World Wide Web）"></a>www（World Wide Web）</h1><p>1990年万维网（World Wide Web）诞生。Tim Berners-Lee 发明了第一个网页、第一个浏览器和第一个服务器</p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li><p><strong>URI（Uniform Resource Identifier）</strong>：统一资源标识符，是一个用于标识某一互联网资源名称的字符串，其中包括 URL 和 URN 。</p>
<ul>
<li><p>URL（Uniform Resource Locator）：统一资源定位符，或者称为<strong>URL地址</strong>和<strong>网页地址（网址）</strong>。统一资源定位符的标准格式如下：<br><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code><br><img src="http://upload-images.jianshu.io/upload_images/9617841-1dd60cd247108428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URL地址"></p>
</li>
<li><p>URN（Uniform Resource Name）：统一资源名称，其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址。</p>
</li>
</ul>
</li>
<li><p><strong>HTTP（HyperText Transfer Protocol）</strong>：超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。就是两个电脑之间传输内容的协议。</p>
</li>
<li><p><strong>HTML（HyperText Markup Language）</strong>：超文本标记语言，是一种用于创建网页的标准标记语言。<a href="http://info.cern.ch/" target="_blank" rel="noopener">第一个网页</a></p>
</li>
<li><p><strong>DNS（Domain Name System）</strong>：域名系统，是互联网的一项服务。它作为将<strong>域名和IP地址相互映射</strong>的一个分布式数据库，能够使人更方便地访问互联网。（<strong>输入一个域名，将得到一个IP</strong>）</p>
<ul>
<li><p>输入域名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在命令行中输入以下任意一条，即可返回包括IP地址的一些信息</span><br><span class="line">nslookup baidu.com</span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出IP</p>
</li>
</ul>
</li>
</ol>
<p><strong>说明：</strong></p>
<ul>
<li>可以修改本地 hosts 文件从而让域名指向特定的IP</li>
<li>URL 的作用是能让你访问一个页面</li>
<li>HTTP 的作用是让你能下载这个页面</li>
<li>HTML 的作用是让你能看懂这个页面。</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-13T01:05:03.000Z"><a href="/2018/01/13/HTML-Element/">2018-01-13</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/13/HTML-Element/">HTML Element</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h1><ul>
<li><code>&lt;html&gt;</code> 表示一个HTML文档的根（顶级元素），所所以它也被称为根元素。其他所有其他元素必须是此元素的后代</li>
</ul>
<h1 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h1><p>元数据（Metadata）含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件 (如搜索引擎， 浏览器等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件</p>
<ul>
<li><p><code>&lt;link&gt;</code> 指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件</p>
</li>
<li><p><code>&lt;meta&gt;</code> 表示那些不能由其它HTML元相关元素 (<code>&lt;base&gt;</code>，<code>&lt;link&gt;</code>，<code>&lt;script&gt;</code>，<code>&lt;style&gt;</code>或<code>&lt;title&gt;</code>）之一表示的任何元数据信息</p>
</li>
<li><p><code>&lt;style&gt;</code> 包含了文档的样式化信息或者文档的一部分。指定的样式化星系包含的该元素内，通常是CSS的格式</p>
</li>
</ul>
<h1 id="内容分区"><a href="#内容分区" class="headerlink" title="内容分区"></a>内容分区</h1><p>内容分区元素允许你将文档内容从逻辑上进行组织划分。使用包括页眉(header)、页脚(footer)、导航(nav)和标题(h1~h6)等分区元素，来为页面内容创建明确的大纲，以便区分各个章节的内容</p>
<ul>
<li><p><code>&lt;address&gt;</code> 可以让作者为它最近的<code>&lt;article&gt;</code>或者<code>&lt;body&gt;</code>祖先元素提供联系信息。在后一种情况下，它应用于整个文档</p>
</li>
<li><p><code>&lt;article&gt;</code> 表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目</p>
</li>
<li><p><code>&lt;aside&gt;</code> 表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容</p>
</li>
<li><p><code>&lt;footer&gt;</code> 示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息</p>
</li>
<li><p><code>&lt;h1-h6&gt;</code> 标题信息</p>
</li>
<li><p><code>&lt;header&gt;</code> 表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等</p>
</li>
<li><p><code>&lt;hgroup&gt;</code> 代表一个段的标题</p>
</li>
<li><p><code>&lt;nav&gt;</code> 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表</p>
</li>
<li><p><code>&lt;section&gt;</code> 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）</p>
</li>
</ul>
<h1 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h1><p>使用 HTML 文本内容元素来组织在开标签<code>&lt;body&gt;</code>和闭标签<code>&lt;/body&gt;</code> 里的块或章节的内容。这些元素能标识内容的宗旨或结构，而这对于 accessibility 和 SEO很重要</p>
<ul>
<li><p><code>&lt;blockquote&gt;</code> 引用块</p>
</li>
<li><p><code>&lt;div&gt;</code> 是一个通用型的流内容容器</p>
</li>
<li><p><code>&lt;dl&gt;</code> 是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)</p>
</li>
<li><p><code>&lt;dt&gt;</code> 用于在一个定义列表中声明一个术语。通常在该元素后面会跟着 <code>&lt;dd&gt;</code>元素</p>
</li>
<li><p><code>&lt;dd&gt;</code> 用来指明一个描述列表  ( <code>&lt;dl&gt;</code> ) 元素中一个术语的描述。这个元素只能作为描述列表元素的子元素出现，并且必须跟着一个 <code>&lt;dt&gt;</code> 元素</p>
</li>
<li><p><code>&lt;hr&gt;</code> 表示段落级元素之间的主题转换。在HTML的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上</p>
</li>
<li><p><code>&lt;main&gt;</code> 呈现了文档<code>&lt;body&gt;</code>或应用的主体部分</p>
</li>
<li><p><code>&lt;ol&gt;</code> 表示多个有序列表项，通常渲染为有带编号的列表</p>
</li>
<li><p><code>&lt;ul&gt;</code> 代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的</p>
</li>
<li><p><code>&lt;li&gt;</code> 用于表示列表里的条目。它必须被包含在一个父元素 <code>&lt;ul&gt;</code> <code>&lt;ol&gt;</code> 里</p>
</li>
<li><p><code>&lt;p&gt;</code> 表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进</p>
</li>
<li><p><code>&lt;pre&gt;</code> 表示预定义格式文本</p>
</li>
</ul>
<h1 id="内联文本语义"><a href="#内联文本语义" class="headerlink" title="内联文本语义"></a>内联文本语义</h1><p>使用 HTML 内联文本语义(Inline text semantics)定义语句，结构，可以是一个词，一段，或任意风格的文字</p>
<ul>
<li><p><code>&lt;a&gt;</code>  可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接</p>
</li>
<li><p><code>&lt;abbr&gt;</code> 代表缩写，并可选择提供一个完整的描述</p>
</li>
<li><p><code>&lt;b&gt;</code> 表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联，通常以粗体显示</p>
</li>
<li><p><code>&lt;bdi&gt;</code> (双向隔离元素) 会隔离可能以不同方向进行格式化的外部文本</p>
</li>
<li><p><code>&lt;bdo&gt;</code> (HTML双向覆盖元素)用于覆盖当前文本的朝向，它使得字符按给定的方向排列</p>
</li>
<li><p><code>&lt;br&gt;</code> 文本中产生一个换行（回车键）</p>
</li>
<li><p><code>&lt;cite&gt;</code> 表示一个作品的引用</p>
</li>
<li><p><code>&lt;code&gt;</code> 现一段计算机代码. 默认情况下, 它以浏览器的默认等宽字体显示</p>
</li>
<li><p><code>&lt;data&gt;</code> 将一个指定内容和机器可读的翻译联系在一起</p>
</li>
<li><p><code>&lt;em&gt;</code> 标记出需要用户着重阅读的内容</p>
</li>
<li><p><code>&lt;i&gt;</code> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示</p>
</li>
<li><p><code>&lt;kbd&gt;</code> 用于表示用户输入，它将产生一个行内元素，以浏览器的默认monospace字体显示</p>
</li>
<li><p><code>&lt;mark&gt;</code> 代表突出显示的文字</p>
</li>
<li><p><code>&lt;q&gt;</code> 表示一个封闭的并且是短的行内引用的文本。这个标签是用来引用短的文本，所以请不要引入换行符； 对于长的文本的引用请使用<code>&lt;blockquote&gt;</code>替代</p>
</li>
<li><p><code>&lt;s&gt;</code> 使用删除线来渲染文本</p>
</li>
<li><p><code>&lt;small&gt;</code> 使文本的字体变小一号</p>
</li>
<li><p><code>&lt;span&gt;</code> 短语内容的通用行内容器，并没有任何特殊语义</p>
</li>
<li><p><code>&lt;strong&gt;</code> 表示文本十分重要，一般用粗体显示</p>
</li>
<li><p><code>&lt;sub&gt;</code> 定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。<strong>下标</strong></p>
</li>
<li><p><code>&lt;sup&gt;</code> 定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。<strong>上标</strong></p>
</li>
<li><p><code>&lt;u&gt;</code> 使文本在其内容的基线下的一行呈现下划线</p>
</li>
</ul>
<h1 id="图片和多媒体"><a href="#图片和多媒体" class="headerlink" title="图片和多媒体"></a>图片和多媒体</h1><p>HTML 支持各种多媒体资源，例如图像，音频和视频</p>
<ul>
<li><p><code>&lt;area&gt;</code>  在图片上定义一个热点区域</p>
</li>
<li><p><code>&lt;audio&gt;</code> 用于在文档中表示音频内容。 <code>&lt;audio&gt;</code>元素可以包含多个音频资源， 这些音频资源可以使用 <code>src</code>属性或者<code>&lt;source&gt;</code>元素来进行描述； 浏览器将会选择最合适的一个来使用。对于不支持 <code>&lt;audio&gt;</code> 元素的浏览器，<code>&lt;audio&gt;</code> 元素也可以作为浏览器不识别的内容加入到文档中</p>
</li>
<li><p><code>&lt;img&gt;</code> 代表文档中的一个图像</p>
</li>
<li><p><code>&lt;track&gt;</code> 被当作媒体元素—<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>的子元素来使用。它允许指定计时字幕（或者基于事件的数据），例如自动处理字幕</p>
</li>
<li><p><code>&lt;video&gt;</code> 用于在HTML或者XHTML文档中嵌入视频内容</p>
</li>
</ul>
<h1 id="内嵌内容"><a href="#内嵌内容" class="headerlink" title="内嵌内容"></a>内嵌内容</h1><p>除了常规的多媒体内容，HTML 可以包括各种其他的内容，即使它并不容易交互</p>
<ul>
<li><p><code>&lt;embed&gt;</code> 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件</p>
</li>
<li><p><code>&lt;object&gt;</code> 表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源</p>
</li>
<li><p><code>&lt;param&gt;</code> 定义了 <code>&lt;object&gt;</code>的参数</p>
</li>
<li><p><code>&lt;source&gt;</code></p>
</li>
</ul>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>为了创建动态内容和 Web 应用程序，HTML 支持使用脚本语言，最突出的就是 JavaScript。某些元素支持此功能</p>
<ul>
<li><p><code>&lt;canvas&gt;</code> 可被用来通过脚本（通常是JavaScript）绘制图形</p>
</li>
<li><p><code>&lt;noscript&gt;</code> 如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则HTML <noscript>元素定义要插入的html部分</noscript></p>
</li>
<li><p><code>&lt;script&gt;</code> 用于嵌入或引用可执行脚本</p>
</li>
</ul>
<h1 id="编辑标识"><a href="#编辑标识" class="headerlink" title="编辑标识"></a>编辑标识</h1><p>这些元素能标示出某个文本被更改过的部分</p>
<ul>
<li><p><code>&lt;del&gt;</code> 表示已经从文档中删除的文本范围。此元素通常是（但不必）呈现删除线的文本</p>
</li>
<li><p><code>&lt;ins&gt;</code> 定义已经被插入文档中的文本</p>
</li>
</ul>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>HTML 提供了许多可一起使用的元素，这些元素能用来创建一个用户可以填写并提交到网站或应用程序的表单</p>
<ul>
<li><p><code>&lt;button&gt;</code>  表示一个可点击的按钮</p>
</li>
<li><p><code>&lt;datalist&gt;</code> 包含了一组<code>&lt;option&gt;</code>元素,这些元素表示其它表单控件可选值</p>
</li>
<li><p><code>&lt;fieldset&gt;</code> 用来对表单中的控制元素进行分组(也包括 label 元素)</p>
</li>
<li><p><code>&lt;form&gt;</code> 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息</p>
</li>
<li><p><code>&lt;input&gt;</code> 用于为基于Web的表单创建交互式控件，以便接受来自用户的数据</p>
</li>
<li><p><code>&lt;label&gt;</code> 表示用户界面中项目的标题</p>
</li>
<li><p><code>&lt;legend&gt;</code> 代表一个用于表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题</p>
</li>
<li><p><code>&lt;meter&gt;</code> 用来显示已知范围的标量值或者分数值</p>
</li>
<li><p><code>&lt;option&gt;</code> 用于定义在<code>&lt;select&gt;</code>、<code>&lt;optgroup&gt;</code> 或 <code>&lt;datalist&gt;</code> 元素中包含的项</p>
</li>
<li><p><code>&lt;output&gt;</code> 表示计算或用户操作的结果</p>
</li>
<li><p><code>&lt;progress&gt;</code> 用来显示一项任务的完成进度。通常情况下,该元素都显示为一个进度条形式</p>
</li>
<li><p><code>&lt;select&gt;</code> 一种表单控件，可创建选项菜单</p>
</li>
<li><p><code>&lt;textarea&gt;</code> 表示一个多行纯文本编辑控件</p>
</li>
</ul>
<h1 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h1><p>HTML 提供了一系列有助于创建交互式用户界面对象的元素</p>
<ul>
<li><p><code>&lt;details&gt;</code> 被用作发现小部件，用户可以从其中检索附加信息</p>
</li>
<li><p><code>&lt;dialog&gt;</code> 表示一个对话框或其他交互式组件，例如一个检查员或窗口</p>
</li>
<li><p><code>&lt;menu&gt;</code> 呈现了一组用户可执行或激活的命令。这既包含了可能出现在屏幕顶端的列表菜单，也包含了那些隐藏在按钮之下、当点击按钮后显示出来的文本菜单</p>
</li>
<li><p><code>&lt;menuitem&gt;</code> 生成一个弹出式菜单。这包括上下文菜单，以及按钮可能附带的菜单。</p>
</li>
<li><p><code>&lt;summary&gt;</code> 用作 一个 <code>&lt;details&gt;</code> 元素的一个内容的摘要，标题或图例</p>
</li>
</ul>
<h1 id="web组件"><a href="#web组件" class="headerlink" title="web组件"></a>web组件</h1><p>Web 组件是种近似 HTML（HTML-related） 的技术，这使得它能够，从本质上讲，创建和使用自定义元素，就好像它是普通的 HTML。此外，你甚至可以创建自定义版本的标准 HTML 元素</p>
<ul>
<li><p><code>&lt;slot&gt;</code> web组件技术的一部分，slot是web组件的一个占位符，可以用来插入自定义的标记文本。可以创建不同的DOM树并进行渲染</p>
</li>
<li><p><code>&lt;template&gt;</code> 一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用JavaScript进行实例化</p>
</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTML/">HTML</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-12T11:05:51.000Z"><a href="/2018/01/12/jQuery系列（二）-- 样式/">2018-01-12</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/12/jQuery系列（二）-- 样式/">jQuery系列（二） -- 样式</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>jQuery 函数包装的对象是类数组对象，对象里面包含了 DOM 对象的信息，并封装了很多操作方法，可以和访问数组一样的方法来访问。</p>
<h1 id="jQuery-对象-和-DOM-对象"><a href="#jQuery-对象-和-DOM-对象" class="headerlink" title="jQuery 对象 和 DOM 对象"></a>jQuery 对象 和 DOM 对象</h1><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>可是使用 $ 符号将 DOM 对象封装成 jQuery 对象 <code>$( div )</code><br>可是使用 <code>div = $div[ 0 ]</code> 或者 <code>div = $div.get( 0 )</code> 将 jQuery 对象转化成 DOM 对象</p>
<p>###区别<br>DOM 对象的属性和方法有： .style   .classList<br>jQuery 对象的属性和方法有：.css     .addClass    </p>
<p><strong>说明：</strong>传递给 $(DOM) 函数的参数是 DOM Object ，则 jQuery 函数会把这个 DOM Object 给包装成一个新的 jQuery 对象</p>
<h1 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h1><ol>
<li>id 选择器： $( “#id” )</li>
<li>类选择器：$( “.class” )</li>
<li>元素选择器： $( “element” )</li>
<li>全选择器：$( “*” )</li>
<li><p>层级选择器</p>
<ul>
<li><p>子选择器：$( “parent &gt; child” )</p>
</li>
<li><p>后代选择器：$( “ancestor descendant” )</p>
</li>
<li><p>相邻兄弟选择器：$( “prev + next” )<br>选择所有紧跟在 <code>prev</code> 元素后的 <code>next</code> 元素</p>
</li>
<li><p>一般兄弟选择器：$( “prev ~ siblings” )<br>匹配 <code>prev</code> 元素之后的所有兄弟元素，具有相同的父元素，并匹配过滤 <code>siblings</code> 选择器</p>
</li>
</ul>
</li>
<li><p>基本筛选选择器</p>
<ul>
<li>$( “:first” ) ==&gt; 匹配第一个元素</li>
<li>$( “:last” ) ==&gt; 匹配最后一个元素</li>
<li>$( “:not(seletor)” ) ==&gt; 选择所有元素去除不匹配给定的选择器元素</li>
<li>$( “:eq(index)” ) ==&gt; 在匹配的集合中选择 index 的元素（从0开始）</li>
<li>$( “:gt(index)” ) ==&gt; 在匹配的集合中选择大于 index 的元素（从0开    始）</li>
<li>$( “:lt(index)” ) ==&gt; 在匹配的集合中选择小于 index 的元素（从0开    始）</li>
<li>$( “:odd” ) ==&gt; 选择索引值为奇数的元素</li>
<li>$( “:even” ) ==&gt; 选择索引值为偶数的元素</li>
<li>$( “:header” ) ==&gt; 选择所有标题元素</li>
<li>$( “:root” ) ==&gt; 选择该文档的根元素</li>
<li>$( “:lang(language)” ) ==&gt; 选择指定语言的所有元素</li>
<li>$( “:animated” ) ==&gt; 选择所有正在执行动画的元素<br><strong>说明：</strong><pre><code>1. :eq()、:lt()、:gt()、:even、:odd 用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素进一步筛选
2. :gt() 是一个段落筛选，从指定索引的下一个开始，:gt(1) 实际是从2开始
</code></pre></li>
</ul>
</li>
<li><p>内容筛选选择器</p>
<ul>
<li><p>$( “:parent” ) ==&gt; 选择所有含有子元素或者文本的元素</p>
</li>
<li><p>$( “:empty” ) ==&gt; 选择所有没有子元素的元素（包括文本节点）</p>
</li>
<li><p>$( “:contains(text)” ) ==&gt; 选择所有包含指定文本的元素</p>
</li>
<li><p>$( “:has(selector)” ) ==&gt; 选择元素中至少包含指定选择器的元素<br><strong>说明：</strong></p>
<pre><code>1. :contain 和 :has 都有查找的意思，但 contains 查找包含**制定文本**的元素，has 查找包含**指定元素**的元素
2. 如果 :contains 匹配的文本包含在元素的子元素中，同样认为是符合条件的
3. :parent 和 :empty 是相反的，但是两者所涉及的子元素都包括文本节点
</code></pre></li>
</ul>
</li>
<li><p>可见性筛选选择器</p>
<ul>
<li><p>$( “:visible” ) ==&gt; 选择所有显示的元素</p>
</li>
<li><p>$( “:hidden” ) ==&gt; 选择所有隐藏的元素</p>
<p><strong>隐藏元素的方式</strong></p>
<ol>
<li>CSS ==&gt; display: none</li>
<li>width: 0; height: 0;</li>
<li>visibility: hidden;</li>
<li>opacity: 0;<br><strong>说明：</strong>如果元素<strong>占据文档中一定的空间</strong>，元素被认为是<strong>可见</strong>的，可见元素的宽高都大于 0 ，元素的 <code>visibility: hidden;</code> 和 <code>opacity: 0;</code> 被认为是可见的，因为他们仍然占据空间布局。不在文档中的元素被认为是不可见的，如果当他们被插入到文档中，jQuery 没有办法知道他们是否是可见的，因为元素可见性依赖于使用的样式。</li>
</ol>
</li>
</ul>
</li>
<li><p>属性筛选选择器</p>
<ul>
<li><p>$( “[attribute |= ‘value’]” ) ==&gt; 选择指定属性值等于<strong>给定字符串</strong>或<strong>以该字符串为前缀</strong>（该字符串后跟一个连字符 ‘-‘）的元素</p>
</li>
<li><p>$( “[attribute <em>= ‘value’]” ) ==&gt; 选择指定属性具有<em>*包含一个给定的子字符串</em></em>的元素（选择给定属性是包含某些值的元素）</p>
</li>
<li><p>$( “[attribute ~= ‘value’]” ) ==&gt; 选择指定属性用<strong>空格分隔</strong>的值中包含一个给定值的元素</p>
</li>
<li><p>$( “[attribute = ‘value’]” ) ==&gt; 选择指定属性是<strong>给定值</strong>的元素</p>
</li>
<li><p>$( “[attribute != ‘value’]” ) ==&gt; 选择<strong>不存在指定属性</strong>，或者指定的属性<strong>不等于给定值</strong>的元素</p>
</li>
<li><p>$( “[attribute ^= ‘value’]” ) ==&gt; 选择指定属性是以<strong>给定字符串开始</strong>的元素</p>
</li>
<li><p>$( “[attribute $= ‘value’]” ) ==&gt; 选择指定属性是以<strong>给定值结尾</strong>的元素</p>
</li>
<li><p>$( “[attribute]” ) ==&gt; 选择所有<strong>具有指定属性</strong>的元素，该属性是任意值</p>
</li>
</ul>
</li>
<li><p>表单元素选择器</p>
<ul>
<li><p>$( “:input” ) ==&gt; 选择所有 input textarea select 和 button 的元素</p>
</li>
<li><p>$( “:text” ) ==&gt; 匹配所有文本框</p>
</li>
<li><p>$( “:password” ) ==&gt; 匹配所有密码框</p>
</li>
<li><p>$( “:raido” ) ==&gt; 匹配所有单选按钮</p>
</li>
<li><p>$( “:checkbox” ) ==&gt; 匹配所有复选框</p>
</li>
<li><p>$( “:submit” ) ==&gt; 匹配所有提交按钮</p>
</li>
<li><p>$( “:image” ) ==&gt; 匹配所有图像域</p>
</li>
<li><p>$( “:reset” ) ==&gt; 匹配所有重置按钮</p>
</li>
<li><p>$( “:button” ) ==&gt; 匹配所有按钮</p>
</li>
<li><p>$( “:file” ) ==&gt; 匹配所有文件域</p>
</li>
</ul>
<p><strong>说明：</strong></p>
<pre><code>1. 除了 input 筛选选择器，其余每个表单类别选择器都对应一个 input 元素的 type 值，所以其都可以用属性筛选选择器替换
2. ` $( &quot;:password&quot; ) === $( &quot;[type = password]&quot; ) `
</code></pre></li>
<li><p>表单对象属性筛选选择器</p>
<ul>
<li><p>$( “:enabled” ) ==&gt; 选取可用的表单元素</p>
</li>
<li><p>$( “:disabled” ) ==&gt; 选取不可用的表单元素</p>
</li>
<li><p>$( “:checked” ) ==&gt; 选取被选中的 <input> 元素</p>
</li>
<li><p>$( “:selected” ) ==&gt; 选取被选中的 <option> 元素</option></p>
</li>
</ul>
<p><strong>说明：</strong></p>
<pre><code>1. 选择器适用于复选框和单选框，对于**下拉框**元素使用 **:selected** 选择器
2. 在使用 :checked 的时候，**最佳实践是使用 input: checked** 
</code></pre></li>
<li><p>子元素筛选选择器</p>
<ul>
<li><p>$( “:first-child” ) ==&gt; 选择所有父级元素下的第一个子元素</p>
</li>
<li><p>$( “:last-child” ) ==&gt; 选择所有父级元素下的最后一个子元素</p>
</li>
<li><p>$( “:only-child” ) ==&gt; 如果某个元素是其父元素下的唯一子元素，那么它就会被选中</p>
</li>
<li><p>$( “:nth-child(n)” ) ==&gt; 选择所有父级元素下的第 n 个子元素，n 是索引值，从 1 开始</p>
</li>
<li><p>$( “:nth-last-child(n)” ) ==&gt; 选择所有父级元素下的第 n 个子元素，计数从最后一个开始</p>
</li>
</ul>
</li>
<li><p>特殊选择器</p>
<ul>
<li><p>this ==&gt; 表示当前的上下文对象是一个 HTML 对象，可以调用 HTML 对象所拥有的属性和方法</p>
</li>
<li><p>$(this) ==&gt; 代表上下文是一个 jQuery 的上下文对象，可以调用 jQuery 的方法和属性值</p>
</li>
</ul>
</li>
</ol>
<h1 id="jQuery-属性与样式"><a href="#jQuery-属性与样式" class="headerlink" title="jQuery 属性与样式"></a>jQuery 属性与样式</h1><ol>
<li><p>.attr()<br>获取和设置元素属性（DOM操作）</p>
<ul>
<li>.attr(传入属性名) ==&gt; 获取属性值</li>
<li>.attr(属性名, 属性值) ==&gt; 设置属性值</li>
<li>.attr(属性名, 函数值) ==&gt; 设置属性的函数值</li>
<li>.attr(attribute) ==&gt; 给指定元素设置多个属性值<br>.attr({属性名1: “属性值1” , 属性名2: “属性值2”, …})</li>
</ul>
<p><strong>说明：Attribute 和 Property</strong></p>
<pre><code>1. Attribute 属性 ，  Property  特性
2. Attribute 就是 DOM node 自带的属性（id、class、title），Property 是 DOM 元素作为对象，其附加的内容（nodeName、nodeType、tagName）
</code></pre></li>
<li><p>.removeAttr()<br> 为匹配的元素集合中的每个元素移除一个属性 attributeName</p>
</li>
<li><p>.html()<br> 获取或设置匹配元素的 HTML 内容</p>
<ul>
<li>.html() ==&gt; 获取集合中第一个匹配元素的 HTML 内容</li>
<li>.html(htmlString) ==&gt; 设置每一个匹配元素的 HTML 内容</li>
<li>.html(function(index, oldhtml)) ==&gt; 用来返回设置 HTML 内容的一个函数<br><strong>说明：</strong><pre><code>.html() 方法内部使用的是 DOM 的 innerHTML 属性来操作的，这个操作是针对整个 HTML 内容（包括文本内容）
</code></pre></li>
</ul>
</li>
<li><p>.text()<br> 得到匹配元素集合中的每个元素的文本内容的结合，包括他们的后代，或者设置匹配元素集合中每个元素的文本内容为指定的文本内容</p>
<ul>
<li>.text() ==&gt; 获取匹配元素集合中每个元素的合并文本，包括他们的后代</li>
<li>.text(textString) ==&gt; 用来设置匹配元素内容的文本</li>
<li><p>.text(function(index, text)) ==&gt; 用来返回设置文本内容的一个函数</p>
<p><strong>说明：.html() 和 .text()</strong></p>
<pre><code>1. .html() 处理元素内容，.text() 处理文本内容
2. html() 只能使用在 HTML 文档中，.text() 在 XML 文档和 HTML 文档都能使用
3. 若处理对象只有一个子文本节点，则 .html 和 .text() 处理结果相同
</code></pre></li>
</ul>
</li>
<li><p>.val()<br> 处理<strong>表单元素</strong>的值  </p>
<ul>
<li>.val() ==&gt; 获取匹配元素集合中第一个元素的当前值</li>
<li>.val(value) ==&gt; 设置匹配的元素集合中每个元素的值</li>
<li><p>.val(function(){}) ==&gt; 一个用来返回设置值的函数</p>
<p><strong>说明：.html() 和 .text()</strong></p>
<pre><code>1. .val() 处理 select 元素，当没有选择项被选中时，它将返回 null 
2. 若 select 元素有 multiple 属性，并且至少一个选择项被选中时， .val() 将返回一个数组，这个数组包含每个选中选择项的值
3. .val() 方法多用来设置表单的字段的值
</code></pre></li>
</ul>
</li>
<li><p>.addClass()<br> 动态增加 class 类名</p>
<ul>
<li>.addClass(className) ==&gt; 为每个匹配元素增加一个或多个类名</li>
<li><p>.addClass(function(index, currentClass){}) ==&gt; 这个函数返回一个或更多用空格隔开的要增加的样式名</p>
<p><strong>说明：</strong></p>
<pre><code>1. .addClass() 方法不会替换一个样式类名，它只是简单的添加一个类名到元素上
2. 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(&apos;div&apos;).addClass(function(index, className)&#123;</span><br><span class="line">      if( className.indexOf(index) !== -1 )&#123;</span><br><span class="line">          $(this).addClass(&apos;red&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>.removeClass()<br> 删除全部或者指定的 class</p>
<ul>
<li>.removeClass([className])  ==&gt; 每个匹配的元素移除一个或对个用空格隔开的样式名</li>
<li><p>.removeClass(function(index, class)) ==&gt; 返回一个或多个要被移除的样式名的函数</p>
<p><strong>说明：</strong>如果 .removeClass() 没有参数，则会移除所有的样式类</p>
</li>
</ul>
</li>
<li><p>.toggleClass()<br> 在匹配的元素集合中的每个元素上添加或删除一个或多个样式类，取决于这个样式是否存在，即：如果存在就删除一个类，如果不存在就添加一个类</p>
<ul>
<li>.toggleClass(className) ==&gt; 切换类</li>
<li>.toggleClass(className,switch) ==&gt; 一个布尔值，用来判断样式是否应该被添加或移除</li>
<li>.toggleClass(function(index, class, switch){})</li>
</ul>
</li>
<li><p>.css()<br> 获取元素样式属性的计算值或者设置元素的 CSS 属性<br> <strong>获取</strong></p>
<ul>
<li>.css( “propertyName” ) ==&gt; 获取匹配元素集合中的第一个元素的样式属性的计算值</li>
<li><p>.css( “propertyNames” ) ==&gt; 传递一组数组，返回一个对象结果</p>
<p><strong>设置</strong></p>
</li>
<li>.css( ‘propertyName’, ‘value’ ) ==&gt; 设置 CSS</li>
<li>.css( ‘propertyName’, function ) ==&gt; 可以传入一个回调函数，返回取到对应的值进行处理</li>
<li><p>.css( ‘properties ) ==&gt; 可以传入一个对象，同时设置多个样式，用 <code>{ }</code> 括起</p>
<p><strong>说明：</strong></p>
<ol>
<li>通过 .css() 方法设置的样式属性优先级要高于 .addClass() 方法</li>
<li>若是<strong>静态结构</strong>，确定了布局规则，使用 <strong>.addClass()</strong> 方法增加类</li>
<li>若是<strong>动态的 HTML 结构</strong>，在不确定布局或者经常要变化的情况下，使用 <strong>.css()</strong> 方法</li>
<li>.addClass() 不能获取到指定样式的属性值，.css() 可以获取到指定的样式值</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/jQuery/">jQuery</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-12T11:01:20.000Z"><a href="/2018/01/12/jQuery系列（一）-- touch-jQuery/">2018-01-12</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/12/jQuery系列（一）-- touch-jQuery/">jQuery系列（一） -- touch jQuery</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h1><p>尽管 DOM 提供了 API ，可是当我们使用 DOM API 的时候却不尽人意，它提供的功能实在是有限，并且有些方法还没有，所以我们先来封装两个函数。第一个函数作用是获取一个元素节点的所有兄弟，第二个函数作用是可以对一个节点添加或者删除 class 。</p>
<h4 id="获取一个元素节点的所有兄弟"><a href="#获取一个元素节点的所有兄弟" class="headerlink" title="获取一个元素节点的所有兄弟"></a>获取一个元素节点的所有兄弟</h4><p>当调用 getSiblings 函数的时候只需要传入一个元素节点即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getSiblings(node) &#123;</span><br><span class="line">        let allchild = node.parentNode.children</span><br><span class="line">        let siblings = &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0, len = allchild.length; i &lt; len; i++) &#123;</span><br><span class="line">            if (allchild[i] !== node) &#123;</span><br><span class="line">                siblings[siblings.length] = allchild[i]</span><br><span class="line">                siblings.length += 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return siblings;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="操纵一个节点的-class-可以进行添加和删除"><a href="#操纵一个节点的-class-可以进行添加和删除" class="headerlink" title="操纵一个节点的 class 可以进行添加和删除"></a>操纵一个节点的 class 可以进行添加和删除</h4><p>调用 operationClass 时，需要传入一个节点和一个 classes 对象<code>operationClass( node, { className: true, className: false } )</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function operationClass(node,classes)&#123;</span><br><span class="line">        for(let key in classes)&#123;</span><br><span class="line">            let method = classes[key] ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">            node.classList[method](key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>利用命名空间，从而对上述两个函数进行优化<br>调用方法：<br><code>DOM.operationClass.call(undefined,node,{className:true,className:false})</code><br><code>console.log(DOM.getSiblings.call(undefined,node))</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let DOM = &#123;&#125;</span><br><span class="line">    DOM.operationClass = (node,classes) =&gt; &#123;</span><br><span class="line">        for(let key in classes)&#123;</span><br><span class="line">            let method = classes[key] ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">            node.classList[method](key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DOM.getSiblings = (node) =&gt; &#123;</span><br><span class="line">        let allchild = node.parentNode.children</span><br><span class="line"></span><br><span class="line">        let siblings = &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (let i = 0, len = allchild.length; i &lt; len; i++) &#123;</span><br><span class="line">            if (allchild[i] !== node) &#123;</span><br><span class="line">                siblings[siblings.length] = allchild[i]</span><br><span class="line">                siblings.length += 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return siblings;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最终优化"><a href="#最终优化" class="headerlink" title="最终优化"></a>最终优化</h1><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>在 Node.prototype 上添加方法，调用方法是：<br><code>node.operationClass.call(node,{className:true,className:false})</code><br><code>node.getSiblings.call(node)</code><br><strong>缺点</strong>：改变了 Node.prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Node.prototype.operationClass = function(classes)&#123;</span><br><span class="line">       for(let key in classes)&#123;</span><br><span class="line">           let method = classes[key] ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">           this.classList[method](key)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Node.prototype.getSiblings = function()&#123;</span><br><span class="line">       let allchild = this.parentNode.children</span><br><span class="line">       let siblings = &#123;</span><br><span class="line">           length: 0</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (let i = 0, len = allchild.length; i &lt; len; i++) &#123;</span><br><span class="line">           if (allchild[i] !== this) &#123;</span><br><span class="line">               siblings[siblings.length] = allchild[i]</span><br><span class="line">               siblings.length += 1</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return siblings;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>创造一个新的接口，使用全局变量 otherNode ，无侵入式调用。<br>调用方法：</p>
<pre><code>let node = otherNode.call(undefined,node)
node.operationClass.call(undefined,{red:true,blue:false})
node.getSiblings.call(undefined))
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.otherNode = (node) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        operationClass: (classes) =&gt; &#123;</span><br><span class="line">            for (let key in classes) &#123;</span><br><span class="line">                let method = classes[key] ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">                node.classList[method](key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        getSiblings : () =&gt; &#123;</span><br><span class="line">            let allchild = node.parentNode.children</span><br><span class="line">            let siblings = &#123;</span><br><span class="line">                length: 0</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let i = 0, len = allchild.length; i &lt; len; i++) &#123;</span><br><span class="line">                if (allchild[i] !== node) &#123;</span><br><span class="line">                    siblings[siblings.length] = allchild[i]</span><br><span class="line">                    siblings.length += 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return siblings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="方案二优化"><a href="#方案二优化" class="headerlink" title="方案二优化"></a>方案二优化</h6><p>优化方向：</p>
<ul>
<li>允许用户传入一个 CSS 选择器</li>
<li>添加了操作文本的功能<br>调用方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let node = otherNode.call(undefined,&apos;#id&apos;)</span><br><span class="line">node.getSiblings.call(undefined)</span><br><span class="line">node.operationClass.call(undefined,&#123;red:true,blue:false&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">window.otherNode = (nodeOrSelector) =&gt; &#123;</span><br><span class="line">        let node</span><br><span class="line">        if(typeof nodeOrSelector === &apos;string&apos;)&#123;</span><br><span class="line">            node = document.querySelector(nodeOrSelector)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            node = nodeOrSelector</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            operationClass: (classes) =&gt; &#123;</span><br><span class="line">                for (let key in classes) &#123;</span><br><span class="line">                    let method = classes[key] ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">                    node.classList[method](key)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            setText:(text) =&gt; &#123;</span><br><span class="line">                node.textContent = text;</span><br><span class="line">            &#125;,</span><br><span class="line">            getSiblings : () =&gt; &#123;</span><br><span class="line">                let allchild = node.parentNode.children</span><br><span class="line">                let siblings = &#123;</span><br><span class="line">                    length: 0</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (let i = 0, len = allchild.length; i &lt; len; i++) &#123;</span><br><span class="line">                    if (allchild[i] !== node) &#123;</span><br><span class="line">                        siblings[siblings.length] = allchild[i]</span><br><span class="line">                        siblings.length += 1</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return siblings;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="方案二再优化"><a href="#方案二再优化" class="headerlink" title="方案二再优化"></a>方案二再优化</h6><p>优化方向：</p>
<ul>
<li>满足更多的 CSS 选择器，例如 <code>ul &gt; li</code></li>
<li>简化了 <code>text</code> 功能，不传参数，就是获取，传参数就是设置<br>使用方法：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let node = otherNode.call(undefined, &apos;ul &gt; li&apos;)</span><br><span class="line">node.text()</span><br><span class="line">node.text(&apos;hello world&apos;)</span><br><span class="line">node.operationClass.call(undefined, &#123;</span><br><span class="line">    className: false,</span><br><span class="line">    className: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">window.otherNode = (nodeOrSelector) =&gt; &#123;</span><br><span class="line">    let nodes = &#123;&#125;</span><br><span class="line">    if (typeof nodeOrSelector === &apos;string&apos;) &#123;</span><br><span class="line">        let temp = document.querySelectorAll(nodeOrSelector)</span><br><span class="line">        for (let i = 0, len = temp.length; i &lt; len; i++) &#123;</span><br><span class="line">            nodes[i] = temp[i]</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.length = temp.length</span><br><span class="line">    &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">        nodes = &#123;</span><br><span class="line">            0: nodeOrSelector,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.operationClass = (classes) =&gt; &#123;</span><br><span class="line">        for (let key in classes) &#123;</span><br><span class="line">            let method = classes[key] ? &apos;add&apos; : &apos;remove&apos;</span><br><span class="line">            for (let i = 0, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">                nodes[i].classList[method](key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    nodes.text = (text) =&gt; &#123;</span><br><span class="line">        if (text === undefined) &#123;</span><br><span class="line">            let texts = []</span><br><span class="line">            for (let i = 0, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">                texts.push(nodes[i].textContent)</span><br><span class="line">            &#125;</span><br><span class="line">            return texts</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (let i = 0, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">                nodes[i].textContent = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>jQuery 就是将 otherNode 更名为 jQuery，当然 jQuery 的兼容性更好、功能更加丰富（DOM 操作、动画、AJAX操作等等），并且它使用了 prototype 。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/jQuery/">jQuery</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-11T12:04:06.000Z"><a href="/2018/01/11/JS系列 -- Function 浅析/">2018-01-11</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/11/JS系列 -- Function 浅析/">JS系列 -- Function 浅析</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>函数是一个可以执行代码的对象。每个函数都是 Function 类型的实例，并且都与其他引用类型一样具有属性和方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-4afc8efd99ed4324.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Function"></p>
<p>每个 Function 的实例的 <code>__proto__</code> 都指向了 Function.prototype(原型)，函数原型（Function.prototype）的 <code>__proto__</code> 指向了 Object.prototype(对象的原型)</p>
<h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><ol>
<li><p>函数声明</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name( param1[ , param2[, ...] ] )&#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>如果 <code>return</code> 省略，那么浏览器将自动添加 <code>return undefined</code></strong><br> <code>function</code> 是关键字，它只能用来声明函数，而 <code>var</code> 则可以用来声明7    种数据类型（number、string、boolean、null、undefined、symbol、    object）中的任意一种。</p>
</li>
<li><p>函数表达式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = function( param1[ , param2[, ...] ] )&#123;</span><br><span class="line">    return </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 匿名函数需要赋给变量，之后才能调用。<strong>这个匿名函数称为函数表达式</strong></p>
</li>
<li><p>混合式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fn = function name( param1[ , param2[, ...] ] )&#123;</span><br><span class="line">    return </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 混合式中，函数名 name 只在函数体内部有效，指代函数表达式本身，在函数体外部无效。</p>
</li>
<li><p>Function 构造函数<br> 最后一个参数被始终看成函数体，而前面的参数则枚举了新函数的参数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fn = new Function( &apos;param1&apos;[ , &apos;param2&apos;[,&apos; ...&apos;] ] , functionBoby )&#123;</span><br><span class="line">    return </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>例子：</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let n = 1;</span><br><span class="line">let fn = new Function( &apos;x&apos; , &apos;y&apos; , &apos;return x + &apos; + n + &apos; + y&apos; );</span><br><span class="line">fn( 1,2 )  //4，此时的 n 是1</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数（ES6）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（param1[ , param2[, ...] ]）=&gt; &#123; return  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><ul>
<li>parameters ==&gt; 形参，定义时的占位符</li>
<li>arguments ==&gt; 实参，调用时传入的参数</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>函数会在执行完 return 语句之后停止并立即退出，因此，位于 return 语句之后的任何代码都永远不会执行。</li>
<li>没有传递值的命名参数将自动被赋值 undefined</li>
<li>所有参数传递的都是值，不可能通过引用传递参数</li>
<li>验证函数，使用 <code>typeof xxx === &#39;function&#39;</code></li>
</ul>
<h1 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h1><ul>
<li>函数声明<br>  浏览器解析器会率先读取函数声明（<strong>声明前置</strong>），并使其在执行任何代码之前可用</li>
<li>函数表达式<br>  必须要等到浏览器解析器执行到它所在的代码行，才会被解析执行</li>
</ul>
<h1 id="声明前置"><a href="#声明前置" class="headerlink" title="声明前置"></a>声明前置</h1><p>先声明变量，后声明 function，如果 function 名字和 var 声明名字一样<br> function 优先。如果赋值就按照赋值的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-b685a2f72fd44407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="声明前置"></p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h3 id="自身-API"><a href="#自身-API" class="headerlink" title="自身 API"></a>自身 API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-03cb79b4dd1cd59d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自身属性 API"></p>
<ul>
<li><code>name</code> ==&gt; 返回函数实例的名称</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-43d062bc839e7d48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fn.name"></p>
<ul>
<li><code>length</code> ==&gt; 指明函数的<strong>形参</strong>个数</li>
</ul>
<h3 id="Function-prototype-API"><a href="#Function-prototype-API" class="headerlink" title="Function.prototype API"></a>Function.prototype API</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-b7e392157560ccdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Function.prototype API"></p>
<ul>
<li><p><code>call()</code> ==&gt; 调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)<br>  <strong>作用：</strong></p>
<ol>
<li>改变 this 值<br><img src="http://upload-images.jianshu.io/upload_images/9617841-248eb360eed5d5e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="改变 this 值"></li>
<li><p>操作参数</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(this, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p><strong>参数：</strong></p>
</li>
<li><p>this ：函数运行时的指定的 this 值。</p>
<ul>
<li><p><strong>非严格模式</strong>下，若 this 为 null 或者 undefined ，则 this 自动指向<strong>全局对象（global[ window ]）</strong>，同时值为原始值(数字，字符串，布尔值)的 this 会<strong>指向该原始值的自动包装对象</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-91e0f7d177fcb401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非严格模式"></p>
</li>
<li><p><strong>严格模式</strong>下，若 this 为 undefined ，则 <strong>this === undefined</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-8ed9e92d37439649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="严格模式"><br>此处 call 的时候指明了 this === 1，例子不明显，应该 fn.call()，此时便可以打印出 undefined</p>
</li>
</ul>
</li>
<li><p>arguments ：伪数组，元素为函数的参数</p>
<ul>
<li>函数中的参数在内部是用一个伪数组（<code>arguments</code>）来表示，在函数内部通过 <code>arguments</code> 对象来访问参数从而获取传递给函数的每一个参数。</li>
<li><code>arguments</code> 可以被用作被调用对象的所有未指定的参数。可以使用arguments来把所有的参数传递给被调用对象。 </li>
<li><code>arguments</code> 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。</li>
</ul>
</li>
</ol>
</li>
<li><p><code>apply()</code> ==&gt; 调用一个函数, 其具有一个指定的<code>this</code>值，以及作为一个数组（或<strong>类似数组的对象</strong>）提供的参数。<br>   <strong>作用：</strong>和 call() 一样</p>
<ol>
<li>改变 this 值</li>
<li><p>操作参数</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(this, arguments)</span><br></pre></td></tr></table></figure>
<p><strong>使用实例：</strong></p>
</li>
<li><p>实例1：<strong>不关心 this ，所以将 this 传为 null</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-ca8c95bbb5abd53b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apply 实例1"></p>
</li>
<li><p>实例2：<strong>关心 this ，this === arr1</strong><br><img src="http://upload-images.jianshu.io/upload_images/9617841-3b3a79c946e1e7c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Apply 实例2"></p>
</li>
</ol>
<p><strong>说明：<code>call()</code> 和 <code>apply()</code> 的区别</strong><br>  <code>apply()</code> 与 <code>call()</code> 作用相同，不同之处在于<strong>提供参数的方式</strong>。<br>  <code>apply()</code> 使用参数数组，<strong>可以将数组里的元素拆分传入参数</strong><br>  <code>call()</code> 使用一组参数列表，一个一个传递参数<br>  <code>apply</code>可以使用数组字面量，也可以使用 <code>arguments</code>对    象， <code>arguments</code> 是一个函数的局部变量。 </p>
</li>
</ul>
<ul>
<li><p><code>bind()</code> ==&gt; 创建一个新的函数, 当被调用时，将其 <code>this</code> 关键字设置为提供的值，<strong>返回新创建的函数</strong>。在调用新函数时，在任何提供之前提供一个给定的参数序列。<br>  <strong>作用：</strong></p>
<ol>
<li>切换上下文（this）</li>
<li><p>科里化</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind( this [ , arg1 [ , arg2 [ , ... ] ] ] )</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<pre><code>**使用实例：**
1. 实例1：**基本用法**
![bind 基本用法](http://upload-images.jianshu.io/upload_images/9617841-f825f2fa123c4db2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
2. 实例2：**实际应用**
![bind 实际应用](http://upload-images.jianshu.io/upload_images/9617841-71e4fff179f8a3f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
3. 实例3：**利用 this + apply 实现 bind**
![重构 bind](http://upload-images.jianshu.io/upload_images/9617841-ca4c2e02d2132d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><ol>
<li><p>创建一个新对象 obj ，对象 <code>__proto__</code> 指向构造函数的 <code>prototype</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象. __proto__ === 构造函数.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 call()/apply()/bind()</p>
</li>
</ol>
<h1 id="Call-Stack（调用栈）"><a href="#Call-Stack（调用栈）" class="headerlink" title="Call Stack（调用栈）"></a>Call Stack（调用栈）</h1><p>栈是一种数据结构，特点是<strong>先进后出</strong>，js 代码执行时都遵循 Call Stack 的规则。如果压栈太多会导致错误（Stack Overflow[ 栈溢出 ]）</p>
<h1 id="作用域-和-作用域链"><a href="#作用域-和-作用域链" class="headerlink" title="作用域 和 作用域链"></a>作用域 和 作用域链</h1><p>scope（范围、视野、眼界）</p>
<p><strong>如果在函数作用域中没有写 <code>var</code> 直接写 <code>a = 3</code></strong></p>
<pre><code>1. 优先赋值
2. 沿着作用域链寻找 a 的声明
3. 若作用域链中没有 a 的声明，则声明全局变量并赋值
</code></pre><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>将作用域链中首先要做<strong>变量提升</strong></p>
<h6 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h6><pre><code>var a = 1;
function fn(){
    console.log( a );
    var a = 2;
}
fn.call();  //  a === undefined
</code></pre><h6 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h6><pre><code>var a = 1;
function fn1(){
    console.log( a );  //  a === undefined
    var a = 2;
    fn2.call();
}
function fn2(){
    console.log( a );  //  a === 1
}
fn1.call();
</code></pre><h6 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h6><pre><code>var obj = { name: &apos; obj &apos; }
function fn1(){
    function fn2(){
        console.log( this );   // this === window 
    }
    fn2.call();
}
fn1.call( obj );
</code></pre><h6 id="例子4："><a href="#例子4：" class="headerlink" title="例子4："></a>例子4：</h6><pre><code>var liTags = document.querySelectAll( &apos; li &apos; );
for( let i = 0, len = liTags.length; i &lt; len; i++ ){
    liTags[ i ].onclick = function(){
        console.log( i )  // 打印出的 i 都是最后的数字
    }
}
</code></pre><h1 id="this-值"><a href="#this-值" class="headerlink" title="this 值"></a>this 值</h1><p>this 的调用主要有两种方式，一种是函数（function），另一种是作为对象的方法（methods）</p>
<h3 id="判断-this-值就看函数怎么被调用，之后转化为-call-形式"><a href="#判断-this-值就看函数怎么被调用，之后转化为-call-形式" class="headerlink" title="判断 this 值就看函数怎么被调用，之后转化为 call 形式"></a>判断 this 值就看函数怎么被调用，之后转化为 call 形式</h3><h6 id="例子1：作为对象的方法调用"><a href="#例子1：作为对象的方法调用" class="headerlink" title="例子1：作为对象的方法调用"></a>例子1：作为对象的方法调用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    a: &apos;a&apos;,</span><br><span class="line">    fn: fn</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()  // this === obj</span><br></pre></td></tr></table></figure>
<h6 id="例子2：作为对象属性的深层次嵌套"><a href="#例子2：作为对象属性的深层次嵌套" class="headerlink" title="例子2：作为对象属性的深层次嵌套"></a>例子2：作为对象属性的深层次嵌套</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    a: &apos;a&apos;,</span><br><span class="line">    wrapper: &#123;</span><br><span class="line">        b: &apos;b&apos;,</span><br><span class="line">        fn: fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.wrapper.fn()  // this === &#123; b: &apos;b&apos;, fn: fn &#125; === obj.wrapper</span><br></pre></td></tr></table></figure>
<h6 id="例子3：-1"><a href="#例子3：-1" class="headerlink" title="例子3："></a>例子3：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: &apos;a&apos;,</span><br><span class="line">    fn () &#123;</span><br><span class="line">        console.log(fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function fncb(cb)&#123;</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br><span class="line">fncb(obj.fn)  // this === 全局变量</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>如果一个函数使用了它范围外的值，那么这个函数 + 这个变量就叫做闭包。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-19f3603e86a9f96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="声明变量"></p>
<h1 id="立即调用函数"><a href="#立即调用函数" class="headerlink" title="立即调用函数"></a>立即调用函数</h1><p>window下有很多全局属性<br><img src="http://upload-images.jianshu.io/upload_images/9617841-e883bce645e9a47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="window"><br>当定义变量的时候，有可能不小心覆盖了 window 的全局属性，为了避免覆盖 window 上的属性，可以：</p>
<ol>
<li>不用全局属性</li>
<li>用局部变量</li>
<li><p>使用立即调用函数，从而使用局部变量</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123; &#125;.call()</span><br><span class="line">() =&gt; &#123; &#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是如果像上述写法，浏览器会报错，所以要这么写：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123; &#125;.call() )</span><br><span class="line">(() =&gt; &#123; &#125; ).call()</span><br><span class="line">-() =&gt; &#123; &#125;.call()</span><br><span class="line">+() =&gt; &#123; &#125;.call() </span><br><span class="line">！() =&gt; &#123; &#125;.call()</span><br><span class="line">～() =&gt; &#123; &#125;.call()</span><br><span class="line">&#123; let  &#125;  // let 作用域在块级作用域中</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h1><ol>
<li><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明</p>
</li>
<li><p>递归：函数调用自身</p>
</li>
<li><p>JavaScript将函数看做一种值，函数只是一个可以执行的值</p>
</li>
<li><p>当<strong>函数表达式</strong>和<strong>函数声明</strong>同时有的时候<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-f712689a1b6da638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="function"></p>
</li>
<li><p>不能在条件语句中声明函数（变量提升，是的 if 无效）</p>
</li>
<li><p><strong>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</strong></p>
</li>
<li><p>参数<strong>传值传递</strong>，内存中体现<strong>原始值的拷贝</strong>。<br>参数<strong>传址传递</strong>（复杂类型的值），内存中体现<strong>原始值的地址</strong>，唯一一种不改变参数的是<strong>替换掉整个参数，这时不会影响到原始值</strong>（添加属性或方法会影响到原始值）</p>
</li>
<li><p>如果有同名的参数，则取最后出现的那个值</p>
</li>
<li><p>eval命令的作用是，<strong>将字符串当作语句执行</strong>。eval没有自己的作用域，都<strong>在当前作用域内执行</strong>，因此可能会修改当前作用域的变量的值，造成安全问题。为了防止这种风险，JavaScript 规定，如果使用<strong>严格模式</strong>，<strong>eval内部声明的变量，不会影响到外部作用域</strong></p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-11T11:58:39.000Z"><a href="/2018/01/11/Tween-js/">2018-01-11</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/11/Tween-js/">Tween.js</a></h1>
  

    </header>
    <div class="entry">
      
        <p>tweenjs 是使用 JavaScript 中的一个简单的补间动画库，支持数字、对象的属性和 CSS 样式属性的赋值。</p>
<p>tweenjs 以平滑的方式修改元素的属性值，需要传递给 tween 要修改的值、动画结束时的最终值和动画花费时间（duration），之后 tween 引擎就可以计算从开始动画点到结束动画点之间值，从而产生平滑的动画效果。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul>
<li><p>tweenjs CDN </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.1.1/Tween.min.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>tweenjs <a href="https://pan.baidu.com/s/1nvoXev3" target="_blank" rel="noopener">下载到本地</a>，密码是 <code>ywoq</code>。</p>
</li>
<li><p><a href="https://github.com/tweenjs/tween.js" target="_blank" rel="noopener">tweenjs github</a></p>
</li>
<li><p>tweenjs 实例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var box = document.createElement(&apos;div&apos;);</span><br><span class="line">box.style.setProperty(&apos;background-color&apos;, &apos;#008800&apos;);</span><br><span class="line">box.style.setProperty(&apos;width&apos;, &apos;100px&apos;);</span><br><span class="line">box.style.setProperty(&apos;height&apos;, &apos;100px&apos;);</span><br><span class="line">document.body.appendChild(box);</span><br><span class="line"></span><br><span class="line">function animate(time) &#123;</span><br><span class="line">    requestAnimationFrame(animate);</span><br><span class="line">    TWEEN.update(time);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br><span class="line"></span><br><span class="line">var coords = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">var tween = new TWEEN.Tween(coords) </span><br><span class="line">        .to(&#123; x: 300, y: 200 &#125;, 1000) </span><br><span class="line">        .easing(TWEEN.Easing.Quadratic.Out) </span><br><span class="line">        .onUpdate(function() &#123; </span><br><span class="line">            box.style.setProperty(&apos;transform&apos;, &apos;translate(&apos; + coords.x + &apos;px, &apos;     + coords.y + &apos;px)&apos;);</span><br><span class="line">        &#125;)</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h1><ol>
<li><p>假设有一个对象 position ，它的坐标为 x 和 y</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var position = &#123; x: 100, y: 0 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>改变 x 的值从 100 到 200 ，持续时间为 1s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var tween = new TWEEN.Tween(position)</span><br><span class="line">tween.to(&#123;x: 200&#125;, 1000)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 tween 对象后，激活它，从而让它开始动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了平滑的动画效果，需要在同一个循环动画中调用 TWEEN.update 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animate();</span><br><span class="line">function animate()&#123;</span><br><span class="line">    requestAnimationFrame(animate);</span><br><span class="line">    TWEEN.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个动作将会更新所有被激活的 tweens ，在 1s 内 position.x 将变为 200 。</p>
<ol>
<li>可以使用 onUpdate 回调函数将结果打印到控制台上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tween.onUpdate(function()&#123;</span><br><span class="line">    console.log( this.x );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个函数在每次 tween 被更新时都会被调用</p>
<h1 id="tweenjs-动画"><a href="#tweenjs-动画" class="headerlink" title="tweenjs 动画"></a>tweenjs 动画</h1><p>Tween.js 本身不会运行，你需要通过 update 方法明确告诉它什么时候开始运行，推荐在动画主循环中使用该动画，可以调用 <code>requestAnimationFrame</code> 方法来获得良好的图像性能</p>
<p>使用无参数的调用方法，update 将明确当前时间。也可以为 update 方法法明确一个时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TWEEN.update(100);</span><br></pre></td></tr></table></figure></p>
<p>update 的时间为 100毫秒 ，可以使用这种方法来明确代码中所有随时间变化的函数。</p>
<h1 id="控制-tween-动画"><a href="#控制-tween-动画" class="headerlink" title="控制 tween 动画"></a>控制 tween 动画</h1><ul>
<li><p><code>start</code> 和 <code>stop</code> ==&gt; <code>Tween.start</code> 和 <code>Tween.stop</code> 分别用来控制 tween 动画的开始和结束<br>对于已经结束和没有开始的动画，Tween.stop 方法不起作用。 Tween.start 可以方法接收一个时间参数，若使用了该参数，tween 动画将在延迟该时间数后才开始动画，否则他将立刻开始动画。</p>
</li>
<li><p><code>update</code> ==&gt; 通过 <code>TWEEN.update</code> 方法执行动画的更新</p>
</li>
<li><p><code>chain</code> ==&gt; 制作多个多行，例如一个动画在另一个动画结束后开始，可以通过 <code>chain</code> 来实现</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tweenA.chain(tweenB);  //tweenB 在 tweenA 之后开始动画，故可以制作一个无线循环的动画</span><br><span class="line">tweenB.chain(tweenA);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>repeat</code> ==&gt; 制作循环动画，优于 <code>chain</code>，接收一个用于描述循环次数的参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tween.repeat(10);</span><br><span class="line">tween.repeat(infinity);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>delay</code> ==&gt; 用于控制动画之间的延迟</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tween.delay(1000);</span><br><span class="line">tween.start()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>可以在每次 tween 循环周期的指定时间点调用自定义的函数</p>
<ul>
<li><code>onStart</code> ==&gt; tween 动画开始前的回调函数</li>
<li><code>onStop</code> ==&gt; tween 动画结束后的回调函数</li>
<li><code>onUpdate</code> ==&gt; 在 tween 动画每次更新后执行</li>
<li><code>onComplete</code> ==&gt; 在 tween 动画全部结束后执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var tween = new TWEEN.Tween(&#123;</span><br><span class="line"></span><br><span class="line">&#125;).to(&#123;</span><br><span class="line"></span><br><span class="line">&#125;).onStart(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;).onUpdate(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="动画运动算法（缓动函数）easing函数"><a href="#动画运动算法（缓动函数）easing函数" class="headerlink" title="动画运动算法（缓动函数）easing函数"></a>动画运动算法（缓动函数）easing函数</h1><ul>
<li>Linear ==&gt; 线性匀速运动效果</li>
<li>Quadratic ==&gt; 二次方的缓动（t^2）</li>
<li>Cubic ==&gt; 三次方的缓动（）</li>
<li>Quartic ==&gt; 四次方的缓动（）</li>
<li>Quintic ==&gt; 五次方的缓动</li>
<li>Sinusoidal ==&gt; 正弦曲线的缓动（）</li>
<li>Exponential ==&gt; 指数曲线的缓动（）</li>
<li>Circular ==&gt; 圆形曲线的缓动（）</li>
<li>Elastic ==&gt; 指数衰减的正弦曲线缓动（）</li>
<li>Back ==&gt; 超过范围的三次方的缓动</li>
<li>Bounce ==&gt; 指数衰减的反弹缓动</li>
</ul>
<h1 id="缓动方式（效果）easing类型"><a href="#缓动方式（效果）easing类型" class="headerlink" title="缓动方式（效果）easing类型"></a>缓动方式（效果）easing类型</h1><ul>
<li>easeIn（In） ==&gt; 加速，先慢后快</li>
<li>easeOut（Out） ==&gt; 减速，先快后慢</li>
<li>easeInOut（InOut） ==&gt; 前半段加速，后半段减速</li>
</ul>
<h1 id="使用公式"><a href="#使用公式" class="headerlink" title="使用公式"></a>使用公式</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.easing(TWEEN.Easing.easing函数.easing类型)</span><br></pre></td></tr></table></figure>
<h1 id="tweenjs-源码"><a href="#tweenjs-源码" class="headerlink" title="tweenjs 源码"></a>tweenjs 源码</h1><p><img src="http://upload-images.jianshu.io/upload_images/9617841-82e90227e99697b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-8846f1fe98dec1d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制动画方法"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-5db818a1c9c6e0f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓动函数"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-c9678e2fab0b0c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/Plugin/">Plugin</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-10T04:56:16.000Z"><a href="/2018/01/10/JS系列 -- 基本包装类型/">2018-01-10</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/10/JS系列 -- 基本包装类型/">JS系列 -- 基本包装类型</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ECMAScript 提供了 3 个特殊的引用类型：Boolean()  Number()  String() ，以便于操作基本类型值。</p>
<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>当创建基本包装类型时，相对应的变量会有 <strong>proto</strong> 的属性，此属性是基本包装类型指向 Object 类型的 prototype 。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-c47b07b10819e131.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本包装类型"></p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-4911258278ef065e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本包装类型 Boolean"></p>
<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><ul>
<li>valueof() ==&gt; 返回基本类型值 true 或 false (重写)</li>
<li>toString() ==&gt; 返回字符串 ‘true’ 和 ‘false’ (重写)</li>
</ul>
<p><strong>套路：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f1 = false;</span><br><span class="line">var f2 = new Boolean(false);</span><br><span class="line">if(f1)&#123;console.log(1)&#125; //不打印</span><br><span class="line">if(f2)&#123;console.log(2)&#125; //打印2，因为在调用 f2 的时候，f2 对应的包装类型是对象，所有的对象都是真值。</span><br></pre></td></tr></table></figure></p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-6e664f59886709f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本包装类型 Number"></p>
<h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul>
<li>valueof() ==&gt; 返回对象表示的基本类型的数值 （重写）</li>
<li>toString() ==&gt; 返回字符串形式的数值 （重写）</li>
<li>toLocaleString() ==&gt; 返回字符串形式的数值 （重写）</li>
<li>toFixed() ==&gt; 按照指定的小数位返回数值的字符串表示，参数为小数位数</li>
<li>toExponential() ==&gt; 返回以指数表示法表示的数值的字符串形式，参数为指定输出结果中的小数位数</li>
<li>toPrecision() ==&gt; 可能返回固定大小格式，也可能返回指数格式；具体规则看哪种格式更加合适，参数为表示数值的所有数字的位数（不包括指数部分）。</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p><img src="http://upload-images.jianshu.io/upload_images/9617841-5c889bdc59874e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本包装类型 String"></p>
<h5 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h5><ul>
<li><p>length ==&gt; 属性，表示字符串中包含多少个字符</p>
</li>
<li><p>valueof()  ==&gt; 返回对象所表示的基本字符串值</p>
</li>
<li><p>toLocaleString() ==&gt; 返回对象所表示的基本字符串值</p>
</li>
<li><p>toString() ==&gt; 返回对象所表示的基本字符串值</p>
</li>
<li><p>chatAt() ==&gt; 以单字符字符串的形式返回给定位置的那个字符，参数为指定位置</p>
</li>
<li><p>charCodeAt() ==&gt; 以字符编码的形式返回给定位置的那个字符，参数为指定位置</p>
</li>
<li><p>concat() ==&gt; 将一个或多个字符串拼接起来，返回拼接得到的新字符串，可以接受任意多个参数（实践中可以使用加号操作符）</p>
</li>
<li><p>slice() ==&gt; 返回被操作字符串的一个<strong>子字符串</strong>，接受一个或者两个参数，<strong>第一个参数</strong>指定子字符串的<strong>开始位置</strong>，<strong>第二个参数</strong>（在指定的情况下）表示子字符串的<strong>结束位置</strong>，<strong>[ 开始位置，结束位置 )</strong>。如果第二参数未指定，一直到字符串的结束为止。如果传入的<strong>参数是负值</strong>，将传入的负值<strong>与字符串的长度相加</strong>。</p>
</li>
<li><p>substr() ==&gt; 返回被操作字符串的一个<strong>子字符串</strong>，接受一个或者两个参数，<strong>第一个参数</strong>指定子字符串的<strong>开始位置</strong>，<strong>第二个参数</strong>（在指定的情况下）表示子字符串的<strong>结束位置</strong>，<strong>[ 开始位置，结束位置 )</strong>。如果第二参数未指定，一直到字符串的结束为止。如果传入的<strong>参数是负值</strong>，将负的第一个参数加上字符串的长度，将负的第二个参数转换为0。</p>
</li>
<li><p>substring() ==&gt; 返回被操作字符串的一个<strong>子字符串</strong>，接受一个或者两个参数，<strong>第一个参数</strong>指定子字符串的<strong>开始位置</strong>，<strong>第二个参数</strong>（在指定的情况下）表示子字符串返回的个数，<strong>[ 开始位置，个数 )</strong>。如果第二参数未指定，一直到字符串的结束为止。如果传入的<strong>参数是负值</strong>，将所有负值转换为0。</p>
</li>
<li><p>indexOf() ==&gt; 在一个字符串中从前向后搜索给定的子字符串，返回子字符串的位置，如果没有找到该位置，则返回 -1，接受一个或者两个参数，第一个参数表示指定的字符串，第二个参数表示从字符串中的那个位置开始搜索。</p>
</li>
<li><p>lastIndexOf() ==&gt; 在一个字符串中从后向前搜索给定的子字符串，返回子字符串的位置，如果没有找到该位置，则返回 -1，接受一个或者两个参数，第一个参数表示指定的字符串，第二个参数表示从字符串中的那个位置开始搜索。</p>
</li>
<li><p>trim() ==&gt; 创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
</li>
<li><p>toLowerCase() ==&gt; 字符串大小写转换</p>
</li>
<li><p>toLocaleLowerCase() ==&gt; 字符串大小写转换</p>
</li>
<li><p>toUpperCase() ==&gt; 字符串大小写转换</p>
</li>
<li><p>toLocalUpperCase() ==&gt; 字符串大小写转换</p>
</li>
<li><p>match() ==&gt; 在字符串中匹配模式，接受一个参数，正则或者 RegExp 对象。</p>
</li>
<li><p>search() ==&gt; 在字符串中从前向后查找模式，返回字符串中第一个匹配项的索引，如果没有找到匹配项，则返回 -1，接受一个参数，正则或者 RegExp 对象。</p>
</li>
<li><p>replace() ==&gt; 替换子字符串，接受两个参数，第一个参数可以是一个 RegExp 对象或者一个字符串，第二个参数可以是一个字符串或者一个函数</p>
</li>
<li><p>split() ==&gt; 基于指定的分隔符将一个字符串分割成多个字符串，并将结果放在一个数组中，接受一个或两个参数，第一个参数表示分隔符，第二个参数表示数组的长度。</p>
</li>
</ul>
<h5 id="当在读取模式中访问-Boolean-Number-和-String-类型时，后台会自动完成"><a href="#当在读取模式中访问-Boolean-Number-和-String-类型时，后台会自动完成" class="headerlink" title="当在读取模式中访问 Boolean Number 和 String 类型时，后台会自动完成"></a>当在<strong>读取</strong>模式中访问 Boolean Number 和 String 类型时，后台会自动完成</h5><ol>
<li>创建相应的基本类型的一个实例 <strong>( var temp = new 基本包装类型; )</strong></li>
<li>在实例上调用制定的方法 <strong>( var 变量 = temp.方法; )</strong></li>
<li>销毁这个实例 <strong>( temp = null; )</strong></li>
</ol>
<h1 id="基本类型-和-基本包装类型-区别"><a href="#基本类型-和-基本包装类型-区别" class="headerlink" title="基本类型 和 基本包装类型 区别"></a>基本类型 和 基本包装类型 区别</h1><p>基本类型 和 基本包装类型 区别在于<strong>存储的路径</strong></p>
<ul>
<li><p>基本类型存储在 <strong>Stack(栈内存)</strong> 中</p>
</li>
<li><p>基本包装类型在 <strong>Stack(栈内存) 存储一个地址</strong>，之后对应在 <strong>Heap(堆内存) 中的一个对象</strong>，其中有很多方法，可以进行操作数据。</p>
</li>
<li><p>例子：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var n1 = 1;</span><br><span class="line">var n2 = new Number(1);</span><br></pre></td></tr></table></figure>
<p>  两者区别在于：</p>
<ul>
<li>n1 类型是 Number(基本数据类型) ，直接储存在 Stack(栈内存) 中</li>
<li>n2 类型是<strong>基本包装类型</strong>，在 Stack(栈内存) 存储一个地址，之后    对应在 Heap(堆内存) 中的一个对象，其中有很多方法，可以进行操作数据。</li>
</ul>
</li>
</ul>
<h1 id="引用类型-和-基本包装类型-区别"><a href="#引用类型-和-基本包装类型-区别" class="headerlink" title="引用类型 和 基本包装类型 区别"></a>引用类型 和 基本包装类型 区别</h1><p>引用类型 和 基本包装类型 区别在于<strong>对象的生存期</strong></p>
<ul>
<li><p>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中</p>
</li>
<li><p>自动创建的基本包装类型的对象，只存在与一行代码的执行瞬间，然后立即被销毁</p>
</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript/">JavaScript</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  

  <nav id="pagination">
  
    <a href="/archives/2018/01/page/2/" class="alignleft prev">Vorherige Seite</a>
  
  
    <a href="/archives/2018/01/page/4/" class="alignright next">Nächste Seite</a>
  
  <div class="clearfix"></div>
</nav>


</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>3</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>4</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
