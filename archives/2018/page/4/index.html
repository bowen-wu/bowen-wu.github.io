<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | Archives: 2018 | 吴博文</title>
  <meta name="author" content="吴博文">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="吴博文"/>

  
    <meta property="og:image" content=""/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="canonical" href="http://yoursite.com/archives/2018/page/4/index.html" />
  <link rel="alternate" href="/atom.xml" title="吴博文" type="application/atom+xml">
  
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-45991394-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="blog-header">
  <h1><a href="/">吴博文</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="blog-nav">
  <ul>
    
      <li><a href="/">首页/Home</a></li>
    
      <li><a href="/archives">归档/Archives</a></li>
    
      <li><a href="/about">关于/About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    
      <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2018</h2>
<p></p>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-22T14:13:10.000Z"><a href="/2018/01/22/JS进阶 -- MVC 思想/">2018-01-22</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/22/JS进阶 -- MVC 思想/">JS进阶 -- MVC 思想</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MVC 是一种思想，它会让我们写代码时更加简洁、高效、模块化，了解这种方法对于前端程序员来说是很有必要的。首先说明下 MVC 代表的含义：</p>
<ul>
<li>M ==&gt; Model ==&gt; 模型</li>
<li>V ==&gt; View ==&gt; 视图</li>
<li>C ==&gt; Controller ==&gt; 控制器</li>
</ul>
<h1 id="MVC-各自作用"><a href="#MVC-各自作用" class="headerlink" title="MVC 各自作用"></a>MVC 各自作用</h1><p>MVC 主要是按功能划分模块</p>
<ol>
<li>view：js 代码所操纵的视图（HTML），负责显示给用户和通知 controller（控制器）</li>
<li><p>Model：view（视图）所需要的所有的数据操作,包括：</p>
<ul>
<li>初始化数据</li>
<li>读取数据</li>
<li><p>存入数据</p>
<p>负责和向 server（服务器）请求数据和响应 server（服务器） </p>
</li>
</ul>
</li>
<li><p>controller：所有的逻辑操作，负责监控和更新 view（视图） + 调用和接收 model（数据） </p>
</li>
</ol>
<h1 id="MVC-使用技术点"><a href="#MVC-使用技术点" class="headerlink" title="MVC 使用技术点"></a>MVC 使用技术点</h1><ol>
<li><p>立即执行函数，<a href="https://www.jianshu.com/p/e8ad9fdf8e07" target="_blank" rel="noopener">这里</a>有所有的立即执行函数的写法，但是这里推荐大家使用 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;&#125;.call()</span><br></pre></td></tr></table></figure>
<p> 立即执行函数避免了我们是用全局变量，隔离作用域，从而达到了使用局部变量的目的</p>
</li>
<li><p>闭包<br> 闭包就是如果一个函数使用了它范围外的值，那么这个函数 + 这个变量就叫做闭包<br> 闭包使得模块之间可以进行相互访问。具体实现：<br> <img src="http://upload-images.jianshu.io/upload_images/9617841-10ee3cec1d8d6750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包 + 操作局部变量"></p>
<ul>
<li>函数 fn 中局部变量 obj 和 return 的函数构成了闭包</li>
<li>return 的函数便是接口，可以供外部调用，从而来操纵局部变量 obj</li>
<li><strong>外部除了使用函数 fn 的接口，没有任何其他方法可以访问到局部变量 obj</strong></li>
</ul>
</li>
<li><p>全局变量<br>模块与模块之间是在不同的 js 文件中，例如模块2想去操纵模块1的数据，通过上述方式显然是不够的，那么只能退而求其次，使用全局变量。具体实现：<br><img src="http://upload-images.jianshu.io/upload_images/9617841-9012bcc7bdc3e5fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全局变量"><br>通过使用全局变量保存了匿名函数的地址，从而全局都可以使用这个全局属性</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上3种技术点的结合 ==&gt; <strong>立即执行函数 + 闭包 + 全局变量</strong> 实现了 MVC 中 Controller（控制器） 的相应需求，从而让前端更好的使用 MVC 思想</p>
<h4 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h4><ol>
<li>this 的使用，在 MVC 中要着重使用 this </li>
<li>箭头函数，其实在 MVC 中使用箭头函数，主要就是为了 this ，原因在于<strong>箭头函数内外 this 不变</strong></li>
<li>HTML 中每一块都是一个 view ，当我们为 HTML 分块的时候，是可以嵌套的，所以我们的 view 也是可以嵌套的</li>
</ol>
<h1 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    let view = 操纵的 HTML 模块</span><br><span class="line">    let model = &#123;</span><br><span class="line">        init: function()&#123;&#125;,</span><br><span class="line">        fetch: function()&#123;&#125;  // 注意此处最好返回 Promise 对象</span><br><span class="line">        save: function()&#123;&#125;  // 注意此处最好返回 Promise 对象</span><br><span class="line">    &#125;</span><br><span class="line">    let controller = &#123;</span><br><span class="line">        view = null,</span><br><span class="line">        model = null,</span><br><span class="line">        ...... = null,</span><br><span class="line">        init: function()&#123;</span><br><span class="line">            this.view = view</span><br><span class="line">            this.model = model</span><br><span class="line">            ......</span><br><span class="line">            this.bindEvents()</span><br><span class="line">        &#125;,</span><br><span class="line">        bindEvents: function()&#123;</span><br><span class="line">            // 绑定事件，与绑定事件无关的放在 controller 属性上</span><br><span class="line">        &#125;,</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    controller.init( controller,model )</span><br><span class="line">    //controller.init.call( controller,view, model )</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p><a href="https://github.com/bowen-wu/resume/blob/master/js/leaveMessage-system-database.js" target="_blank" rel="noopener">代码示例</a></p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/JavaScript-进阶/">JavaScript 进阶</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T09:10:21.000Z"><a href="/2018/01/20/HTTP系列 -- AJAX 进阶/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- AJAX 进阶/">HTTP系列 -- AJAX 进阶</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/master/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">相关代码链接</a></p>
<h1 id="AJAX-设置响应-和-获取请求"><a href="#AJAX-设置响应-和-获取请求" class="headerlink" title="AJAX 设置响应 和 获取请求"></a>AJAX 设置响应 和 获取请求</h1><h3 id="AJAX-设置请求-header"><a href="#AJAX-设置请求-header" class="headerlink" title="AJAX 设置请求 header"></a>AJAX 设置请求 header</h3><p>第一部分：<code>request.open( &#39;POST&#39;, &#39;http://www.baidu.com/search&#39; )</code><br>第二部分：<code>request.setRequestHeader( hander, value )</code><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setRequestHeader( &apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos; )</span><br><span class="line">request.setRequestHeader( &apos;who&apos;, &apos;bowen&apos; )</span><br></pre></td></tr></table></figure></p>
<p>第四部分：<code>request.send( &#39;a=1&amp;b=2&#39; )</code></p>
<h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. POST /search HTTP/1.1</span><br><span class="line">2. Host: www.baidu.com</span><br><span class="line">   Content-Type: application/x-www-form-urlencoded</span><br><span class="line">   who: bowen</span><br><span class="line">   Content-Length: </span><br><span class="line">   Cookie: </span><br><span class="line">3. </span><br><span class="line">4. a=1&amp;b=2</span><br></pre></td></tr></table></figure>
<h3 id="AJAX-获取响应-header"><a href="#AJAX-获取响应-header" class="headerlink" title="AJAX 获取响应 header"></a>AJAX 获取响应 header</h3><p>第一部分：<code>request.status</code> 和 <code>request.statusText</code><br>第二部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.getResponseHeader( headerName ) </span><br><span class="line">request.getAllResponseHeaders()</span><br></pre></td></tr></table></figure></p>
<p>第四部分：<code>request.responseText</code></p>
<h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. HTTP/1.1 200 ok</span><br><span class="line">2. key: value</span><br><span class="line">3. </span><br><span class="line">4. 数据</span><br></pre></td></tr></table></figure>
<h3 id="Node-js（后端）设置响应-header"><a href="#Node-js（后端）设置响应-header" class="headerlink" title="Node.js（后端）设置响应 header"></a>Node.js（后端）设置响应 header</h3><p><a href="https://bowen-wu.github.io/2018/01/19/HTTP%E7%B3%BB%E5%88%97-Node-js/" target="_blank" rel="noopener">详解</a></p>
<h1 id="callback（回调）"><a href="#callback（回调）" class="headerlink" title="callback（回调）"></a>callback（回调）</h1><p>callback 就是一个回调函数，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/9617841-580ea1a7bb64c8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callback 示例"></p>
<ol>
<li>给 window 添加一个方法 fn123 ，这个方法接受一个对象 options 。</li>
<li>使用 window 下的方法 fn123 ，并传入一个对象，这个对象有一个方法 fn456 ，它是一个函数。</li>
<li>window 下的 fn123 接受到对象后将调用 fn456，将其 call back</li>
<li>fn456 中接受的 this 就是 window 下的方法中 call 时传的第一个参数，x 就是 call 时传的第二个参数</li>
</ol>
<h1 id="实现-jQuery-ajax"><a href="#实现-jQuery-ajax" class="headerlink" title="实现 jQuery.ajax"></a>实现 jQuery.ajax</h1><ol>
<li><p>首先回顾下 <a href="https://www.jianshu.com/p/3eb5f1c7937e" target="_blank" rel="noopener">window.jQuery</a></p>
</li>
<li><p>将 AJAX-基础 的<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/master/AJAX-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">代码</a> 进行封装，封装为 window.jQuery.ajax，<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/da549df5393a229f1d3e878d27b491755e6e99bb" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>将封装的 window.jQuery.ajax 进行代码优化（给参数命名）。由于传入参数过多，将其参数设置为有结构的数据 ==&gt; 对象，<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/80c6de9166b9efb60b2c34a5fb115aa9d0f61fcf" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>实现传入不定个参数的优化。既可以传入一个对象，也可以传入 url + 对象。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/3ca84506652fa89c4f3854da77420d7f6094e240" target="_blank" rel="noopener">代码地址</a>。此时由于要使用 arguments ，所以不能使用箭头函数。</p>
</li>
<li><p>优化代码，使用 ES6 解构赋值达到优化代码的目的，并增加 request.setRequestHeader() 功能。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/5118accb4c21f0ed2b8da6f2c5677867d238bf51" target="_blank" rel="noopener">代码地址</a>。</p>
</li>
<li><p>如果不实现传入不定个参数，还可以进一步使用 ES6 解构赋值优化。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/88436fc2378cec3a814a96cc3260a5de133038da/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>使用 Promise 规范进行优化，<code>return new Promise(function(resolve,reject){})</code>，成功 === 调用 resolve，失败 === 调用 reject，之后在调用时使用 <code>.then</code> 方法。<a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/tree/1ea0e7728b98f008f077e7b7f77b2eb80ec77e6b/AJAX-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">代码地址</a></p>
</li>
<li><p>Promise 实现原理</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.Promise = function(fn)&#123;</span><br><span class="line">  // ......</span><br><span class="line">   return &#123;</span><br><span class="line">        then: function()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T09:01:25.000Z"><a href="/2018/01/20/HTTP系列 -- AJAX 基础/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- AJAX 基础/">HTTP系列 -- AJAX 基础</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/server-Node.js-demo/tree/master/AJAX-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">参考代码</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AJAX（Async JavaScript And XML）：异步 JavaScript 和XML，远程编程脚本，使 JavaScript 能够在 Web 服务器上运行的程序通信，它是一种无需重新加载整个网页的情况之下能够更新部分网页的技术。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>使用 XMLHttpRequest 发请求</li>
<li>服务器返回 XML / <strong>JSON</strong> 格式的<strong>字符串</strong></li>
<li>JS 解析 XML / <strong>JSON</strong>，并更新局部页面<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3>HTTP 的 path（路径）都是绝对路径</li>
</ol>
<h1 id="如何发送请求"><a href="#如何发送请求" class="headerlink" title="如何发送请求"></a>如何发送请求</h1><h3 id="form-表单"><a href="#form-表单" class="headerlink" title="form 表单"></a>form 表单</h3><p>使用 form 表单可以发请求，但是会刷新页面或新开页面<br>    <img src="http://upload-images.jianshu.io/upload_images/9617841-a4cd551b880d7edc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-fa120004a4c5d9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送请求"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-9f0cfec4a4ad3a6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送 GET 请求"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-13288ee474125f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="form 标签发送 POST 请求"></p>
<h3 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h3><p>使用 a 标签可以发 GET 请求，但是也会刷新页面或新开页面<br><img src="http://upload-images.jianshu.io/upload_images/9617841-f8081f7df640b734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-1b8aad5535592eed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 标签发送 GET 请求"></p>
<h3 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h3><p>使用 img 标签可以发 GET 请求，但是只能以图片的形式展示<br><img src="http://upload-images.jianshu.io/upload_images/9617841-419575e6ec290994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-78c17819094b4e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img 标签发送 GET 请求"></p>
<h3 id="link-标签"><a href="#link-标签" class="headerlink" title="link 标签"></a>link 标签</h3><p>使用 link 标签可以发 GET 请求，但是只能以 CSS、favicon 的形式展示<br><img src="http://upload-images.jianshu.io/upload_images/9617841-67c1f5fea5f0cd93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-396bbc64663e8d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link 标签发送 GET 请求"></p>
<h3 id="script-标签（JSONP）"><a href="#script-标签（JSONP）" class="headerlink" title="script 标签（JSONP）"></a>script 标签（JSONP）</h3><p>使用 script 标签可以发 GET 请求，但是只能以脚本的形式运行<br><img src="http://upload-images.jianshu.io/upload_images/9617841-b11d2c9d39d32347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="script 标签创建"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-16b27a15892f6486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="script 标签发送 GET 请求"></p>
<h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p><code>XMLHttpRequest</code> 是一个 API，它为客户端<strong>提供了在客户端和服务器之间传输数据的功能</strong>。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。<code>XMLHttpRequest</code> 在 <a href="https://developer.mozilla.org/zh-CN/docs/AJAX" target="_blank" rel="noopener">AJAX</a> 中被大量使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/9617841-15f0d81c590baedd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="挂载在 window 下的 XMLHttpRequest 对象"></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><ul>
<li>类型：function</li>
<li>JavaScript函数对象，当readyState属性改变时会调用它。</li>
</ul>
<h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>类型：Number<br>显示 XMLHttpRequest  代理当前所处的状态，值：</p>
<ul>
<li>0 ==&gt; 代理被创建，但尚未调用 open() 方法</li>
<li>1 ==&gt; open() 方法已经被调用</li>
<li>2 ==&gt; send() 方法已经被调用，并且头部和状态已经可获得</li>
<li>3 ==&gt; 下载中，requestText 属性已经包含部分数据</li>
<li>4 ==&gt; 下载操作以完成</li>
</ul>
<h5 id="responseText"><a href="#responseText" class="headerlink" title="responseText"></a>responseText</h5><ul>
<li>类型：String<br>响应的文本</li>
</ul>
<h5 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h5><p>设置响应类型，值：</p>
<ul>
<li>“” ==&gt; 字符串（默认值）</li>
<li>“arraybuffer”</li>
<li>“blob”</li>
<li>“document”</li>
<li>“json” ==&gt; JavaScript 对象，解析自服务器传递回来的JSON 字符串</li>
<li>“text” ==&gt; 字符串</li>
</ul>
<h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>请求的响应状态码<br><a href="https://www.jianshu.com/p/036df537e96d" target="_blank" rel="noopener">详见</a></p>
<h5 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h5><p>请求的响应状态信息,包含一个状态码和原因短语（”200 OK”） </p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h5 id="1-open"><a href="#1-open" class="headerlink" title="1. open()"></a>1. open()</h5><p>初始化一个请求。该方法用于JavaScript代码中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open( method, url, async )</span><br></pre></td></tr></table></figure></p>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>methos ==&gt; 请求所使用的HTTP方法</li>
<li>url ==&gt; 该请求所要访问的 URL / 路径</li>
<li>async ==&gt; 默认为true（异步），表示是否执行异步操作</li>
</ul>
<h5 id="2-setRequestHeader"><a href="#2-setRequestHeader" class="headerlink" title="2. setRequestHeader()"></a>2. setRequestHeader()</h5><p>给指定的HTTP请求头赋值.在这之前,你必须确认已经调用 <code>open()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open( &apos;POST&apos;, &apos;/xxx&apos; )</span><br><span class="line">request.setRequestHeader( header, value )</span><br></pre></td></tr></table></figure></p>
<p><strong>request.setRequestHeader( ‘Content-type’ , ‘application/x-www-form=urlcoded’ )</strong></p>
<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><ul>
<li>header ==&gt; 将要被赋值的请求头名称</li>
<li>value ==&gt; 给指定的请求头赋的值</li>
</ul>
<h5 id="3-send"><a href="#3-send" class="headerlink" title="3. send()"></a>3. send()</h5><p>发送请求。如果该请求是异步模式(默认)，该方法会立刻返回。相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回</p>
<h5 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders()"></a>getAllResponseHeaders()</h5><p>返回所有响应头信息(响应头名和值)，如果响应头还没接受,则返回null</p>
<h5 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader()"></a>getResponseHeader()</h5><p>返回指定的响应头的值，如果响应头还没被接受，或该响应头不存在，则返回null</p>
<h1 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h1><p><strong><code>JSON</code></strong>对象包含用于解析 JSON 的方法，并将值转换为 JSON。它不能被调用或者作为构造函数</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><p>解析一个JSON字符串，可选地转换生成的值及其属性，并返回值</p>
<h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p>返回与指定值相对应的一个JSON字符串，可选地仅包含某些属性或以用户定义的方式替换属性值</p>
<h1 id="原生-JavaScript-发送-AJAX-请求"><a href="#原生-JavaScript-发送-AJAX-请求" class="headerlink" title="原生 JavaScript 发送 AJAX 请求"></a>原生 JavaScript 发送 AJAX 请求</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest()</span><br><span class="line">//open() 方法有第三个参数，true 为异步（默认），false为同步</span><br><span class="line">request.open( &apos;GET&apos;, &apos;路径&apos; )   // 配置 request </span><br><span class="line"></span><br><span class="line">//request.open( &apos;POST&apos;, &apos;路径&apos; )  </span><br><span class="line">// 配置 request ，如果是 POST 方法，必须设置 setRequestHeader</span><br><span class="line">//request.setRequestHeader( &apos;Content-type&apos; , &apos;application/x-www-form-urlcoded&apos; )</span><br><span class="line"></span><br><span class="line">request.send()</span><br><span class="line">request.onreadystatechange = () =&gt;&#123;</span><br><span class="line">    if( request.readyState === 4 )&#123; //请求响应都完毕了</span><br><span class="line">        if( request.status &gt;= 200 &amp;&amp; request.status &lt; 300 )&#123;</span><br><span class="line">            console.log( &apos;说明请求成功&apos; )</span><br><span class="line">            let string = request.responseText</span><br><span class="line">            // 把符合 JSON 语法的字符串转换成 JS 对应的值</span><br><span class="line">            let object = window.JSON.parse( string )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><p>HTTP 第四部分永远是字符串，只不过是符合 JSON 对象语法的字符串（解析 JSON.parse()）</p>
</li>
<li><p>如何判断代码执行时长</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time()</span><br><span class="line">要判断的代码</span><br><span class="line">console.end()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断同步异步</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log( &apos;start&apos; )</span><br><span class="line">要判断的代码</span><br><span class="line">console.log( &apos;end&apos; )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON（JavaScript Object Notation）：存储和交换文本信息的语法，类似 XML，它采用键值对的方式来组织，易于人们阅读和编写，同时也易于机器解析和生成。<strong>它是一门新的语言</strong>。</p>
<h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p><a href="https://www.json.org/" target="_blank" rel="noopener">JSON 铁轨图</a><br>JSON 中有 String、null、Number、true、false、Array 和 Object</p>
<h3 id="JSON-和-JavaScript-的区别"><a href="#JSON-和-JavaScript-的区别" class="headerlink" title="JSON 和 JavaScript 的区别"></a>JSON 和 JavaScript 的区别</h3><p>JSON 和 JavaScript 是两门语言，JSON 是抄袭的 JavaScript，两者区别主要体现在：</p>
<ul>
<li>JSON 没有 undefined、function 和 Symbol</li>
<li>JSON 必须使用双引号</li>
<li>JSON 没有变量</li>
<li>JSON 中对象仅仅是一个哈希</li>
</ul>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>当一个资源从与该资源本身所在的服务器不同的域或端口<strong>发送 AJAX</strong> 请求一个资源时，资源会发起一个跨域 HTTP 请求，出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求</p>
</li>
<li><p>只有 AJAX 被限制，其他的都可以（img、form、link 和 script）</p>
</li>
<li><p>原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面的内容，所以浏览器认为这是安全的。而 AJAX 是可以读取相应内容的，因此浏览器将阻止你这样做</p>
</li>
<li><p>如果使用 AJAX 向其他源发送请求，会成功，但是报错（request.status === 0）</p>
</li>
<li><p>AJAX 请求已经发送出去了，却拿不到响应<br>request.status === 0</p>
</li>
<li><p>同源策略本质：一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容，但是浏览器并不阻止向另一个域名发送请求。<strong>只有协议、域名和端口一模一样才允许发送 AJAX 请求</strong></p>
</li>
</ul>
<h3 id="为什么要使用同源策略"><a href="#为什么要使用同源策略" class="headerlink" title="为什么要使用同源策略"></a>为什么要使用同源策略</h3><p><strong>安全</strong>，如果没有同源策略，AJAX 就可以向另一个域名发送 GET / POST 请求，GET 请求可以获取信息，POST 请求可以直接转账，那样互联网就没有隐私可言</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li><p>JSONP：但是 JSONP 有局限，不能发送 POST 请求</p>
</li>
<li><p>CORS（Cross-Orogin Resource Sharing 跨域资源共享）：请求的域名的<strong>后端</strong>需要在相应的接口添加<strong>响应头</strong>，此时就可以发送 POST 请求</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &quot;Access-Control-Allow-Origin&quot;, &quot;http://......&quot; )</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-20T08:56:11.000Z"><a href="/2018/01/20/HTTP系列 -- JSONP/">2018-01-20</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/20/HTTP系列 -- JSONP/">HTTP系列 -- JSONP</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/server-Node.js-demo/tree/master/JSONP" target="_blank" rel="noopener">参考代码</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库是用来长久储存数据的。</p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h4 id="form-表单提交"><a href="#form-表单提交" class="headerlink" title="form 表单提交"></a><code>form</code> 表单提交</h4><p>缺点：刷新页面 + 用户后退 + 用户刷新 = 数据变动</p>
<h4 id="form-iframe-提交"><a href="#form-iframe-提交" class="headerlink" title="form + iframe 提交"></a><code>form</code> + <code>iframe</code> 提交</h4><p><code>form</code> 表单提交到 <code>iframe</code> 中，页面不会刷新。<br>缺点：用户刷新页面  ==&gt;  数据变动</p>
<h4 id="JS动态创建-img-标签"><a href="#JS动态创建-img-标签" class="headerlink" title="JS动态创建 img 标签"></a>JS动态创建 <code>img</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let img = document.createElement(&apos;img&apos;);</span><br><span class="line">img.src = &apos;路径&apos;</span><br><span class="line">img.onload = function()&#123;&#125;  ==&gt;  HTTP状态码</span><br><span class="line">img.onerror = function()&#123;&#125;  ==&gt;  HTTP状态码</span><br></pre></td></tr></table></figure>
<p>通过路径，在 Nodejs 中设置成功或者失败，之后返回状态码，前端通过返回的HTTP状态码，进而来判断成功失败。</p>
<h4 id="动态创建-script-标签"><a href="#动态创建-script-标签" class="headerlink" title="动态创建 script 标签"></a>动态创建 <code>script</code> 标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.src = &apos;路径&apos;;</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">script.onload = function()&#123;&#125;</span><br><span class="line">script.onerror = function()&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过设置响应头中的类型进而来确定返回内容的格式（第四部分），从而保证返回的是 JavaScript 代码。</li>
<li>当创建  <code>script</code> 标签插入 <code>body</code> 后，返回的内容会立即执行，之后再去执行 <code>onload</code> 和 <code>onerror</code> 事件，所以说  <code>onload</code> 可以进行删除， 之后将处理逻辑交给后端（处理逻辑中应该包括使用完 <code>script</code> 标签之后立刻删除），但是此时前后端耦合。</li>
<li><code>script</code> 的 <code>src</code> 属性可以访问其他地址</li>
</ul>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>动态创建 <code>script</code> 并调用前端传给后端的 callback 技术</p>
<h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h3><h5 id="Nodejs："><a href="#Nodejs：" class="headerlink" title="Nodejs："></a>Nodejs：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.write(` callback.call(undefined,&apos; success &apos;) `);</span><br></pre></td></tr></table></figure>
<h5 id="JS"><a href="#JS" class="headerlink" title="JS:"></a>JS:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.callback = function()&#123;&#125;  //返回之后进行处理</span><br><span class="line">script.src = http://....../路径?callback = xxx</span><br></pre></td></tr></table></figure>
<h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><h5 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.write(` $&#123; query.callback &#125;.call(undefined,&#123;</span><br><span class="line">    &quot;success&quot;: true,</span><br><span class="line">    &quot;left&quot;: $&#123; newAmount &#125;</span><br><span class="line">&#125;) `)</span><br></pre></td></tr></table></figure>
<p>返回的数据是 JSON 数据<br><strong>特点：</strong></p>
<ul>
<li>请求方创建 <code>script</code> ，<code>src</code> 属性指向响应方</li>
<li>响应方根据查询参数，构造形如 xxx.call(undefined,”传给前端的数据”) 这样的响应。</li>
</ul>
<h1 id="JSONP-1"><a href="#JSONP-1" class="headerlink" title="JSONP"></a>JSONP</h1><h3 id="什么是-JSONP"><a href="#什么是-JSONP" class="headerlink" title="什么是 JSONP"></a>什么是 JSONP</h3><p>请求方：前端（浏览器）<br>响应方：后端（服务器）</p>
<ol>
<li>请求方创建 <code>script</code> ，<code>src</code> 指向响应方，同时传入一个查询参数 ?callback = 随机数</li>
<li>响应方根据查询参数 callback ，构造形如 <code>随机数.call(undefined,&quot;传给前端的数据&quot;)</code> 这样的响应</li>
<li>浏览器接收到响应，就会执行 <code>随机数.call(undefined,&quot;传给前端的数据&quot;)</code> </li>
<li>请求方获取到数据<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h5 id="JS-1"><a href="#JS-1" class="headerlink" title="JS"></a>JS</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">button.addEventlistener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;);</span><br><span class="line">    let functionName = &apos;bowen&apos; + parseInt(Math.random()*100000,10);</span><br><span class="line">    window[ functionName ] = function(result)&#123;</span><br><span class="line">        if( result === &apos;success&apos; )&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = &apos;http://....../路径?callback = &apos; + functionName</span><br><span class="line">    document.body.appendChild( script );</span><br><span class="line">    script.onload = function(event)&#123;</span><br><span class="line">        event.currentTarget.remove();</span><br><span class="line">        delete window[ functionName ]</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = function()&#123;</span><br><span class="line">        alert(&apos;fail&apos;);</span><br><span class="line">        event.currentTarget.remove();</span><br><span class="line">        delete window[ functionName ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="jQ"><a href="#jQ" class="headerlink" title="jQ:"></a>jQ:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;,(event) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &apos;http://....../路径&apos;，</span><br><span class="line">        dataType: &apos;jsonp&apos;,</span><br><span class="line">        success: function( response )&#123;</span><br><span class="line">            // do something</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="套路：为什么-JSONP-不支持-POST-请求"><a href="#套路：为什么-JSONP-不支持-POST-请求" class="headerlink" title="套路：为什么 JSONP 不支持 POST 请求"></a>套路：为什么 JSONP 不支持 POST 请求</h3><p>JSONP 是动态创建 <code>script</code> 标签 + 传入 callback 查询参数，<code>script</code> 标签，只能发送 GET 请求，不能使用 POST。</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><p>如果后端没有写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.write(` $&#123; query.callback &#125;.call(undefined,&#123;</span><br><span class="line">    &quot;success&quot;: true,</span><br><span class="line">    &quot;left&quot;: $&#123; newAmount &#125;</span><br><span class="line">&#125;) `)</span><br></pre></td></tr></table></figure></p>
<p>前端虽然有响应内容，但是使用不到</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-19T00:01:38.000Z"><a href="/2018/01/19/HTTP系列 -- Node.js/">2018-01-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/19/HTTP系列 -- Node.js/">HTTP系列 -- Node.js</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/Node.js-server-JSONP-AJAX/blob/master/server.js" target="_blank" rel="noopener">Node.js 服务器代码</a></p>
<h1 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let string = fs.readFileSync( &apos;路径&apos;, &apos;UTF-8&apos; )</span><br><span class="line">response.setHeader( &apos;Content-Type&apos;, &apos;类型&apos; )</span><br><span class="line">response.statusCode = 200</span><br><span class="line">response.write()</span><br><span class="line">response.end()</span><br></pre></td></tr></table></figure>
<h3 id="response-setHeader-‘Content-Type’-‘类型’"><a href="#response-setHeader-‘Content-Type’-‘类型’" class="headerlink" title="response.setHeader( ‘Content-Type’, ‘类型’ )"></a>response.setHeader( ‘Content-Type’, ‘类型’ )</h3><p>类型：</p>
<ul>
<li>HTML ==&gt; <code>response.setHeader( &#39;Content-Type, &#39;text/html; charset = utf-8&#39; )</code></li>
<li>CSS ==&gt; <code>response.setHeader( &#39;Content-Type&#39;, &#39;text/css&#39; )</code></li>
<li>JavaScript ==&gt; <code>response.setHeader( &#39;Content-Type&#39;, &#39;application/javascript&#39; )</code></li>
</ul>
<h1 id="创建-Node-js-服务器"><a href="#创建-Node-js-服务器" class="headerlink" title="创建 Node.js 服务器"></a>创建 Node.js 服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)</span><br><span class="line">var port = process.argv[2]</span><br><span class="line"></span><br><span class="line">if(!port)&#123;</span><br><span class="line">  console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;)</span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(request, response)&#123;</span><br><span class="line">  var parsedUrl = url.parse(request.url, true)</span><br><span class="line">  var path = request.url </span><br><span class="line">  var query = &apos;&apos;</span><br><span class="line">  if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125;</span><br><span class="line">  var pathNoQuery = parsedUrl.pathname</span><br><span class="line">  var queryObject = parsedUrl.query</span><br><span class="line">  var method = request.method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(&apos;HTTP 路径为\n&apos; + path)</span><br><span class="line">  if(path == &apos;/style&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/script&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/index&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)</span><br></pre></td></tr></table></figure>
<h1 id="解析-Node-js-服务器"><a href="#解析-Node-js-服务器" class="headerlink" title="解析 Node.js 服务器"></a>解析 Node.js 服务器</h1><ol>
<li><p><code>console.log(&#39;HTTP 路径为\n&#39; + path)</code> 表示在命令行中或者<code>Console</code>面板中打印出当前请求的 HTTP 路径</p>
</li>
<li><p>下方代码表示如果请求路径为<code>/style</code>，设置响应头信息为<code>&#39;Content-Type&#39;, &#39;text/css; charset=utf-8&#39;</code>（即响应内容 [ 第四部分 ] 的类型 [ css ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 <code>body{background-color: #ddd;}h1{color: red;}</code> ，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/style&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求路径为 <code>/script</code> ，设置响应头信息为 <code>&#39;Content-Type&#39;, &#39;text/javascript; charset=utf-8&#39;</code> （即响应内容 [ 第四部分 ] 的类型 [ javascript ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 <code>alert(&quot;这是JS执行的&quot;)</code>，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/script&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求路径为 <code>/index</code> ，设置响应头信息为 <code>(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;</code> （即响应内容 [ 第四部分 ] 的类型 [ html ] 和编码 [ utf-8 ]），响应内容( 第四部分 )为 HTML 页面，之后完成响应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(path == &apos;/index&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;script src=&quot;/script&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下方代码表示如果请求的路径不是上述路径，则返回状态码为 <code>404</code> ，之后完成响应。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h1><ol>
<li><p>新建目录和进入</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir node-demo</span><br><span class="line">cd node-demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件并编辑</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch server.js</span><br><span class="line">start server.js //内容如上</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js 端口号</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用-Node-js-发起请求"><a href="#使用-Node-js-发起请求" class="headerlink" title="使用 Node.js 发起请求"></a>使用 Node.js 发起请求</h1><ol>
<li><p>在新的 Bash 窗口运行 <code>curl http://localhost:你的指定的端口/xxx</code> 或者 <code>curl http://127.0.0.1:你指定的端口/xxx</code>即可发起请求</p>
</li>
<li><p>在浏览器窗口地址栏中输入 <code>http://localhost:你的指定的端口/xxx</code> 或者 <code>http://127.0.0.1:你指定的端口/xxx</code> 回车，即可发起请求。</p>
</li>
<li><p><code>curl -s -v -- &quot;http://localhost:port/xxx&quot;</code>可以查看完整的请求体和响应体。</p>
</li>
</ol>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><ul>
<li><p>在运行 <code>node server.js 端口号</code> Bash 窗口中可以查看到打印出来的路径（<code>console.log(&#39;HTTP 路径为\n&#39; + path)</code>），并且在发起请求的 Bash 窗口中可以查看请求体和响应体</p>
</li>
<li><p>在浏览器窗口中可以看到实际运行效果</p>
</li>
</ul>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><ol>
<li><p>任意一台电脑都是服务器</p>
</li>
<li><p>创建的<em>Node.js服务器</em>提供 HTTP 服务，所以需要提供 HTTP 服务的程序</p>
</li>
<li><p>用脚本可以提供 HTTP 服务</p>
</li>
</ol>
<h1 id="当在浏览器地址栏输入地址回车后发生的事情"><a href="#当在浏览器地址栏输入地址回车后发生的事情" class="headerlink" title="当在浏览器地址栏输入地址回车后发生的事情"></a>当在浏览器地址栏输入地址回车后发生的事情</h1><ol>
<li><p>DNS 域名解析。首先浏览器会查找缓存，如果没有，就向运营商查找，运营商会提供 DNS 服务，从而得到域名所对应的 IP 地址。DNS 域名解析就是一个域名到 IP 地址的转换</p>
</li>
<li><p>TCP 连接。浏览器根据 IP 地址向服务器发起 TCP 连接，与服务器建立 TCP 三次握手，浏览器对服务器说：“您好，我可以链接你么？”，服务器对浏览器说：“您好，你可以连接我”，浏览器对服务器说：“好的，那我连接你了！”，通过 TCP 的三次握手，从而确定双方都有收发文件的能力，自此浏览器和服务器建立了链接</p>
</li>
<li><p>浏览器发送 HTTP 请求。请求包括了请求行、请求头和请求正文</p>
</li>
<li><p>浏览器拿到响应、解析并渲染页面。浏览器是一个边解析边渲染的过程，首先浏览器解析HTML文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上</p>
</li>
<li><p>通过四次挥手关闭 TCP 连接。浏览器对服务器说：“不早了，我该走了”，服务器对浏览器说：“知道了”，之后服务器又对浏览器说：“我也该走了”，浏览器回应服务器：“好的”，至此 TCP 连接结束</p>
</li>
</ol>
<p><strong>注意</strong>：后缀是没有用的。HTTP 路径不是文件路径。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-18T23:59:03.000Z"><a href="/2018/01/19/HTTP系列 -- 网络与 IP /">2018-01-19</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/19/HTTP系列 -- 网络与 IP /">HTTP系列 -- 网络 与 IP</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP协议的底层是由 <strong>TCP 协议</strong>和 <strong>IP 协议</strong>（简称<strong>TCP/IP</strong>）构建的。HTTP只规定了请求格式和相应格式，即如何书写内容的协议。</p>
<h1 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h1><p>TCP 是传输控制协议，它规定了如何传输协议。</p>
<h3 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h3><ul>
<li>TCP 可靠、面向连接、相对 UDP 较慢</li>
<li>UDP 不可靠，不面向连接、相对 TCP 较快。</li>
</ul>
<h3 id="TCP-的三次握手指的是什么"><a href="#TCP-的三次握手指的是什么" class="headerlink" title="TCP 的三次握手指的是什么"></a>TCP 的三次握手指的是什么</h3><p>每次建立连接前，客户端和服务端之前都要先进行三次对话才开始正式传输内容，三次对话大概是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端：我要连接你了，可以吗</span><br><span class="line">2. 服务端：嗯，我准备好了，连接我吧</span><br><span class="line">3. 客户端：那我连接你咯。</span><br><span class="line">4. 开始后面步骤</span><br></pre></td></tr></table></figure></p>
<p>通过上述对话，从而确定了双方都可以收发内容。</p>
<h1 id="IP（Internet-Protocol）"><a href="#IP（Internet-Protocol）" class="headerlink" title="IP（Internet Protocol）"></a>IP（Internet Protocol）</h1><p>IP 是网络协议，它规定了如何联网协议。</p>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ol>
<li><p>只要在互联网中，那么就会有一个 IP。IP 分为<strong>内网 IP</strong> 和<strong>外网 IP</strong>。</p>
</li>
<li><p>内网：以路由器为核心的以及所有连接路由器的设备统称为内网</p>
</li>
<li><p>外网：以路由器为出口的外面的网络都是外网</p>
</li>
<li><p>服务商提供 DNS 服务（告知你你想要请求的域名所对应的 IP<br>地址）</p>
</li>
<li><p>路由器可以广播出来 WIFI ，连接之后便可以上网</p>
</li>
<li><p>路由器连接服务商的服务器，那么路由器就会有一个<strong>外网IP</strong>，表示用户在<strong>互联网</strong>中的地址</p>
</li>
<li><p>如果重启路由器，则有可能会重新分配<strong>外网IP</strong>，所以<strong>路由器没有固定的外网IP</strong></p>
</li>
<li><p>可以租用<strong>固定的外网IP</strong>，从而为用户提供稳定的服务（eg. 阿里、腾讯等公司）</p>
</li>
<li><p>内网中的设备使用<strong>内网IP</strong>，一般来说这个 IP 的格式都是<strong>192.168.xxx.xxx</strong></p>
</li>
<li><p>一般路由会给自己分配一个好记的<strong>内网 IP</strong>，如<em>192.168.1.1</em>。之后给每个设备分配不同的<strong>内网IP</strong></p>
</li>
<li><p>路由器会有两个IP，分别是<strong>内网IP</strong>和<strong>外网IP</strong></p>
</li>
<li><p>内网中的设备可以互相访问（比如你可以用电脑或手机进入<a href="http://192.168.1.1/" title="null" target="_blank" rel="noopener">http://192.168.1.1</a>来查看你的路由器<strong>「因为路由器内置一个HTTP服务器」</strong>），但是不能<strong>直接</strong>访问外网，内网设备想要访问外网，就必须经过路由器中转</p>
</li>
<li><p>外网中的设备可以互相访问（比如 qq.com 可以把首页发送给你的路由器，你的路由器有<strong>外网 IP</strong>），但是外网中的设备无法访问你的内网设备（这很好理解，内网是一个封闭的网络，外人进不来，所以实际上 qq.com 无法直接把首页放送给你的电脑和手机）</p>
</li>
<li><p>路，就是「必由之路」中的路。由，就是「必由之路」中的由（由是经过、缘由的意思）。所有的信息都要经过路由器，然后被指向一条它该去的路</p>
</li>
<li><p><strong>内网</strong>和<strong>外网</strong>通过<strong>路由器</strong>连接</p>
</li>
<li><p><strong>本地IP：127.0.0.1</strong>：表示设备本身</p>
</li>
<li><p>hosts：可以设置任意域名对应的IP</p>
</li>
<li><p>hosts文件中会有一行<code>127.0.0.1 localhost</code>，意思就是 <strong>localhost</strong> 指向 <strong>127.0.0.1</strong>，所以 <strong>localhost</strong> 也表示设备本身</p>
</li>
<li><p>特别特殊的 IP：<code>0.0.0.0</code>，它不表示任何设备。这个 IP 不同的地方含义不同</p>
</li>
<li><p>使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可。如果没有提供，浏览器会加上默认端口号80。</p>
</li>
</ol>
<h1 id="端口（port）"><a href="#端口（port）" class="headerlink" title="端口（port）"></a>端口（port）</h1><p>端口其实就是一个编号。一个服务器（硬件）不一定只提供一种服务，比如一个服务器既提供 HTTP 服务（网页服务），又提供 FTP 服务（文件下载服务），还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务，所以<strong>一个端口对应一个服务</strong>，是固定的。</p>
<h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><ol>
<li><p>提供 <strong>HTTP 服务</strong> ==&gt; <strong>80 端口</strong></p>
</li>
<li><p>提供 <strong>HTTPS 服务</strong> ==&gt; <strong>443 端口</strong></p>
</li>
<li><p>提供 <strong>FTP 服务</strong> ==&gt; <strong>21 端口</strong></p>
</li>
<li><p>提供<strong>代理服务器端口</strong> ==&gt; <strong>1080端口</strong></p>
</li>
</ol>
<h3 id="端口基础"><a href="#端口基础" class="headerlink" title="端口基础"></a>端口基础</h3><p>每个机器一共有 65535（2的16次方减1）个端口（这是协议规定的）。不过这些端口的使用有一些规定</p>
<ol>
<li><p>0 到 1023（2的10次方减1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口</p>
</li>
<li><p>其他端口可以给普通用户使用</p>
</li>
<li><p>如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。</p>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-15T10:27:13.000Z"><a href="/2018/01/15/HTTP系列 -- 请求与响应/">2018-01-15</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/15/HTTP系列 -- 请求与响应/">HTTP系列 -- 请求与响应</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol>
<li><p><strong>Server（服务器）</strong>：服务器作为硬件来说，通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机</p>
</li>
<li><p><strong>Client（客户端）</strong>：是指与服务器相对应，为客户提供本地服务的程序</p>
</li>
</ol>
<h1 id="浏览器-服务器-HTTP-三者关系"><a href="#浏览器-服务器-HTTP-三者关系" class="headerlink" title="浏览器 + 服务器 + HTTP 三者关系"></a>浏览器 + 服务器 + HTTP 三者关系</h1><ul>
<li>浏览器负责发起请求</li>
<li>服务器在<strong>80端口</strong>接收请求</li>
<li>服务器负责返回内容（响应）</li>
<li>浏览器负责下载响应内容</li>
</ul>
<p><strong>HTTP 的作用就是指导浏览器和服务器如何进行沟通。</strong></p>
<h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><h3 id="请求头（Request-Headers）格式"><a href="#请求头（Request-Headers）格式" class="headerlink" title="请求头（Request Headers）格式"></a>请求头（Request Headers）格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.请求类型 路径 协议/版本 // 请求行</span><br><span class="line">2.key: value  // 请求头</span><br><span class="line">3.</span><br><span class="line">4.要上传的数据  // 其他消息体</span><br></pre></td></tr></table></figure>
<h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><ol>
<li><p>GET ==&gt; 用于获取数据。</p>
</li>
<li><p>POST ==&gt; 用于提交数据，请求服务器进行处理。</p>
</li>
<li><p>PUT ==&gt; 向指定资源位置上传其最新内容（所有内容都更新）。</p>
</li>
<li><p>PATCH ==&gt; 用于将局部修改应用到资源。</p>
</li>
<li><p>DELETE ==&gt; 请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>HEAD ==&gt; 向服务器发出指定资源的请求，但服务器将不传回资源的本文部分。</p>
</li>
<li><p>OPTIONS ==&gt; 使服务器传回该资源所支持的所有HTTP请求方法，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
</ol>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>必须以 <code>/</code> 开头，如果不设置，默认为 <code>/</code> ，路径包括<strong>查询参数</strong>，但是不包括<strong>锚点</strong></p>
<h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><p>版本大部分都是 <code>HTTP/1.1</code>，还有<code>HTTP/2</code>.</p>
<h3 id="请求头（key-value）："><a href="#请求头（key-value）：" class="headerlink" title="请求头（key: value）："></a>请求头（key: value）：</h3><p>请求头定义一些操作参数。其中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host: www.baidu.com  // 域名</span><br><span class="line">User-Agent:      // 用的什么软件发起的请求</span><br><span class="line">Content-Type: application/x-www-form-urlcoded    //标识了第4部分的格式,POST 请求</span><br><span class="line">Content-Length: </span><br><span class="line">Cookie:</span><br></pre></td></tr></table></figure></p>
<h3 id="第3部分："><a href="#第3部分：" class="headerlink" title="第3部分："></a>第3部分：</h3><p>是一个空行（回车）。</p>
<h3 id="第4部分："><a href="#第4部分：" class="headerlink" title="第4部分："></a>第4部分：</h3><p>上传的数据，可以没有 </p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>https 协议 ==&gt; 所有数据在网络上请求和传输的时候都是加密的</li>
<li>http 协议  ==&gt; 所有数据在网络上请求和传输的时候都是明文的</li>
</ul>
<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><h3 id="响应头（Response-Headers）格式"><a href="#响应头（Response-Headers）格式" class="headerlink" title="响应头（Response Headers）格式"></a>响应头（Response Headers）格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.协议/版本 状态码 状态解释</span><br><span class="line">2.key: value  </span><br><span class="line">3.</span><br><span class="line">4.要下载的数据</span><br></pre></td></tr></table></figure>
<h3 id="状态码："><a href="#状态码：" class="headerlink" title="状态码："></a>状态码：</h3><p>表示网页服务器超文本传输协议响应状态的3位数字代码。</p>
<ul>
<li><p>2xx成功 ==&gt; 代表请求已成功被服务器接收、理解、并接受。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回（GET）。</span><br><span class="line">b.204 No Content 服务器成功处理了请求，没有返回任何内容（创建成功 ==&gt; POST）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>3xx重定向 ==&gt; 类状态码代表需要客户端采取进一步的操作才能完成请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.301 Move Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。</span><br><span class="line">b.302 Found 要求客户端执行临时重定向。</span><br><span class="line">c.304 Not Modified 表示资源未被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</span><br></pre></td></tr></table></figure>
</li>
<li><p>4xx客户端错误 ==&gt; 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.403 Forbidden 客户端错误，服务器已经理解请求，但是拒绝执行  它。</span><br><span class="line">b.404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发    现，但允许用户的后续请求。</span><br></pre></td></tr></table></figure>
</li>
<li><p>5xx服务器错误 ==&gt; 表示服务器无法完成明显有效的请求。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.500 Internal Server Error 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</span><br><span class="line">b.502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HTML-与-HTTP"><a href="#HTML-与-HTTP" class="headerlink" title="HTML 与 HTTP"></a>HTML 与 HTTP</h1><p>所有 App 都会内置一个浏览器（WebView）用来展示 HTML，而 HTML 都是通过 HTTP 下载的，而如果你要使用 HTTP 一般都会用到 URL。</p>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-15T10:21:51.000Z"><a href="/2018/01/15/HTTP系列 -- 基础知识/">2018-01-15</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/15/HTTP系列 -- 基础知识/">HTTP系列 -- 基础知识</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://github.com/bowen-wu/bash-create-file-script-demo" target="_blank" rel="noopener">代码链接</a></p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>JavaScript 是一门动态类型、面向对象的脚本语言</p>
<h3 id="bash-脚本"><a href="#bash-脚本" class="headerlink" title="bash 脚本"></a>bash 脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/local</span><br><span class="line">cd ~/local</span><br><span class="line">touch demo.txt</span><br><span class="line">start demo.txt</span><br><span class="line"></span><br><span class="line">    //内容如下：</span><br><span class="line">    //mkdir demo</span><br><span class="line">    //cd demo</span><br><span class="line">    //mkdir css js</span><br><span class="line">    //touch index.html css/style.css js/main.js</span><br><span class="line">    //exit</span><br><span class="line"></span><br><span class="line">    //（Windows 用户请跳过这一步）给 demo.sh 添加执行权限，加上可执行的操作</span><br><span class="line">    //chmod +x demo.txt</span><br><span class="line"></span><br><span class="line">    // 在任意位置执行 &apos;sh ~/local/demo.txt&apos; 即可运行此脚本，sh ==&gt; shell</span><br><span class="line">cd ~/desktop</span><br><span class="line">sh ~/local/demo.txt</span><br><span class="line">    // 你会看到当前目录里多出一个 demo 目录，demo 目录里面还有一些文件</span><br><span class="line">    // demo.txt 就是你写出的第一个 Bash 脚本了。</span><br><span class="line"></span><br><span class="line">    // 将 ~/local 添加到 PATH 里</span><br><span class="line">cd ~/local;pwd</span><br><span class="line">touch ~/.bashrc</span><br><span class="line">start ~/.bashrc</span><br><span class="line">    //在最后一行添加 </span><br><span class="line">export PATH=&quot;local的绝对路径:$PATH&quot;</span><br><span class="line">source ~/.bashrc</span><br><span class="line">    // 之前你要运行 sh ~/local/demo.txt，现在你只需要运行 demo.txt 就行  了</span><br><span class="line">    // 原因：将这个路径添加到 &apos;~/.bashrc&apos; 之后，就是在进入 git bash 之前就运行了 &apos;~/.bashrc&apos; </span><br><span class="line"></span><br><span class="line">    // 删掉demo.txt 的后缀 .txt </span><br><span class="line">mv ~/local/demo.txt ~/local/demo</span><br><span class="line">    // 现在只要运行 demo 就能执行该脚本了。</span><br></pre></td></tr></table></figure>
<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol>
<li>PATH 的作用<br>你每次在 Bash 里面输入一个命令时（比如 ls、cp、demo），Bash 都会去 PATH 列表里面寻找对应的文  件，如果找到了就执行。(<code>each $PATH</code>查看PATH，’目录：目录…’)</li>
<li><code>type demo</code> 可以看到寻找过程</li>
<li><code>which demo</code> 可以看到寻找结果,最终结果</li>
<li>文件后缀的作用：毫无作用，windows有一个用处，告诉计算机，用什么打开文件</li>
<li>所有命令都是可执行文件，都是一个脚本文件，可执行文件就是命令，不可执行文件就是配置</li>
</ol>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>让 demo 脚本创建的目录可变，更改 demo 的内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir $1</span><br><span class="line">cd $1   //  $1 ==&gt; 表示传递的第一个参数</span><br><span class="line">mkdir css js</span><br><span class="line">touch index.html css/style js/main.js</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p><code>exit 1</code> 表示错误代码1</p>
<p><code>exit 0</code>表示没有错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo xxx &amp;&amp; echo &apos;end&apos; //表示之后 demo xxx 成功了才会执行 echo &apos;end&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Node-js-脚本"><a href="#Node-js-脚本" class="headerlink" title="Node.js 脚本"></a><a href="https://github.com/bowen-wu/node-create-file" target="_blank" rel="noopener">Node.js 脚本</a></h3><h1 id="www（World-Wide-Web）"><a href="#www（World-Wide-Web）" class="headerlink" title="www（World Wide Web）"></a>www（World Wide Web）</h1><p>1990年万维网（World Wide Web）诞生。Tim Berners-Lee 发明了第一个网页、第一个浏览器和第一个服务器</p>
<h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><ol>
<li><p><strong>URI（Uniform Resource Identifier）</strong>：统一资源标识符，是一个用于标识某一互联网资源名称的字符串，其中包括 URL 和 URN 。</p>
<ul>
<li><p>URL（Uniform Resource Locator）：统一资源定位符，或者称为<strong>URL地址</strong>和<strong>网页地址（网址）</strong>。统一资源定位符的标准格式如下：<br><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code><br><img src="http://upload-images.jianshu.io/upload_images/9617841-1dd60cd247108428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="URL地址"></p>
</li>
<li><p>URN（Uniform Resource Name）：统一资源名称，其目的是通过提供一种途径，用于在特定的命名空间资源的标识，以补充网址。</p>
</li>
</ul>
</li>
<li><p><strong>HTTP（HyperText Transfer Protocol）</strong>：超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。就是两个电脑之间传输内容的协议。</p>
</li>
<li><p><strong>HTML（HyperText Markup Language）</strong>：超文本标记语言，是一种用于创建网页的标准标记语言。<a href="http://info.cern.ch/" target="_blank" rel="noopener">第一个网页</a></p>
</li>
<li><p><strong>DNS（Domain Name System）</strong>：域名系统，是互联网的一项服务。它作为将<strong>域名和IP地址相互映射</strong>的一个分布式数据库，能够使人更方便地访问互联网。（<strong>输入一个域名，将得到一个IP</strong>）</p>
<ul>
<li><p>输入域名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在命令行中输入以下任意一条，即可返回包括IP地址的一些信息</span><br><span class="line">nslookup baidu.com</span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出IP</p>
</li>
</ul>
</li>
</ol>
<p><strong>说明：</strong></p>
<ul>
<li>可以修改本地 hosts 文件从而让域名指向特定的IP</li>
<li>URL 的作用是能让你访问一个页面</li>
<li>HTTP 的作用是让你能下载这个页面</li>
<li>HTML 的作用是让你能看懂这个页面。</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTTP/">HTTP</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-13T01:05:03.000Z"><a href="/2018/01/13/HTML-Element/">2018-01-13</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/13/HTML-Element/">HTML Element</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h1><ul>
<li><code>&lt;html&gt;</code> 表示一个HTML文档的根（顶级元素），所所以它也被称为根元素。其他所有其他元素必须是此元素的后代</li>
</ul>
<h1 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h1><p>元数据（Metadata）含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件 (如搜索引擎， 浏览器等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件</p>
<ul>
<li><p><code>&lt;link&gt;</code> 指定了外部资源与当前文档的关系. 这个元素的使用方法包括为导航定义关系框架.这个元素经常用来链接css文件</p>
</li>
<li><p><code>&lt;meta&gt;</code> 表示那些不能由其它HTML元相关元素 (<code>&lt;base&gt;</code>，<code>&lt;link&gt;</code>，<code>&lt;script&gt;</code>，<code>&lt;style&gt;</code>或<code>&lt;title&gt;</code>）之一表示的任何元数据信息</p>
</li>
<li><p><code>&lt;style&gt;</code> 包含了文档的样式化信息或者文档的一部分。指定的样式化星系包含的该元素内，通常是CSS的格式</p>
</li>
</ul>
<h1 id="内容分区"><a href="#内容分区" class="headerlink" title="内容分区"></a>内容分区</h1><p>内容分区元素允许你将文档内容从逻辑上进行组织划分。使用包括页眉(header)、页脚(footer)、导航(nav)和标题(h1~h6)等分区元素，来为页面内容创建明确的大纲，以便区分各个章节的内容</p>
<ul>
<li><p><code>&lt;address&gt;</code> 可以让作者为它最近的<code>&lt;article&gt;</code>或者<code>&lt;body&gt;</code>祖先元素提供联系信息。在后一种情况下，它应用于整个文档</p>
</li>
<li><p><code>&lt;article&gt;</code> 表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目</p>
</li>
<li><p><code>&lt;aside&gt;</code> 表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者嵌入内容</p>
</li>
<li><p><code>&lt;footer&gt;</code> 示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息</p>
</li>
<li><p><code>&lt;h1-h6&gt;</code> 标题信息</p>
</li>
<li><p><code>&lt;header&gt;</code> 表示一组引导性的帮助，可能包含标题元素，也可以包含其他元素，像logo、分节头部、搜索表单等</p>
</li>
<li><p><code>&lt;hgroup&gt;</code> 代表一个段的标题</p>
</li>
<li><p><code>&lt;nav&gt;</code> 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表</p>
</li>
<li><p><code>&lt;section&gt;</code> 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）</p>
</li>
</ul>
<h1 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h1><p>使用 HTML 文本内容元素来组织在开标签<code>&lt;body&gt;</code>和闭标签<code>&lt;/body&gt;</code> 里的块或章节的内容。这些元素能标识内容的宗旨或结构，而这对于 accessibility 和 SEO很重要</p>
<ul>
<li><p><code>&lt;blockquote&gt;</code> 引用块</p>
</li>
<li><p><code>&lt;div&gt;</code> 是一个通用型的流内容容器</p>
</li>
<li><p><code>&lt;dl&gt;</code> 是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)</p>
</li>
<li><p><code>&lt;dt&gt;</code> 用于在一个定义列表中声明一个术语。通常在该元素后面会跟着 <code>&lt;dd&gt;</code>元素</p>
</li>
<li><p><code>&lt;dd&gt;</code> 用来指明一个描述列表  ( <code>&lt;dl&gt;</code> ) 元素中一个术语的描述。这个元素只能作为描述列表元素的子元素出现，并且必须跟着一个 <code>&lt;dt&gt;</code> 元素</p>
</li>
<li><p><code>&lt;hr&gt;</code> 表示段落级元素之间的主题转换。在HTML的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上</p>
</li>
<li><p><code>&lt;main&gt;</code> 呈现了文档<code>&lt;body&gt;</code>或应用的主体部分</p>
</li>
<li><p><code>&lt;ol&gt;</code> 表示多个有序列表项，通常渲染为有带编号的列表</p>
</li>
<li><p><code>&lt;ul&gt;</code> 代表多项的无序列表，即无数值排序项的集合，且它们在列表中的顺序是没有意义的</p>
</li>
<li><p><code>&lt;li&gt;</code> 用于表示列表里的条目。它必须被包含在一个父元素 <code>&lt;ul&gt;</code> <code>&lt;ol&gt;</code> 里</p>
</li>
<li><p><code>&lt;p&gt;</code> 表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进</p>
</li>
<li><p><code>&lt;pre&gt;</code> 表示预定义格式文本</p>
</li>
</ul>
<h1 id="内联文本语义"><a href="#内联文本语义" class="headerlink" title="内联文本语义"></a>内联文本语义</h1><p>使用 HTML 内联文本语义(Inline text semantics)定义语句，结构，可以是一个词，一段，或任意风格的文字</p>
<ul>
<li><p><code>&lt;a&gt;</code>  可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他URL的超链接</p>
</li>
<li><p><code>&lt;abbr&gt;</code> 代表缩写，并可选择提供一个完整的描述</p>
</li>
<li><p><code>&lt;b&gt;</code> 表示相对于普通文本字体上的区别，但不表示任何特殊的强调或者关联，通常以粗体显示</p>
</li>
<li><p><code>&lt;bdi&gt;</code> (双向隔离元素) 会隔离可能以不同方向进行格式化的外部文本</p>
</li>
<li><p><code>&lt;bdo&gt;</code> (HTML双向覆盖元素)用于覆盖当前文本的朝向，它使得字符按给定的方向排列</p>
</li>
<li><p><code>&lt;br&gt;</code> 文本中产生一个换行（回车键）</p>
</li>
<li><p><code>&lt;cite&gt;</code> 表示一个作品的引用</p>
</li>
<li><p><code>&lt;code&gt;</code> 现一段计算机代码. 默认情况下, 它以浏览器的默认等宽字体显示</p>
</li>
<li><p><code>&lt;data&gt;</code> 将一个指定内容和机器可读的翻译联系在一起</p>
</li>
<li><p><code>&lt;em&gt;</code> 标记出需要用户着重阅读的内容</p>
</li>
<li><p><code>&lt;i&gt;</code> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示</p>
</li>
<li><p><code>&lt;kbd&gt;</code> 用于表示用户输入，它将产生一个行内元素，以浏览器的默认monospace字体显示</p>
</li>
<li><p><code>&lt;mark&gt;</code> 代表突出显示的文字</p>
</li>
<li><p><code>&lt;q&gt;</code> 表示一个封闭的并且是短的行内引用的文本。这个标签是用来引用短的文本，所以请不要引入换行符； 对于长的文本的引用请使用<code>&lt;blockquote&gt;</code>替代</p>
</li>
<li><p><code>&lt;s&gt;</code> 使用删除线来渲染文本</p>
</li>
<li><p><code>&lt;small&gt;</code> 使文本的字体变小一号</p>
</li>
<li><p><code>&lt;span&gt;</code> 短语内容的通用行内容器，并没有任何特殊语义</p>
</li>
<li><p><code>&lt;strong&gt;</code> 表示文本十分重要，一般用粗体显示</p>
</li>
<li><p><code>&lt;sub&gt;</code> 定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。<strong>下标</strong></p>
</li>
<li><p><code>&lt;sup&gt;</code> 定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。<strong>上标</strong></p>
</li>
<li><p><code>&lt;u&gt;</code> 使文本在其内容的基线下的一行呈现下划线</p>
</li>
</ul>
<h1 id="图片和多媒体"><a href="#图片和多媒体" class="headerlink" title="图片和多媒体"></a>图片和多媒体</h1><p>HTML 支持各种多媒体资源，例如图像，音频和视频</p>
<ul>
<li><p><code>&lt;area&gt;</code>  在图片上定义一个热点区域</p>
</li>
<li><p><code>&lt;audio&gt;</code> 用于在文档中表示音频内容。 <code>&lt;audio&gt;</code>元素可以包含多个音频资源， 这些音频资源可以使用 <code>src</code>属性或者<code>&lt;source&gt;</code>元素来进行描述； 浏览器将会选择最合适的一个来使用。对于不支持 <code>&lt;audio&gt;</code> 元素的浏览器，<code>&lt;audio&gt;</code> 元素也可以作为浏览器不识别的内容加入到文档中</p>
</li>
<li><p><code>&lt;img&gt;</code> 代表文档中的一个图像</p>
</li>
<li><p><code>&lt;track&gt;</code> 被当作媒体元素—<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>的子元素来使用。它允许指定计时字幕（或者基于事件的数据），例如自动处理字幕</p>
</li>
<li><p><code>&lt;video&gt;</code> 用于在HTML或者XHTML文档中嵌入视频内容</p>
</li>
</ul>
<h1 id="内嵌内容"><a href="#内嵌内容" class="headerlink" title="内嵌内容"></a>内嵌内容</h1><p>除了常规的多媒体内容，HTML 可以包括各种其他的内容，即使它并不容易交互</p>
<ul>
<li><p><code>&lt;embed&gt;</code> 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件</p>
</li>
<li><p><code>&lt;object&gt;</code> 表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源</p>
</li>
<li><p><code>&lt;param&gt;</code> 定义了 <code>&lt;object&gt;</code>的参数</p>
</li>
<li><p><code>&lt;source&gt;</code></p>
</li>
</ul>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>为了创建动态内容和 Web 应用程序，HTML 支持使用脚本语言，最突出的就是 JavaScript。某些元素支持此功能</p>
<ul>
<li><p><code>&lt;canvas&gt;</code> 可被用来通过脚本（通常是JavaScript）绘制图形</p>
</li>
<li><p><code>&lt;noscript&gt;</code> 如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则HTML <noscript>元素定义要插入的html部分</noscript></p>
</li>
<li><p><code>&lt;script&gt;</code> 用于嵌入或引用可执行脚本</p>
</li>
</ul>
<h1 id="编辑标识"><a href="#编辑标识" class="headerlink" title="编辑标识"></a>编辑标识</h1><p>这些元素能标示出某个文本被更改过的部分</p>
<ul>
<li><p><code>&lt;del&gt;</code> 表示已经从文档中删除的文本范围。此元素通常是（但不必）呈现删除线的文本</p>
</li>
<li><p><code>&lt;ins&gt;</code> 定义已经被插入文档中的文本</p>
</li>
</ul>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>HTML 提供了许多可一起使用的元素，这些元素能用来创建一个用户可以填写并提交到网站或应用程序的表单</p>
<ul>
<li><p><code>&lt;button&gt;</code>  表示一个可点击的按钮</p>
</li>
<li><p><code>&lt;datalist&gt;</code> 包含了一组<code>&lt;option&gt;</code>元素,这些元素表示其它表单控件可选值</p>
</li>
<li><p><code>&lt;fieldset&gt;</code> 用来对表单中的控制元素进行分组(也包括 label 元素)</p>
</li>
<li><p><code>&lt;form&gt;</code> 表示了文档中的一个区域，这个区域包含有交互控制元件，用来向web服务器提交信息</p>
</li>
<li><p><code>&lt;input&gt;</code> 用于为基于Web的表单创建交互式控件，以便接受来自用户的数据</p>
</li>
<li><p><code>&lt;label&gt;</code> 表示用户界面中项目的标题</p>
</li>
<li><p><code>&lt;legend&gt;</code> 代表一个用于表示它的父元素<code>&lt;fieldset&gt;</code>的内容的标题</p>
</li>
<li><p><code>&lt;meter&gt;</code> 用来显示已知范围的标量值或者分数值</p>
</li>
<li><p><code>&lt;option&gt;</code> 用于定义在<code>&lt;select&gt;</code>、<code>&lt;optgroup&gt;</code> 或 <code>&lt;datalist&gt;</code> 元素中包含的项</p>
</li>
<li><p><code>&lt;output&gt;</code> 表示计算或用户操作的结果</p>
</li>
<li><p><code>&lt;progress&gt;</code> 用来显示一项任务的完成进度。通常情况下,该元素都显示为一个进度条形式</p>
</li>
<li><p><code>&lt;select&gt;</code> 一种表单控件，可创建选项菜单</p>
</li>
<li><p><code>&lt;textarea&gt;</code> 表示一个多行纯文本编辑控件</p>
</li>
</ul>
<h1 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h1><p>HTML 提供了一系列有助于创建交互式用户界面对象的元素</p>
<ul>
<li><p><code>&lt;details&gt;</code> 被用作发现小部件，用户可以从其中检索附加信息</p>
</li>
<li><p><code>&lt;dialog&gt;</code> 表示一个对话框或其他交互式组件，例如一个检查员或窗口</p>
</li>
<li><p><code>&lt;menu&gt;</code> 呈现了一组用户可执行或激活的命令。这既包含了可能出现在屏幕顶端的列表菜单，也包含了那些隐藏在按钮之下、当点击按钮后显示出来的文本菜单</p>
</li>
<li><p><code>&lt;menuitem&gt;</code> 生成一个弹出式菜单。这包括上下文菜单，以及按钮可能附带的菜单。</p>
</li>
<li><p><code>&lt;summary&gt;</code> 用作 一个 <code>&lt;details&gt;</code> 元素的一个内容的摘要，标题或图例</p>
</li>
</ul>
<h1 id="web组件"><a href="#web组件" class="headerlink" title="web组件"></a>web组件</h1><p>Web 组件是种近似 HTML（HTML-related） 的技术，这使得它能够，从本质上讲，创建和使用自定义元素，就好像它是普通的 HTML。此外，你甚至可以创建自定义版本的标准 HTML 元素</p>
<ul>
<li><p><code>&lt;slot&gt;</code> web组件技术的一部分，slot是web组件的一个占位符，可以用来插入自定义的标记文本。可以创建不同的DOM树并进行渲染</p>
</li>
<li><p><code>&lt;template&gt;</code> 一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用JavaScript进行实例化</p>
</li>
</ul>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/HTML/">HTML</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-12T11:05:51.000Z"><a href="/2018/01/12/jQuery系列（二）-- 样式/">2018-01-12</a></time>
      
      
  
    <h1 class="title"><a href="/2018/01/12/jQuery系列（二）-- 样式/">jQuery系列（二） -- 样式</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>jQuery 函数包装的对象是类数组对象，对象里面包含了 DOM 对象的信息，并封装了很多操作方法，可以和访问数组一样的方法来访问。</p>
<h1 id="jQuery-对象-和-DOM-对象"><a href="#jQuery-对象-和-DOM-对象" class="headerlink" title="jQuery 对象 和 DOM 对象"></a>jQuery 对象 和 DOM 对象</h1><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>可是使用 $ 符号将 DOM 对象封装成 jQuery 对象 <code>$( div )</code><br>可是使用 <code>div = $div[ 0 ]</code> 或者 <code>div = $div.get( 0 )</code> 将 jQuery 对象转化成 DOM 对象</p>
<p>###区别<br>DOM 对象的属性和方法有： .style   .classList<br>jQuery 对象的属性和方法有：.css     .addClass    </p>
<p><strong>说明：</strong>传递给 $(DOM) 函数的参数是 DOM Object ，则 jQuery 函数会把这个 DOM Object 给包装成一个新的 jQuery 对象</p>
<h1 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h1><ol>
<li>id 选择器： $( “#id” )</li>
<li>类选择器：$( “.class” )</li>
<li>元素选择器： $( “element” )</li>
<li>全选择器：$( “*” )</li>
<li><p>层级选择器</p>
<ul>
<li><p>子选择器：$( “parent &gt; child” )</p>
</li>
<li><p>后代选择器：$( “ancestor descendant” )</p>
</li>
<li><p>相邻兄弟选择器：$( “prev + next” )<br>选择所有紧跟在 <code>prev</code> 元素后的 <code>next</code> 元素</p>
</li>
<li><p>一般兄弟选择器：$( “prev ~ siblings” )<br>匹配 <code>prev</code> 元素之后的所有兄弟元素，具有相同的父元素，并匹配过滤 <code>siblings</code> 选择器</p>
</li>
</ul>
</li>
<li><p>基本筛选选择器</p>
<ul>
<li>$( “:first” ) ==&gt; 匹配第一个元素</li>
<li>$( “:last” ) ==&gt; 匹配最后一个元素</li>
<li>$( “:not(seletor)” ) ==&gt; 选择所有元素去除不匹配给定的选择器元素</li>
<li>$( “:eq(index)” ) ==&gt; 在匹配的集合中选择 index 的元素（从0开始）</li>
<li>$( “:gt(index)” ) ==&gt; 在匹配的集合中选择大于 index 的元素（从0开    始）</li>
<li>$( “:lt(index)” ) ==&gt; 在匹配的集合中选择小于 index 的元素（从0开    始）</li>
<li>$( “:odd” ) ==&gt; 选择索引值为奇数的元素</li>
<li>$( “:even” ) ==&gt; 选择索引值为偶数的元素</li>
<li>$( “:header” ) ==&gt; 选择所有标题元素</li>
<li>$( “:root” ) ==&gt; 选择该文档的根元素</li>
<li>$( “:lang(language)” ) ==&gt; 选择指定语言的所有元素</li>
<li>$( “:animated” ) ==&gt; 选择所有正在执行动画的元素<br><strong>说明：</strong><pre><code>1. :eq()、:lt()、:gt()、:even、:odd 用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素进一步筛选
2. :gt() 是一个段落筛选，从指定索引的下一个开始，:gt(1) 实际是从2开始
</code></pre></li>
</ul>
</li>
<li><p>内容筛选选择器</p>
<ul>
<li><p>$( “:parent” ) ==&gt; 选择所有含有子元素或者文本的元素</p>
</li>
<li><p>$( “:empty” ) ==&gt; 选择所有没有子元素的元素（包括文本节点）</p>
</li>
<li><p>$( “:contains(text)” ) ==&gt; 选择所有包含指定文本的元素</p>
</li>
<li><p>$( “:has(selector)” ) ==&gt; 选择元素中至少包含指定选择器的元素<br><strong>说明：</strong></p>
<pre><code>1. :contain 和 :has 都有查找的意思，但 contains 查找包含**制定文本**的元素，has 查找包含**指定元素**的元素
2. 如果 :contains 匹配的文本包含在元素的子元素中，同样认为是符合条件的
3. :parent 和 :empty 是相反的，但是两者所涉及的子元素都包括文本节点
</code></pre></li>
</ul>
</li>
<li><p>可见性筛选选择器</p>
<ul>
<li><p>$( “:visible” ) ==&gt; 选择所有显示的元素</p>
</li>
<li><p>$( “:hidden” ) ==&gt; 选择所有隐藏的元素</p>
<p><strong>隐藏元素的方式</strong></p>
<ol>
<li>CSS ==&gt; display: none</li>
<li>width: 0; height: 0;</li>
<li>visibility: hidden;</li>
<li>opacity: 0;<br><strong>说明：</strong>如果元素<strong>占据文档中一定的空间</strong>，元素被认为是<strong>可见</strong>的，可见元素的宽高都大于 0 ，元素的 <code>visibility: hidden;</code> 和 <code>opacity: 0;</code> 被认为是可见的，因为他们仍然占据空间布局。不在文档中的元素被认为是不可见的，如果当他们被插入到文档中，jQuery 没有办法知道他们是否是可见的，因为元素可见性依赖于使用的样式。</li>
</ol>
</li>
</ul>
</li>
<li><p>属性筛选选择器</p>
<ul>
<li><p>$( “[attribute |= ‘value’]” ) ==&gt; 选择指定属性值等于<strong>给定字符串</strong>或<strong>以该字符串为前缀</strong>（该字符串后跟一个连字符 ‘-‘）的元素</p>
</li>
<li><p>$( “[attribute <em>= ‘value’]” ) ==&gt; 选择指定属性具有<em>*包含一个给定的子字符串</em></em>的元素（选择给定属性是包含某些值的元素）</p>
</li>
<li><p>$( “[attribute ~= ‘value’]” ) ==&gt; 选择指定属性用<strong>空格分隔</strong>的值中包含一个给定值的元素</p>
</li>
<li><p>$( “[attribute = ‘value’]” ) ==&gt; 选择指定属性是<strong>给定值</strong>的元素</p>
</li>
<li><p>$( “[attribute != ‘value’]” ) ==&gt; 选择<strong>不存在指定属性</strong>，或者指定的属性<strong>不等于给定值</strong>的元素</p>
</li>
<li><p>$( “[attribute ^= ‘value’]” ) ==&gt; 选择指定属性是以<strong>给定字符串开始</strong>的元素</p>
</li>
<li><p>$( “[attribute $= ‘value’]” ) ==&gt; 选择指定属性是以<strong>给定值结尾</strong>的元素</p>
</li>
<li><p>$( “[attribute]” ) ==&gt; 选择所有<strong>具有指定属性</strong>的元素，该属性是任意值</p>
</li>
</ul>
</li>
<li><p>表单元素选择器</p>
<ul>
<li><p>$( “:input” ) ==&gt; 选择所有 input textarea select 和 button 的元素</p>
</li>
<li><p>$( “:text” ) ==&gt; 匹配所有文本框</p>
</li>
<li><p>$( “:password” ) ==&gt; 匹配所有密码框</p>
</li>
<li><p>$( “:raido” ) ==&gt; 匹配所有单选按钮</p>
</li>
<li><p>$( “:checkbox” ) ==&gt; 匹配所有复选框</p>
</li>
<li><p>$( “:submit” ) ==&gt; 匹配所有提交按钮</p>
</li>
<li><p>$( “:image” ) ==&gt; 匹配所有图像域</p>
</li>
<li><p>$( “:reset” ) ==&gt; 匹配所有重置按钮</p>
</li>
<li><p>$( “:button” ) ==&gt; 匹配所有按钮</p>
</li>
<li><p>$( “:file” ) ==&gt; 匹配所有文件域</p>
</li>
</ul>
<p><strong>说明：</strong></p>
<pre><code>1. 除了 input 筛选选择器，其余每个表单类别选择器都对应一个 input 元素的 type 值，所以其都可以用属性筛选选择器替换
2. ` $( &quot;:password&quot; ) === $( &quot;[type = password]&quot; ) `
</code></pre></li>
<li><p>表单对象属性筛选选择器</p>
<ul>
<li><p>$( “:enabled” ) ==&gt; 选取可用的表单元素</p>
</li>
<li><p>$( “:disabled” ) ==&gt; 选取不可用的表单元素</p>
</li>
<li><p>$( “:checked” ) ==&gt; 选取被选中的 <input> 元素</p>
</li>
<li><p>$( “:selected” ) ==&gt; 选取被选中的 <option> 元素</option></p>
</li>
</ul>
<p><strong>说明：</strong></p>
<pre><code>1. 选择器适用于复选框和单选框，对于**下拉框**元素使用 **:selected** 选择器
2. 在使用 :checked 的时候，**最佳实践是使用 input: checked** 
</code></pre></li>
<li><p>子元素筛选选择器</p>
<ul>
<li><p>$( “:first-child” ) ==&gt; 选择所有父级元素下的第一个子元素</p>
</li>
<li><p>$( “:last-child” ) ==&gt; 选择所有父级元素下的最后一个子元素</p>
</li>
<li><p>$( “:only-child” ) ==&gt; 如果某个元素是其父元素下的唯一子元素，那么它就会被选中</p>
</li>
<li><p>$( “:nth-child(n)” ) ==&gt; 选择所有父级元素下的第 n 个子元素，n 是索引值，从 1 开始</p>
</li>
<li><p>$( “:nth-last-child(n)” ) ==&gt; 选择所有父级元素下的第 n 个子元素，计数从最后一个开始</p>
</li>
</ul>
</li>
<li><p>特殊选择器</p>
<ul>
<li><p>this ==&gt; 表示当前的上下文对象是一个 HTML 对象，可以调用 HTML 对象所拥有的属性和方法</p>
</li>
<li><p>$(this) ==&gt; 代表上下文是一个 jQuery 的上下文对象，可以调用 jQuery 的方法和属性值</p>
</li>
</ul>
</li>
</ol>
<h1 id="jQuery-属性与样式"><a href="#jQuery-属性与样式" class="headerlink" title="jQuery 属性与样式"></a>jQuery 属性与样式</h1><ol>
<li><p>.attr()<br>获取和设置元素属性（DOM操作）</p>
<ul>
<li>.attr(传入属性名) ==&gt; 获取属性值</li>
<li>.attr(属性名, 属性值) ==&gt; 设置属性值</li>
<li>.attr(属性名, 函数值) ==&gt; 设置属性的函数值</li>
<li>.attr(attribute) ==&gt; 给指定元素设置多个属性值<br>.attr({属性名1: “属性值1” , 属性名2: “属性值2”, …})</li>
</ul>
<p><strong>说明：Attribute 和 Property</strong></p>
<pre><code>1. Attribute 属性 ，  Property  特性
2. Attribute 就是 DOM node 自带的属性（id、class、title），Property 是 DOM 元素作为对象，其附加的内容（nodeName、nodeType、tagName）
</code></pre></li>
<li><p>.removeAttr()<br> 为匹配的元素集合中的每个元素移除一个属性 attributeName</p>
</li>
<li><p>.html()<br> 获取或设置匹配元素的 HTML 内容</p>
<ul>
<li>.html() ==&gt; 获取集合中第一个匹配元素的 HTML 内容</li>
<li>.html(htmlString) ==&gt; 设置每一个匹配元素的 HTML 内容</li>
<li>.html(function(index, oldhtml)) ==&gt; 用来返回设置 HTML 内容的一个函数<br><strong>说明：</strong><pre><code>.html() 方法内部使用的是 DOM 的 innerHTML 属性来操作的，这个操作是针对整个 HTML 内容（包括文本内容）
</code></pre></li>
</ul>
</li>
<li><p>.text()<br> 得到匹配元素集合中的每个元素的文本内容的结合，包括他们的后代，或者设置匹配元素集合中每个元素的文本内容为指定的文本内容</p>
<ul>
<li>.text() ==&gt; 获取匹配元素集合中每个元素的合并文本，包括他们的后代</li>
<li>.text(textString) ==&gt; 用来设置匹配元素内容的文本</li>
<li><p>.text(function(index, text)) ==&gt; 用来返回设置文本内容的一个函数</p>
<p><strong>说明：.html() 和 .text()</strong></p>
<pre><code>1. .html() 处理元素内容，.text() 处理文本内容
2. html() 只能使用在 HTML 文档中，.text() 在 XML 文档和 HTML 文档都能使用
3. 若处理对象只有一个子文本节点，则 .html 和 .text() 处理结果相同
</code></pre></li>
</ul>
</li>
<li><p>.val()<br> 处理<strong>表单元素</strong>的值  </p>
<ul>
<li>.val() ==&gt; 获取匹配元素集合中第一个元素的当前值</li>
<li>.val(value) ==&gt; 设置匹配的元素集合中每个元素的值</li>
<li><p>.val(function(){}) ==&gt; 一个用来返回设置值的函数</p>
<p><strong>说明：.html() 和 .text()</strong></p>
<pre><code>1. .val() 处理 select 元素，当没有选择项被选中时，它将返回 null 
2. 若 select 元素有 multiple 属性，并且至少一个选择项被选中时， .val() 将返回一个数组，这个数组包含每个选中选择项的值
3. .val() 方法多用来设置表单的字段的值
</code></pre></li>
</ul>
</li>
<li><p>.addClass()<br> 动态增加 class 类名</p>
<ul>
<li>.addClass(className) ==&gt; 为每个匹配元素增加一个或多个类名</li>
<li><p>.addClass(function(index, currentClass){}) ==&gt; 这个函数返回一个或更多用空格隔开的要增加的样式名</p>
<p><strong>说明：</strong></p>
<pre><code>1. .addClass() 方法不会替换一个样式类名，它只是简单的添加一个类名到元素上
2. 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  $(&apos;div&apos;).addClass(function(index, className)&#123;</span><br><span class="line">      if( className.indexOf(index) !== -1 )&#123;</span><br><span class="line">          $(this).addClass(&apos;red&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>.removeClass()<br> 删除全部或者指定的 class</p>
<ul>
<li>.removeClass([className])  ==&gt; 每个匹配的元素移除一个或对个用空格隔开的样式名</li>
<li><p>.removeClass(function(index, class)) ==&gt; 返回一个或多个要被移除的样式名的函数</p>
<p><strong>说明：</strong>如果 .removeClass() 没有参数，则会移除所有的样式类</p>
</li>
</ul>
</li>
<li><p>.toggleClass()<br> 在匹配的元素集合中的每个元素上添加或删除一个或多个样式类，取决于这个样式是否存在，即：如果存在就删除一个类，如果不存在就添加一个类</p>
<ul>
<li>.toggleClass(className) ==&gt; 切换类</li>
<li>.toggleClass(className,switch) ==&gt; 一个布尔值，用来判断样式是否应该被添加或移除</li>
<li>.toggleClass(function(index, class, switch){})</li>
</ul>
</li>
<li><p>.css()<br> 获取元素样式属性的计算值或者设置元素的 CSS 属性<br> <strong>获取</strong></p>
<ul>
<li>.css( “propertyName” ) ==&gt; 获取匹配元素集合中的第一个元素的样式属性的计算值</li>
<li><p>.css( “propertyNames” ) ==&gt; 传递一组数组，返回一个对象结果</p>
<p><strong>设置</strong></p>
</li>
<li>.css( ‘propertyName’, ‘value’ ) ==&gt; 设置 CSS</li>
<li>.css( ‘propertyName’, function ) ==&gt; 可以传入一个回调函数，返回取到对应的值进行处理</li>
<li><p>.css( ‘properties ) ==&gt; 可以传入一个对象，同时设置多个样式，用 <code>{ }</code> 括起</p>
<p><strong>说明：</strong></p>
<ol>
<li>通过 .css() 方法设置的样式属性优先级要高于 .addClass() 方法</li>
<li>若是<strong>静态结构</strong>，确定了布局规则，使用 <strong>.addClass()</strong> 方法增加类</li>
<li>若是<strong>动态的 HTML 结构</strong>，在不确定布局或者经常要变化的情况下，使用 <strong>.css()</strong> 方法</li>
<li>.addClass() 不能获取到指定样式的属性值，.css() 可以获取到指定的样式值</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
            
        
  
  <div class="tags">
    <a href="/tags/jQuery/">jQuery</a>
  </div>

                
      

      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  

  <nav id="pagination">
  
    <a href="/archives/2018/page/3/" class="alignleft prev">Prev</a>
  
  
    <a href="/archives/2018/page/5/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav>


</div></div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/CSS/">CSS</a><small>10</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>9</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript-进阶/">JavaScript 进阶</a><small>4</small></li>
  
    <li><a href="/tags/Plugin/">Plugin</a><small>1</small></li>
  
    <li><a href="/tags/jQuery/">jQuery</a><small>4</small></li>
  
    <li><a href="/tags/前端基础/">前端基础</a><small>4</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>1</small></li>
  
    <li><a href="/tags/总结/">总结</a><small>4</small></li>
  
  </ul>
</div>


</aside>
    
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="aligncenter">
  
  &copy; 2018 吴博文
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>



<div id="scroll2top">
<img src="/scroll2top/arrow.png"/>
</div>
<script src="/scroll2top/scroll2top.min.js"></script>
<div id="winterland">
  <canvas></canvas>
</div>
<script src="/js/winterland.min.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="https://www.zybuluo.com/static/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>


  
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59a3e3079f1b7ad5"></script> 
  

</body>
</html>
